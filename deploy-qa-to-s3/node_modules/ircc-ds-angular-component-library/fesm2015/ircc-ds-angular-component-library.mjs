import * as i0 from '@angular/core';
import { Injectable, SecurityContext, Pipe, Component, ViewChild, Input, EventEmitter, Output, QueryList, ViewChildren, HostListener, Directive, NgModule, forwardRef, PLATFORM_ID, Inject } from '@angular/core';
import * as i1 from '@ngx-translate/core';
import { TranslateModule } from '@ngx-translate/core';
import * as i1$1 from '@angular/platform-browser';
import { BehaviorSubject, Subject, Subscription, filter } from 'rxjs';
import * as i2 from '@angular/common';
import { CommonModule, isPlatformBrowser } from '@angular/common';
import * as i3 from '@angular/router';
import { RouterModule } from '@angular/router';
import * as i3$1 from '@angular/cdk/scrolling';
import { ScrollingModule } from '@angular/cdk/scrolling';
import * as i4 from '@angular/cdk-experimental/scrolling';
import { ScrollingModule as ScrollingModule$1 } from '@angular/cdk-experimental/scrolling';
import * as i5 from '@angular/forms';
import { FormGroup, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule, FormControl } from '@angular/forms';

class StandAloneFunctions {
    constructor(translate) {
        this.translate = translate;
    }
    getErrorAria(formGroup, id, errorMessages) {
        var _a, _b;
        let returnError = '';
        if (((_a = formGroup.get(id)) === null || _a === void 0 ? void 0 : _a.dirty) && ((_b = formGroup.get(id)) === null || _b === void 0 ? void 0 : _b.invalid)) {
            errorMessages === null || errorMessages === void 0 ? void 0 : errorMessages.forEach((error) => {
                var _a, _b;
                if ((_b = (_a = formGroup.get(id)) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[error.key]) {
                    returnError === ''
                        ? (returnError += this.translate.instant(error.errorLOV))
                        : (returnError += ', ' + this.translate.instant(error.errorLOV));
                }
            });
            returnError += '.';
        }
        return returnError;
    }
    /**
     * When run, returns an IErrorIds object. It generates IDs based on the errorMessages object
     * and which errors are currently in effect, thereby ensuring that the first element is given
     * an id ending in _error0
     * @param formGroup
     * @param id of the parent (input) component
     * @param errorMessages: IErrorPairs[]
     * @returns errorIds: IErrorIDs[]
     */
    getErrorIds(formGroup, id, errorMessages) {
        var _a;
        let errorIds = [];
        errorMessages === null || errorMessages === void 0 ? void 0 : errorMessages.forEach((message) => {
            errorIds.push({ key: message.key, errorLOV: message.errorLOV });
        });
        //Code block to get errors that have occurred before the statusChange obs is activated
        let i = 0;
        errorIds.forEach((error) => {
            var _a, _b;
            if ((_b = (_a = formGroup.get(id)) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[error.key]) {
                error.id = id + '_error' + i;
                i++;
            }
        });
        (_a = formGroup.get(id)) === null || _a === void 0 ? void 0 : _a.statusChanges.subscribe((change) => {
            let i = 0;
            errorIds.forEach((error) => {
                var _a, _b;
                if ((_b = (_a = formGroup.get(id)) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[error.key]) {
                    error.id = id + '_error' + i;
                    i++;
                }
            });
        });
        return errorIds;
    }
    /**
     * Given a form group & form control id, set errors & mark as touch on specific form controls
     * @param formGroup
     * @param formID ID of form control
     * @param errorKeys
     */
    setFormErrors(formGroup, formID, errorKeys) {
        var _a, _b, _c;
        const errorVals = {};
        if (errorKeys.length === 0) {
            (_a = formGroup.get(formID)) === null || _a === void 0 ? void 0 : _a.setErrors(null);
        }
        else {
            errorKeys.forEach((error) => {
                errorVals[error] = true;
            });
            (_b = formGroup.get(formID)) === null || _b === void 0 ? void 0 : _b.setErrors(errorVals);
            (_c = formGroup.get(formID)) === null || _c === void 0 ? void 0 : _c.markAsTouched();
        }
    }
    /**
     * Create a label config - for use inside form input components
     * @param formGroup
     * @param id
     * @param parentID
     * @param errorMessages
     * @param label
     * @param desc
     * @param hint
     * @param required
     */
    makeLabelConfig(formGroup, parentID, errorMessages, label, desc, hint, required, iconButton, topLabel) {
        const config = {
            formGroup: formGroup,
            parentID: parentID,
            errorMessages: errorMessages,
            label: label,
            desc: desc,
            hint: hint,
            required: required,
            iconButton: iconButton,
            topLabel: topLabel
        };
        return config;
    }
    /**
     * A function designed to deal with how AWFUL Safari is. Safari does not consider touched to be a valid state in <body>,
     * therefore this is needed to force it to acknowledge the state.
     * @param formGroup
     * @param id of the parent (input) component
     */
    wasTouched(formGroup, id) {
        var _a;
        (_a = formGroup.get(id)) === null || _a === void 0 ? void 0 : _a.markAsTouched();
    }
    /**
     * Get the current base url.
     * @param baseUrl
     * @param baseUrlKey Translation key of base url
     */
    getBaseUrl(baseUrl = '', baseUrlKey) {
        const curLang = this.translate.currentLang;
        const langKey = curLang === 'en-US' || curLang === 'en' ? 'en' : 'fr';
        let i = window.location.href.slice(window.location.href.indexOf(langKey), window.location.href.length);
        i = i.split('/');
        let index = 0;
        for (const j of i) {
            if (j === this.translate.instant(baseUrlKey !== null && baseUrlKey !== void 0 ? baseUrlKey : '')) {
                baseUrl += '/' + j;
                // Should halt when find the base url segment
                break;
            }
            else if (index !== i.length - 1) {
                baseUrl += '/' + j;
                index += 1;
            }
        }
        if (baseUrl[baseUrl.length] !== '/')
            baseUrl += '/';
        return baseUrl;
    }
}
StandAloneFunctions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: StandAloneFunctions, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
StandAloneFunctions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: StandAloneFunctions, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: StandAloneFunctions, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; } });

var DropdownTypes;
(function (DropdownTypes) {
    DropdownTypes["input"] = "input";
    DropdownTypes["cta"] = "cta";
})(DropdownTypes || (DropdownTypes = {}));
var DropDownActions;
(function (DropDownActions) {
    DropDownActions["addApplications"] = "add-applications";
    DropDownActions["filterApplications"] = "filter-applications";
})(DropDownActions || (DropDownActions = {}));
var DSSizes;
(function (DSSizes) {
    DSSizes["large"] = "large";
    DSSizes["small"] = "small";
})(DSSizes || (DSSizes = {}));
var DSFullSizes;
(function (DSFullSizes) {
    DSFullSizes["large"] = "large";
    DSFullSizes["small"] = "small";
    DSFullSizes["extraSmall"] = "extraSmall";
})(DSFullSizes || (DSFullSizes = {}));
var DSOrientations;
(function (DSOrientations) {
    DSOrientations["horizontal"] = "horizontal";
    DSOrientations["vertical"] = "vertical";
})(DSOrientations || (DSOrientations = {}));
var DSViewPortSize;
(function (DSViewPortSize) {
    DSViewPortSize[DSViewPortSize["default"] = 0] = "default";
    DSViewPortSize[DSViewPortSize["mobile"] = 768] = "mobile";
    DSViewPortSize[DSViewPortSize["tablet"] = 992] = "tablet";
    DSViewPortSize[DSViewPortSize["desktop"] = 1366] = "desktop";
})(DSViewPortSize || (DSViewPortSize = {}));

class autocompletePipe {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    transform(value, searched = '') {
        if (searched.length === 0) {
            return this.sanitize(`${value}`);
        }
        return this.sanitize(`<span class="bolded">${this.replace(value, searched)}</span>`);
    }
    replace(str, searched) {
        return str.replace(new RegExp(`(${searched})`, 'i'), '<span class="normal">$1</span>');
    }
    sanitize(str) {
        return this.domSanitizer.sanitize(SecurityContext.HTML, str);
    }
}
autocompletePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: autocompletePipe, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe });
autocompletePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: autocompletePipe, name: "autocomplete" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: autocompletePipe, decorators: [{
            type: Pipe,
            args: [{ name: 'autocomplete' }]
        }], ctorParameters: function () { return [{ type: i1$1.DomSanitizer }]; } });

class BannerService {
    constructor() {
        this.bannerSubj = new BehaviorSubject({
            id: ''
        });
        this.bannerSubjObs$ = this.bannerSubj.asObservable();
        this.toggleSubj = new BehaviorSubject({
            id: '',
            value: false
        });
        this.toggleSubjObs$ = this.toggleSubj.asObservable();
        this.setBanner = (update) => {
            this.bannerSubj.next(update);
        };
        this.toggleBanner = (id, value) => {
            this.toggleSubj.next({ id, value });
        };
    }
}
BannerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BannerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
BannerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BannerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BannerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class IconComponent {
    constructor() {
        this.config = {};
    }
    ngOnChanges(changes) {
        if (changes['config'] && !changes['config'].firstChange) {
            const change = changes['config'].currentValue;
            const keys = Object.keys(change);
            let spanContent = `<i class='font-icon `;
            keys.includes('FA_keywords')
                ? (spanContent += `${change['FA_keywords']}'`)
                : null;
            spanContent += `></i>`;
            this.iconSpan.nativeElement.innerHTML = spanContent;
        }
        if (changes['size'] && !changes['size'].firstChange)
            this.config.size = this.size;
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.ariaLabel)
            this.config.ariaLabel = this.ariaLabel;
        if (this.FA_keywords)
            this.config.FA_keywords = this.FA_keywords;
        if (this.size)
            this.config.size = this.size;
        if (this.config.ariaLabel === '') {
            delete this.config.ariaLabel;
        }
    }
}
IconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: { config: "config", ariaLabel: "ariaLabel", FA_keywords: "FA_keywords", size: "size" }, viewQueries: [{ propertyName: "iconSpan", first: true, predicate: ["iconSpan"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<span\n  class=\"ds-icon-container\"\n  [ngClass]=\"config.size\"\n>\n  <span\n    #iconSpan\n    [attr.aria-hidden]=\"config.ariaLabel ? false : true\"\n    [attr.aria-label]=\"config.ariaLabel ? config.ariaLabel : null\"\n    [attr.role]=\"config.ariaLabel ? 'img' : null\"\n  >\n    <i\n      class=\"font-icon\"\n      [ngClass]=\"config.FA_keywords\"\n    ></i>\n  </span>\n</span>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IconComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-icon', template: "<span\n  class=\"ds-icon-container\"\n  [ngClass]=\"config.size\"\n>\n  <span\n    #iconSpan\n    [attr.aria-hidden]=\"config.ariaLabel ? false : true\"\n    [attr.aria-label]=\"config.ariaLabel ? config.ariaLabel : null\"\n    [attr.role]=\"config.ariaLabel ? 'img' : null\"\n  >\n    <i\n      class=\"font-icon\"\n      [ngClass]=\"config.FA_keywords\"\n    ></i>\n  </span>\n</span>\n" }]
        }], propDecorators: { iconSpan: [{
                type: ViewChild,
                args: ['iconSpan']
            }], config: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], FA_keywords: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

var ButtonCategories;
(function (ButtonCategories) {
    ButtonCategories["primary"] = "primary";
    ButtonCategories["secondary"] = "secondary";
    ButtonCategories["plain"] = "plain";
})(ButtonCategories || (ButtonCategories = {}));
var ButtonSize;
(function (ButtonSize) {
    ButtonSize["small"] = "small";
    ButtonSize["large"] = "large";
})(ButtonSize || (ButtonSize = {}));
var ButtonColor;
(function (ButtonColor) {
    ButtonColor["critical"] = "critical";
    ButtonColor["CTA"] = "CTA";
})(ButtonColor || (ButtonColor = {}));
// export enum ButtonType {
//     button = 'button',
//     submit = 'submit',
//     reset = 'reset'
// }
var ButtonIconDirection;
(function (ButtonIconDirection) {
    ButtonIconDirection["left"] = "left";
    ButtonIconDirection["right"] = "right";
})(ButtonIconDirection || (ButtonIconDirection = {}));
class ButtonComponent {
    constructor() {
        this.config = {
            id: ''
        };
        this.id = '';
        this.btnAction = new EventEmitter();
    }
    ngOnInit() {
        this.id !== '' ? (this.config.id = this.id) : undefined;
        this.category === undefined
            ? undefined
            : (this.config.category = this.category);
        this.size === undefined ? undefined : (this.config.size = this.size);
        this.color === undefined ? undefined : (this.config.color = this.color);
        this.ariaLabel !== undefined
            ? (this.config.ariaLabel = this.ariaLabel)
            : undefined;
        this.disabled !== undefined
            ? (this.config.disabled = this.disabled)
            : undefined;
        this.tabIndex !== undefined
            ? (this.config.tabIndex = this.tabIndex)
            : undefined;
        this.fill !== undefined ? (this.config.fill = this.fill) : undefined;
        if (this.icon || this.config.icon) {
            this.config.icon = this.icon ? this.icon : this.config.icon;
            this.config.iconDirection = this.iconDirection
                ? this.iconDirection
                : this.config.iconDirection;
            this.config.iconDirection = this.config.iconDirection
                ? this.config.iconDirection
                : 'left';
        }
        else {
            this.config.icon = undefined;
            this.config.iconDirection = undefined;
        }
    }
    clickEvent(id) {
        this.btnAction.emit(id);
    }
}
ButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ButtonComponent, selector: "ircc-cl-lib-button", inputs: { config: "config", id: "id", category: "category", size: "size", color: "color", ariaLabel: "ariaLabel", disabled: "disabled", icon: "icon", iconDirection: "iconDirection", tabIndex: "tabIndex", fill: "fill" }, outputs: { btnAction: "btnAction" }, ngImport: i0, template: "<button\n  [attr.aria-label]=\"config.ariaLabel\"\n  [attr.color]=\"config.color\"\n  [attr.category]=\"config.category\"\n  [attr.size]=\"config.size\"\n  [attr.tabIndex]=\"config.tabIndex\"\n  [ngClass]=\"config.iconDirection\"\n  (click)=\"clickEvent(config.id)\"\n  class=\"lib-button\"\n  [id]=\"config.id\"\n  [attr.fill-container]=\"config.fill ? true : null\"\n>\n  <div class=\"button-content-container\">\n    <span\n      class=\"icon\"\n      *ngIf=\"config.icon\"\n    >\n      <ircc-cl-lib-icon\n        [config]=\"{ FA_keywords: config.icon }\"\n        [size]=\"config.size\"\n      ></ircc-cl-lib-icon>\n    </span>\n    <span class=\"text\"><ng-content></ng-content></span>\n  </div>\n</button>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-button', template: "<button\n  [attr.aria-label]=\"config.ariaLabel\"\n  [attr.color]=\"config.color\"\n  [attr.category]=\"config.category\"\n  [attr.size]=\"config.size\"\n  [attr.tabIndex]=\"config.tabIndex\"\n  [ngClass]=\"config.iconDirection\"\n  (click)=\"clickEvent(config.id)\"\n  class=\"lib-button\"\n  [id]=\"config.id\"\n  [attr.fill-container]=\"config.fill ? true : null\"\n>\n  <div class=\"button-content-container\">\n    <span\n      class=\"icon\"\n      *ngIf=\"config.icon\"\n    >\n      <ircc-cl-lib-icon\n        [config]=\"{ FA_keywords: config.icon }\"\n        [size]=\"config.size\"\n      ></ircc-cl-lib-icon>\n    </span>\n    <span class=\"text\"><ng-content></ng-content></span>\n  </div>\n</button>\n" }]
        }], propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], category: [{
                type: Input
            }], size: [{
                type: Input
            }], color: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], disabled: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconDirection: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], fill: [{
                type: Input
            }], btnAction: [{
                type: Output
            }] } });

var IconButtonCategories;
(function (IconButtonCategories) {
    IconButtonCategories["primary"] = "primary";
    IconButtonCategories["critical"] = "critical";
    IconButtonCategories["custom"] = "custom";
})(IconButtonCategories || (IconButtonCategories = {}));
const CLASS_X_MARK = 'fa-light fa-xmark';
const CLASS_TRASHCAN = 'fa-light fa-trash-can';
class IconButtonComponent {
    constructor() {
        this.config = {
            id: '',
            category: IconButtonCategories.primary,
            ariaLabel: ''
        };
        this.id = '';
        this.clickEvent = new EventEmitter();
        // Mapping of icons to category
        this.iconConfigs = {
            primary: {
                class: CLASS_X_MARK,
                color: 'var(--text-primary)'
            },
            critical: {
                class: CLASS_TRASHCAN,
                color: 'var(--critical-text)'
            }
        };
    }
    ngOnInit() {
        if (this.id)
            this.config.id = this.id;
        if (this.category)
            this.config.category = this.category;
        if (this.size)
            this.config.size = this.size;
        if (this.ariaLabel)
            this.config.ariaLabel = this.ariaLabel;
        if (this.disabled)
            this.config.disabled = this.disabled;
        if (this.icon)
            this.config.icon =
                this.config.category === IconButtonCategories.custom
                    ? this.icon
                    : this.iconConfigs[this.config.category];
        else if (!this.icon && this.config.icon)
            this.config.icon =
                this.config.category === IconButtonCategories.custom
                    ? this.config.icon
                    : this.iconConfigs[this.config.category];
        else
            this.config.icon = this.iconConfigs[this.config.category];
    }
    buttonClick(id = this.config.id) {
        this.clickEvent.emit(id);
    }
}
IconButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IconButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IconButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IconButtonComponent, selector: "ircc-cl-lib-icon-button", inputs: { config: "config", id: "id", category: "category", size: "size", ariaLabel: "ariaLabel", disabled: "disabled", icon: "icon" }, outputs: { clickEvent: "clickEvent" }, ngImport: i0, template: "<button\n  category=\"plain\"\n  [id]=\"config.id\"\n  [attr.aria-label]=\"config.ariaLabel\"\n  [disabled]=\"config.disabled\"\n  (click)=\"buttonClick()\"\n  [class]=\"config.category + ' ' + config.size\"\n  class=\"icon-btn\"\n>\n  <span>\n    <ircc-cl-lib-icon\n      [config]=\"{ FA_keywords: config.icon?.class }\"\n      [style.color]=\"config.icon?.color\"\n      [ariaLabel]=\"config.icon?.class\"\n    ></ircc-cl-lib-icon>\n  </span>\n</button>\n", dependencies: [{ kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IconButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-icon-button', template: "<button\n  category=\"plain\"\n  [id]=\"config.id\"\n  [attr.aria-label]=\"config.ariaLabel\"\n  [disabled]=\"config.disabled\"\n  (click)=\"buttonClick()\"\n  [class]=\"config.category + ' ' + config.size\"\n  class=\"icon-btn\"\n>\n  <span>\n    <ircc-cl-lib-icon\n      [config]=\"{ FA_keywords: config.icon?.class }\"\n      [style.color]=\"config.icon?.color\"\n      [ariaLabel]=\"config.icon?.class\"\n    ></ircc-cl-lib-icon>\n  </span>\n</button>\n" }]
        }], propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], category: [{
                type: Input
            }], size: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], disabled: [{
                type: Input
            }], icon: [{
                type: Input
            }], clickEvent: [{
                type: Output
            }] } });

var BannerType;
(function (BannerType) {
    BannerType[""] = "";
    BannerType["generic"] = "generic";
    BannerType["info"] = "info";
    BannerType["critical"] = "critical";
    BannerType["success"] = "success";
    BannerType["warning"] = "warning";
})(BannerType || (BannerType = {}));
var BannerSize;
(function (BannerSize) {
    BannerSize["large"] = "large";
    BannerSize["small"] = "small";
})(BannerSize || (BannerSize = {}));
var CTAType;
(function (CTAType) {
    CTAType["link"] = "link";
    CTAType["button"] = "button";
})(CTAType || (CTAType = {}));
class BannerComponent {
    constructor(bannerService, renderer) {
        this.bannerService = bannerService;
        this.renderer = renderer;
        this.lineVisible = true;
        this.textId = '';
        this.config = {
            id: ''
        };
        this.btnEvent = new EventEmitter();
        this.iconConfig = {
            id: '',
            category: 'custom',
            icon: {
                class: 'fa-solid fa-xmark',
                color: 'var(--text-primary)'
            }
        };
    }
    eventHandler(emitValue) {
        var _a;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.id) {
            this.bannerService.toggleBanner(this.config.id, false);
        }
    }
    toggleLine() {
        var _a, _b, _c;
        let containerHeight = (_a = document.getElementById(this.textId)) === null || _a === void 0 ? void 0 : _a.offsetHeight;
        let el = document.querySelector(`#${(_b = this.config) === null || _b === void 0 ? void 0 : _b.id} .banner-line`);
        let ctas = document.querySelector(`#${(_c = this.config) === null || _c === void 0 ? void 0 : _c.id} .banner-ctas`);
        if ((containerHeight && el && containerHeight > 35) ||
            (el && containerHeight && containerHeight > 23 && ctas)) {
            el.style.display = 'block';
        }
        else if (el) {
            el.style.display = 'none';
        }
    }
    ngOnInit() {
        var _a, _b, _c, _d;
        //set config from individual options, if present
        if (this.id)
            this.config.id = this.id;
        if (this.title)
            this.config.title = this.title;
        if (this.content)
            this.config.content = this.content;
        if (this.type)
            this.config.type = this.type;
        if (this.rounded)
            this.config.rounded = this.rounded;
        if (this.dismissible)
            this.config.dismissible = this.dismissible;
        if (this.cta)
            this.config.cta = this.cta;
        if (this.size)
            this.config.size = this.size;
        if (this.ariaDissmissible)
            this.config.ariaDissmissible = this.ariaDissmissible;
        this.iconConfig.id = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.id) + '_closeBtn';
        this.textId = ((_b = this.config) === null || _b === void 0 ? void 0 : _b.id) + '_text';
        if ((_c = this.config) === null || _c === void 0 ? void 0 : _c.cta) {
            (_d = this.config) === null || _d === void 0 ? void 0 : _d.cta.forEach((item) => {
                if (item.ariaLabel && item.btnConfig)
                    item.btnConfig.ariaLabel = item.ariaLabel;
            });
        }
        if (!this.config.ariaDissmissible || this.config.ariaDissmissible === '') {
            if (this.config.dismissible) {
                this.config.ariaDissmissible = 'close';
            }
        }
        this.configSub = this.bannerService.bannerSubjObs$.subscribe((response) => {
            if (this.config.id === response.id) {
                this.config = response;
            }
        });
        this.configSubToggle = this.bannerService.toggleSubjObs$.subscribe((response) => {
            if (this.config.id === response.id) {
                this.toggleVisible(response.value);
            }
        });
    }
    toggleVisible(value) {
        var _a, _b;
        if ((_a = this.banner) === null || _a === void 0 ? void 0 : _a.nativeElement) {
            if (value === false) {
                this.renderer.addClass(this.banner.nativeElement, 'bannerDismissed');
                (_b = this.btnEvent) === null || _b === void 0 ? void 0 : _b.emit(this.config.id);
                setTimeout(() => {
                    var _a;
                    if ((_a = this.banner) === null || _a === void 0 ? void 0 : _a.nativeElement) {
                        this.renderer.removeClass(this.banner.nativeElement, 'bannerDismissed');
                        this.renderer.addClass(this.banner.nativeElement, 'noDisplay');
                    }
                }, 700);
            }
            else {
                this.renderer.removeClass(this.banner.nativeElement, 'bannerDismissed');
                this.renderer.removeClass(this.banner.nativeElement, 'noDisplay');
            }
        }
    }
    ngAfterViewInit() {
        this.toggleLine();
    }
    ngAfterViewChecked() {
        this.toggleLine();
    }
}
BannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BannerComponent, deps: [{ token: BannerService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
BannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: BannerComponent, selector: "ircc-cl-lib-banner", inputs: { config: "config", id: "id", title: "title", content: "content", type: "type", rounded: "rounded", dismissible: "dismissible", cta: "cta", size: "size", ariaDissmissible: "ariaDissmissible" }, outputs: { btnEvent: "btnEvent" }, viewQueries: [{ propertyName: "banner", first: true, predicate: ["banner"], descendants: true }], ngImport: i0, template: "<div\n  (window:resize)=\"toggleLine()\"\n  class=\"banner-component\"\n  class=\"{{ config?.size }}\"\n  id=\"{{ config?.id }}\"\n  #banner\n  [ngClass]=\"{\n    rounded: config?.rounded,\n    information: config?.type === 'info',\n    success: config?.type === 'success',\n    warning: config?.type === 'warning',\n    critical: config?.type === 'critical'\n  }\"\n>\n  <div class=\"banner-container\">\n    <div\n      class=\"banner-left\"\n      *ngIf=\"config?.type !== 'generic' && config?.type\"\n    >\n      <ng-container [ngSwitch]=\"config?.type\">\n        <div *ngSwitchCase=\"'critical'\">\n          <i class=\"fa-circle-exclamation fa-light banner-icon\"></i>\n        </div>\n        <div *ngSwitchCase=\"'success'\">\n          <i class=\"fa-circle-check fa-light banner-icon\"></i>\n        </div>\n        <div *ngSwitchCase=\"'info'\">\n          <i class=\"fa-circle-info fa-light banner-icon\"></i>\n        </div>\n        <div *ngSwitchCase=\"'warning'\">\n          <i class=\"fa-triangle-exclamation fa-light banner-icon\"></i>\n        </div>\n      </ng-container>\n      <div\n        class=\"banner-line\"\n        [ngClass]=\"{ hidden: !lineVisible }\"\n      ></div>\n    </div>\n    <div class=\"banner-right\">\n      <div class=\"banner-body\">\n        <div\n          class=\"banner-text\"\n          id=\"{{ textId }}\"\n        >\n          <div\n            class=\"banner-title h6 emphasis\"\n            *ngIf=\"config?.title\"\n          >\n            {{ config?.title || '' | translate }}\n          </div>\n          <div\n            class=\"banner-content\"\n            [innerHTML]=\"config?.content || '' | translate\"\n            *ngIf=\"config?.content\"\n          ></div>\n        </div>\n      </div>\n      <div\n        class=\"banner-ctas\"\n        *ngIf=\"config?.cta\"\n      >\n        <ng-container *ngFor=\"let cta of config?.cta; let index = index\">\n          <ircc-cl-lib-button\n            *ngIf=\"cta?.type === 'button'\"\n            [id]=\"'cta_' + index\"\n            [category]=\"cta?.btnConfig?.category\"\n            [color]=\"cta?.btnConfig?.color\"\n            [size]=\"config.size\"\n            [ariaLabel]=\"cta?.btnConfig?.ariaLabel\"\n            [disabled]=\"cta?.btnConfig?.disabled\"\n            [icon]=\"cta?.btnConfig?.icon\"\n            [iconDirection]=\"cta?.btnConfig?.iconDirection\"\n            >{{ cta.text | translate }}</ircc-cl-lib-button\n          >\n          <a\n            class=\"cta-link\"\n            *ngIf=\"cta?.type === 'link'\"\n            [routerLink]=\"cta?.linkConfig | translate\"\n            [attr.aria-label]=\"cta?.ariaLabel\"\n            >{{ cta.text | translate }}</a\n          >\n        </ng-container>\n      </div>\n    </div>\n  </div>\n  <div class=\"banner-btn\">\n    <ircc-cl-lib-icon-button\n      [ariaLabel]=\"config?.ariaDissmissible || '' | translate\"\n      size=\"extraSmall\"\n      class=\"banner-close\"\n      *ngIf=\"config?.dismissible\"\n      [config]=\"iconConfig\"\n      (clickEvent)=\"eventHandler($event)\"\n    ></ircc-cl-lib-icon-button>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: ButtonComponent, selector: "ircc-cl-lib-button", inputs: ["config", "id", "category", "size", "color", "ariaLabel", "disabled", "icon", "iconDirection", "tabIndex", "fill"], outputs: ["btnAction"] }, { kind: "component", type: IconButtonComponent, selector: "ircc-cl-lib-icon-button", inputs: ["config", "id", "category", "size", "ariaLabel", "disabled", "icon"], outputs: ["clickEvent"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BannerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-banner', template: "<div\n  (window:resize)=\"toggleLine()\"\n  class=\"banner-component\"\n  class=\"{{ config?.size }}\"\n  id=\"{{ config?.id }}\"\n  #banner\n  [ngClass]=\"{\n    rounded: config?.rounded,\n    information: config?.type === 'info',\n    success: config?.type === 'success',\n    warning: config?.type === 'warning',\n    critical: config?.type === 'critical'\n  }\"\n>\n  <div class=\"banner-container\">\n    <div\n      class=\"banner-left\"\n      *ngIf=\"config?.type !== 'generic' && config?.type\"\n    >\n      <ng-container [ngSwitch]=\"config?.type\">\n        <div *ngSwitchCase=\"'critical'\">\n          <i class=\"fa-circle-exclamation fa-light banner-icon\"></i>\n        </div>\n        <div *ngSwitchCase=\"'success'\">\n          <i class=\"fa-circle-check fa-light banner-icon\"></i>\n        </div>\n        <div *ngSwitchCase=\"'info'\">\n          <i class=\"fa-circle-info fa-light banner-icon\"></i>\n        </div>\n        <div *ngSwitchCase=\"'warning'\">\n          <i class=\"fa-triangle-exclamation fa-light banner-icon\"></i>\n        </div>\n      </ng-container>\n      <div\n        class=\"banner-line\"\n        [ngClass]=\"{ hidden: !lineVisible }\"\n      ></div>\n    </div>\n    <div class=\"banner-right\">\n      <div class=\"banner-body\">\n        <div\n          class=\"banner-text\"\n          id=\"{{ textId }}\"\n        >\n          <div\n            class=\"banner-title h6 emphasis\"\n            *ngIf=\"config?.title\"\n          >\n            {{ config?.title || '' | translate }}\n          </div>\n          <div\n            class=\"banner-content\"\n            [innerHTML]=\"config?.content || '' | translate\"\n            *ngIf=\"config?.content\"\n          ></div>\n        </div>\n      </div>\n      <div\n        class=\"banner-ctas\"\n        *ngIf=\"config?.cta\"\n      >\n        <ng-container *ngFor=\"let cta of config?.cta; let index = index\">\n          <ircc-cl-lib-button\n            *ngIf=\"cta?.type === 'button'\"\n            [id]=\"'cta_' + index\"\n            [category]=\"cta?.btnConfig?.category\"\n            [color]=\"cta?.btnConfig?.color\"\n            [size]=\"config.size\"\n            [ariaLabel]=\"cta?.btnConfig?.ariaLabel\"\n            [disabled]=\"cta?.btnConfig?.disabled\"\n            [icon]=\"cta?.btnConfig?.icon\"\n            [iconDirection]=\"cta?.btnConfig?.iconDirection\"\n            >{{ cta.text | translate }}</ircc-cl-lib-button\n          >\n          <a\n            class=\"cta-link\"\n            *ngIf=\"cta?.type === 'link'\"\n            [routerLink]=\"cta?.linkConfig | translate\"\n            [attr.aria-label]=\"cta?.ariaLabel\"\n            >{{ cta.text | translate }}</a\n          >\n        </ng-container>\n      </div>\n    </div>\n  </div>\n  <div class=\"banner-btn\">\n    <ircc-cl-lib-icon-button\n      [ariaLabel]=\"config?.ariaDissmissible || '' | translate\"\n      size=\"extraSmall\"\n      class=\"banner-close\"\n      *ngIf=\"config?.dismissible\"\n      [config]=\"iconConfig\"\n      (clickEvent)=\"eventHandler($event)\"\n    ></ircc-cl-lib-icon-button>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: BannerService }, { type: i0.Renderer2 }]; }, propDecorators: { banner: [{
                type: ViewChild,
                args: ['banner', { static: false }]
            }], config: [{
                type: Input
            }], id: [{
                type: Input
            }], title: [{
                type: Input
            }], content: [{
                type: Input
            }], type: [{
                type: Input
            }], rounded: [{
                type: Input
            }], dismissible: [{
                type: Input
            }], cta: [{
                type: Input
            }], size: [{
                type: Input
            }], ariaDissmissible: [{
                type: Input
            }], btnEvent: [{
                type: Output
            }] } });

class TabsComponent {
    constructor(translate) {
        this.translate = translate;
        this.config = {
            id: '',
            showContent: true
        };
        this.valueChange = new EventEmitter();
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.id)
            this.config.id = this.id;
        if (this.tab)
            this.config.tab = this.tab;
        if (this.size)
            this.config.size = this.size;
        if (this.selected)
            this.config.selected = this.selected;
        if (this.showContent)
            this.config.showContent = this.showContent;
        if (this.config.selected === undefined && this.config.tab) {
            this.config.selected = this.config.tab[0].id;
            this.valueChange.emit(this.config.selected);
        }
    }
    setSelected(selectedID) {
        var _a, _b;
        if (selectedID)
            this.config.selected = selectedID; //set the selected tab
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.selected) {
            let tab = document.getElementById((_b = this.config) === null || _b === void 0 ? void 0 : _b.selected);
            let x = tab === null || tab === void 0 ? void 0 : tab.getBoundingClientRect().left;
            if (document.querySelector('.page-nav')) {
                let nav = document.querySelector('.page-nav');
                nav && x ? (nav.scrollLeft = x) : null;
            }
            this.valueChange.emit(selectedID);
        }
    }
}
TabsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: TabsComponent, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
TabsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: TabsComponent, selector: "ircc-cl-lib-tabs", inputs: { config: "config", id: "id", tab: "tab", size: "size", selected: "selected", showContent: "showContent" }, outputs: { valueChange: "valueChange" }, ngImport: i0, template: "<div class=\"{{ config.size }}\">\n  <nav class=\"page-nav\">\n    <div *ngFor=\"let val of config.tab\">\n      <button\n        *ngIf=\"val.id === config.selected\"\n        selected\n        class=\"tabs-btn\"\n        [id]=\"val.id\"\n        (click)=\"setSelected(val.id)\"\n        [attr.aria-label]=\"(val.title | translate) + ' selected'\"\n      >\n        {{ val.title || '' | translate }}\n      </button>\n      <button\n        *ngIf=\"val.id !== config.selected\"\n        class=\"tabs-btn\"\n        [id]=\"val.id\"\n        (click)=\"setSelected(val.id)\"\n      >\n        {{ val.title || '' | translate }}\n      </button>\n    </div>\n  </nav>\n  <ng-container *ngIf=\"config.showContent === true\">\n    <br />\n    <div class=\"col-lg-10\">\n      <div class=\"side-menu-content\">\n        <div *ngFor=\"let cont of config.tab\">\n          <div\n            *ngIf=\"cont.id === config.selected\"\n            class=\"content\"\n          >\n            {{ cont.value || '' | translate }}\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: TabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-tabs', template: "<div class=\"{{ config.size }}\">\n  <nav class=\"page-nav\">\n    <div *ngFor=\"let val of config.tab\">\n      <button\n        *ngIf=\"val.id === config.selected\"\n        selected\n        class=\"tabs-btn\"\n        [id]=\"val.id\"\n        (click)=\"setSelected(val.id)\"\n        [attr.aria-label]=\"(val.title | translate) + ' selected'\"\n      >\n        {{ val.title || '' | translate }}\n      </button>\n      <button\n        *ngIf=\"val.id !== config.selected\"\n        class=\"tabs-btn\"\n        [id]=\"val.id\"\n        (click)=\"setSelected(val.id)\"\n      >\n        {{ val.title || '' | translate }}\n      </button>\n    </div>\n  </nav>\n  <ng-container *ngIf=\"config.showContent === true\">\n    <br />\n    <div class=\"col-lg-10\">\n      <div class=\"side-menu-content\">\n        <div *ngFor=\"let cont of config.tab\">\n          <div\n            *ngIf=\"cont.id === config.selected\"\n            class=\"content\"\n          >\n            {{ cont.value || '' | translate }}\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], tab: [{
                type: Input
            }], size: [{
                type: Input
            }], selected: [{
                type: Input
            }], showContent: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

const TAG_LABELS_EN = [
    'In progress',
    'Completed',
    'Error',
    'Locked',
    'Not started'
];
const TAG_LABELS_FR = [
    'En cours',
    'Complété',
    'Erreur',
    'Verrouillé',
    'Pas commencé'
];
var TagType;
(function (TagType) {
    TagType["primary"] = "primary";
    TagType["success"] = "success";
    TagType["critical"] = "critical";
    TagType["locked"] = "locked";
    TagType["notStarted"] = "notStarted";
})(TagType || (TagType = {}));
class ProgressTagsComponent {
    constructor(translate) {
        this.translate = translate;
        this.text = [];
        this.config = {
            id: ''
        };
        this.id = '';
    }
    ngOnInit() {
        if (this.id)
            this.config.id = this.id;
        if (this.type)
            this.config.type = this.type;
        if (this.size)
            this.config.size = this.size;
        this.setTypeTitle();
        this.translate.onLangChange.subscribe(() => {
            this.setTypeTitle();
        });
    }
    ngOnChanges() {
        this.setTypeTitle();
    }
    setTypeTitle() {
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            this.text = TAG_LABELS_EN;
        }
        else {
            this.text = TAG_LABELS_FR;
        }
    }
}
ProgressTagsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ProgressTagsComponent, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
ProgressTagsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ProgressTagsComponent, selector: "ircc-cl-lib-progress-tags", inputs: { config: "config", id: "id", type: "type", size: "size" }, usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"{{ config.size }}\"\n  id=\"{{ config.id }}\"\n  class=\"tag-component\"\n  [ngClass]=\"{\n    success: config.type === 'success',\n    critical: config.type === 'critical',\n    neutral: config.type === 'locked' || config.type === 'notStarted'\n  }\"\n>\n  <div class=\"tag-container\">\n    <div class=\"tag-left\">\n      <ng-container [ngSwitch]=\"config.type\">\n        <div *ngSwitchCase=\"'success'\">\n          <i class=\"fa-circle-check fa-regular tag-icon\"></i>\n          <span class=\"content\">{{ text[1] }}</span>\n        </div>\n        <div *ngSwitchCase=\"'critical'\">\n          <i class=\"fa-circle-exclamation fa-regular tag-icon\"></i>\n          <span class=\"content\">{{ text[2] }}</span>\n        </div>\n        <div *ngSwitchCase=\"'locked'\">\n          <i class=\"fa-light fa-lock tag-icon\"></i>\n          <span class=\"content\">{{ text[3] }}</span>\n        </div>\n        <div *ngSwitchCase=\"'notStarted'\">\n          <i class=\"fa-light fa-circle tag-icon\"></i>\n          <span class=\"content\">{{ text[4] }}</span>\n        </div>\n        <div *ngSwitchDefault>\n          <i class=\"fa-regular fa-circle-half-stroke tag-icon\"></i>\n          <span class=\"content\">{{ text[0] }}</span>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i2.NgSwitchDefault, selector: "[ngSwitchDefault]" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ProgressTagsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-progress-tags', template: "<div\n  class=\"{{ config.size }}\"\n  id=\"{{ config.id }}\"\n  class=\"tag-component\"\n  [ngClass]=\"{\n    success: config.type === 'success',\n    critical: config.type === 'critical',\n    neutral: config.type === 'locked' || config.type === 'notStarted'\n  }\"\n>\n  <div class=\"tag-container\">\n    <div class=\"tag-left\">\n      <ng-container [ngSwitch]=\"config.type\">\n        <div *ngSwitchCase=\"'success'\">\n          <i class=\"fa-circle-check fa-regular tag-icon\"></i>\n          <span class=\"content\">{{ text[1] }}</span>\n        </div>\n        <div *ngSwitchCase=\"'critical'\">\n          <i class=\"fa-circle-exclamation fa-regular tag-icon\"></i>\n          <span class=\"content\">{{ text[2] }}</span>\n        </div>\n        <div *ngSwitchCase=\"'locked'\">\n          <i class=\"fa-light fa-lock tag-icon\"></i>\n          <span class=\"content\">{{ text[3] }}</span>\n        </div>\n        <div *ngSwitchCase=\"'notStarted'\">\n          <i class=\"fa-light fa-circle tag-icon\"></i>\n          <span class=\"content\">{{ text[4] }}</span>\n        </div>\n        <div *ngSwitchDefault>\n          <i class=\"fa-regular fa-circle-half-stroke tag-icon\"></i>\n          <span class=\"content\">{{ text[0] }}</span>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], type: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

var IFlyoutOptionType;
(function (IFlyoutOptionType) {
    IFlyoutOptionType["text"] = "text";
    IFlyoutOptionType["checkbox"] = "checkbox";
    IFlyoutOptionType["dropdown"] = "dropdown";
    IFlyoutOptionType["line"] = "line";
    IFlyoutOptionType["heading"] = "heading";
})(IFlyoutOptionType || (IFlyoutOptionType = {}));
;
class FlyoutOptionComponent {
    constructor() {
        this.config = {
            id: '',
            value: 'Blank label'
        };
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.id)
            this.config.id = this.id;
        if (this.size)
            this.config.size = this.size;
        if (this.value)
            this.config.value = this.value;
        if (this.selected)
            this.config.selected = this.selected;
        if (this.active)
            this.config.active = this.active;
        if (this.disabled)
            this.config.disabled = this.disabled;
        if (this.type)
            this.config.type = this.type;
        if (this.clickable)
            this.config.clickable = this.clickable;
        if (this.config.type === undefined)
            this.config.type = 'text';
        if ((this.config.type === 'text' || 'checkbox' || 'dropdown') && this.config.clickable !== false && this.config.disabled !== true) {
            this.config.clickable = true;
        }
        else {
            this.config.clickable = false;
        }
    }
    ;
}
FlyoutOptionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: FlyoutOptionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FlyoutOptionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: FlyoutOptionComponent, selector: "ircc-cl-lib-flyout-option", inputs: { config: "config", id: "id", size: "size", value: "value", selected: "selected", active: "active", disabled: "disabled", type: "type", clickable: "clickable" }, ngImport: i0, template: "<div\n  class=\"option-container\"\n  [ngClass]=\"config.size\"\n>\n  <ircc-cl-lib-button\n    [category]=\"'plain'\"\n    [id]=\"config.id ? config.id : ''\"\n    role=\"option\"\n    [tabIndex]=\"-1\"\n  >\n    <div class=\"option-contents\">\n      <p\n        class=\"option-text\"\n        [innerHTML]=\"config.value || '' | translate\"\n      ></p>\n      <div *ngIf=\"config.selected\">\n        <span class=\"fa-solid fa-check option-check\"></span>\n      </div>\n    </div>\n  </ircc-cl-lib-button>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ButtonComponent, selector: "ircc-cl-lib-button", inputs: ["config", "id", "category", "size", "color", "ariaLabel", "disabled", "icon", "iconDirection", "tabIndex", "fill"], outputs: ["btnAction"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: FlyoutOptionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-flyout-option', template: "<div\n  class=\"option-container\"\n  [ngClass]=\"config.size\"\n>\n  <ircc-cl-lib-button\n    [category]=\"'plain'\"\n    [id]=\"config.id ? config.id : ''\"\n    role=\"option\"\n    [tabIndex]=\"-1\"\n  >\n    <div class=\"option-contents\">\n      <p\n        class=\"option-text\"\n        [innerHTML]=\"config.value || '' | translate\"\n      ></p>\n      <div *ngIf=\"config.selected\">\n        <span class=\"fa-solid fa-check option-check\"></span>\n      </div>\n    </div>\n  </ircc-cl-lib-button>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], value: [{
                type: Input
            }], selected: [{
                type: Input
            }], active: [{
                type: Input
            }], disabled: [{
                type: Input
            }], type: [{
                type: Input
            }], clickable: [{
                type: Input
            }] } });
;

var IFlyoutSelectTypes;
(function (IFlyoutSelectTypes) {
    IFlyoutSelectTypes["single"] = "single";
    IFlyoutSelectTypes["multi"] = "multi";
    IFlyoutSelectTypes["autocomplete"] = "autocomplete";
})(IFlyoutSelectTypes || (IFlyoutSelectTypes = {}));
const FLYOUT_CURRENT_SELECTED = {
    en: ' currently selected',
    fr: ' actuellement selectionne'
};
class FlyoutComponent {
    constructor(translate) {
        this.translate = translate;
        this.optionContainers = new QueryList();
        this.config = {
            id: '',
            options: []
        };
        //TODO: Must add the other config parameters
        this.isSelected = new EventEmitter();
        this.selectedIndex = -1;
        this.a11yText = '';
        this.currentSelected = '';
    }
    ngOnInit() {
        if (this.config.type === undefined)
            this.config.type = 'single';
        if (this.config.selected === undefined)
            this.config.selected = '';
        if (this.id)
            this.config.id = this.id;
        if (this.options)
            this.config.options = this.options;
        if (!this.config.options)
            this.config.options = [];
        if (this.disabled)
            this.config.disabled = this.disabled;
        if (this.selection)
            this.config.selection = this.selection;
        if (this.type)
            this.config.type = this.type;
        if (this.size)
            this.config.size = this.size;
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
    }
    calculateContainerHeight() {
        var _a;
        let numberOfItems = ((_a = this.config.options) === null || _a === void 0 ? void 0 : _a.length) || 0;
        const itemHeight = 36;
        const visibleItems = 5;
        if (numberOfItems < 2) {
            numberOfItems = 1.5;
        }
        if (numberOfItems && numberOfItems <= visibleItems) {
            return `${itemHeight * numberOfItems}px`;
        }
        return `${itemHeight * visibleItems}px`;
    }
    onClick(event) {
        let target = event.target;
        if (!target.classList.contains('option-contents') &&
            !target.classList.contains('dropdown')) {
            this.isSelected.emit(null);
        }
    }
    onArrowDown(event) {
        event.preventDefault();
        if (this.config.options) {
            let foundClickable = false;
            this.config.options
                .slice(this.selectedIndex + 1)
                .forEach((option, index) => {
                if (!foundClickable && option.clickable !== false) {
                    this.selectedIndex += index + 1;
                    this.highlightIndex(option.id);
                    foundClickable = true;
                }
            });
        }
    }
    onArrowUp(event) {
        event.preventDefault();
        if (this.config.options) {
            let foundClickable = false;
            this.config.options
                .slice(0, this.selectedIndex)
                .reverse()
                .forEach((option, index) => {
                if (!foundClickable && option.clickable !== false) {
                    this.selectedIndex -= index + 1;
                    this.highlightIndex(option.id);
                    foundClickable = true;
                }
            });
            // Ensure selectedIndex does not fall below 0
            this.selectedIndex = Math.max(this.selectedIndex, 0);
        }
    }
    onEnter(event) {
        event.preventDefault();
        //if the index hasn't changes through arrow navigation, emits our event but lets the parent know nothing was selected
        this.selectedIndex != -1
            ? this.optionSelected(this.selectedIndex)
            : this.isSelected.emit(null);
    }
    onHover() {
        // Remove default active state for 1st option when user hover on flyout
        if (this.config.options.length > 0 &&
            this.config.options[0].active === true)
            this.config.options[0].active = false;
    }
    //takes in the active index from HostListeners and sets the config option to active state which triggers styling
    highlightIndex(el_id) {
        var _a;
        if (el_id) {
            (_a = this.config.options) === null || _a === void 0 ? void 0 : _a.forEach((option) => {
                var _a, _b;
                if (option.id === el_id) {
                    option.active = true;
                    (_b = (_a = this.optionContainers
                        .toArray()[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.scrollIntoView({
                        behavior: 'smooth',
                        block: 'end'
                    });
                    console.log('HERE', option.value);
                    this.a11yText = option.value;
                    //updates a11yText to indicate currently selected item if scrolling through flyout again
                    if (option.selected)
                        this.a11yText += this.currentSelected;
                }
                else {
                    option.active = false;
                }
            });
        }
    }
    /**
     * setLang detects changes to the language toggle to serve the correct aria error text
     */
    setLang(lang) {
        lang === 'en' || lang === 'en-US'
            ? (this.currentSelected = FLYOUT_CURRENT_SELECTED.en)
            : (this.currentSelected = FLYOUT_CURRENT_SELECTED.fr);
    }
    //clears all selections by setting the option.selected to false
    clearOptions() {
        var _a, _b;
        (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.forEach((option) => {
            option.selected = false;
        });
    }
    //function takes in index value of current active option and selects it
    optionSelected(i) {
        if (this.config.options &&
            !this.config.options[i].selected &&
            this.config.options[i].clickable) {
            //setup for future multi select feature
            this.config.type !== 'multi'
                ? this.clearOptions()
                : /*this.config.selection = [].push(this.config.options[i]);*/ console.log('MULTI');
            this.config.options[i].selected = true;
            //emits the value of the selected index so it's visible to the parent
            this.isSelected.emit(this.config.options[i].value);
        }
    }
}
FlyoutComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: FlyoutComponent, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
FlyoutComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: FlyoutComponent, selector: "ircc-cl-lib-flyout", inputs: { config: "config", id: "id", options: "options", disabled: "disabled", selection: "selection", type: "type", size: "size" }, outputs: { isSelected: "isSelected" }, host: { listeners: { "document:click": "onClick($event)", "document:keydown.arrowdown": "onArrowDown($event)", "document:keydown.arrowup": "onArrowUp($event)", "document:keydown.enter": "onEnter($event)", "mouseenter": "onHover()" } }, viewQueries: [{ propertyName: "optionContainers", predicate: ["option"], descendants: true }], ngImport: i0, template: "<div\n  *ngIf=\"\n    config.type !== 'autocomplete' || config.options.length < 50;\n    else auto_flyout\n  \"\n>\n  <div\n    class=\"{{ config?.size }} flyout-container\"\n    #container\n  >\n    <div\n      #option\n      *ngFor=\"let option of config?.options; let index = index\"\n      [ngClass]=\"{\n        'flyout-option-container': option.clickable !== false,\n        'disabled-option': option.disabled === true,\n        selected: option.active\n      }\"\n    >\n      <ircc-cl-lib-flyout-option\n        [config]=\"option\"\n        [value]=\"option.value | autocomplete : config.selected\"\n        [size]=\"option.size\"\n        (click)=\"optionSelected(index)\"\n        [id]=\"option.id + '_option_' + (index + 1)\"\n      ></ircc-cl-lib-flyout-option>\n    </div>\n  </div>\n</div>\n\n<ng-template #auto_flyout>\n  <div class=\"{{ config?.size }} flyout-container\">\n    <cdk-virtual-scroll-viewport\n      autosize\n      style=\"height: 100%\"\n      minBufferPx=\"5\"\n      maxBufferPx=\"56\"\n      class=\"example-viewport\"\n      #container\n      [style.height]=\"calculateContainerHeight()\"\n    >\n      <div\n        *cdkVirtualFor=\"\n          let option of config?.options;\n          let index = index;\n          templateCacheSize: 0\n        \"\n        class=\"example-item\"\n        [ngClass]=\"{\n          'flyout-option-container': option.clickable !== false,\n          'disabled-option': option.disabled === true,\n          selected: option.active\n        }\"\n      >\n        <ircc-cl-lib-flyout-option\n          [config]=\"option\"\n          [value]=\"option.value | autocomplete : config.selected\"\n          [size]=\"option.size\"\n          (click)=\"optionSelected(index)\"\n          [id]=\"option.id + '_option_' + (index + 1)\"\n        ></ircc-cl-lib-flyout-option>\n      </div>\n    </cdk-virtual-scroll-viewport>\n  </div>\n</ng-template>\n\n<ng-template\n  #options\n  let-config=\"config\"\n  let-index=\"index\"\n>\n  <ircc-cl-lib-flyout-option\n    [config]=\"config\"\n    [value]=\"config.value | autocomplete : this.config.selected\"\n    [size]=\"config.size\"\n    (click)=\"optionSelected(index)\"\n    [id]=\"config.id + '_option_' + (index + 1)\"\n  ></ircc-cl-lib-flyout-option>\n</ng-template>\n<span\n  id=\"sr\"\n  class=\"sr-only\"\n  aria-live=\"polite\"\n  >{{ a11yText }}{{ currentSelected }}</span\n>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.CdkVirtualForOf, selector: "[cdkVirtualFor][cdkVirtualForOf]", inputs: ["cdkVirtualForOf", "cdkVirtualForTrackBy", "cdkVirtualForTemplate", "cdkVirtualForTemplateCacheSize"] }, { kind: "component", type: i3$1.CdkVirtualScrollViewport, selector: "cdk-virtual-scroll-viewport", inputs: ["orientation", "appendOnly"], outputs: ["scrolledIndexChange"] }, { kind: "directive", type: i4.CdkAutoSizeVirtualScroll, selector: "cdk-virtual-scroll-viewport[autosize]", inputs: ["minBufferPx", "maxBufferPx"] }, { kind: "component", type: FlyoutOptionComponent, selector: "ircc-cl-lib-flyout-option", inputs: ["config", "id", "size", "value", "selected", "active", "disabled", "type", "clickable"] }, { kind: "pipe", type: autocompletePipe, name: "autocomplete" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: FlyoutComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-flyout', template: "<div\n  *ngIf=\"\n    config.type !== 'autocomplete' || config.options.length < 50;\n    else auto_flyout\n  \"\n>\n  <div\n    class=\"{{ config?.size }} flyout-container\"\n    #container\n  >\n    <div\n      #option\n      *ngFor=\"let option of config?.options; let index = index\"\n      [ngClass]=\"{\n        'flyout-option-container': option.clickable !== false,\n        'disabled-option': option.disabled === true,\n        selected: option.active\n      }\"\n    >\n      <ircc-cl-lib-flyout-option\n        [config]=\"option\"\n        [value]=\"option.value | autocomplete : config.selected\"\n        [size]=\"option.size\"\n        (click)=\"optionSelected(index)\"\n        [id]=\"option.id + '_option_' + (index + 1)\"\n      ></ircc-cl-lib-flyout-option>\n    </div>\n  </div>\n</div>\n\n<ng-template #auto_flyout>\n  <div class=\"{{ config?.size }} flyout-container\">\n    <cdk-virtual-scroll-viewport\n      autosize\n      style=\"height: 100%\"\n      minBufferPx=\"5\"\n      maxBufferPx=\"56\"\n      class=\"example-viewport\"\n      #container\n      [style.height]=\"calculateContainerHeight()\"\n    >\n      <div\n        *cdkVirtualFor=\"\n          let option of config?.options;\n          let index = index;\n          templateCacheSize: 0\n        \"\n        class=\"example-item\"\n        [ngClass]=\"{\n          'flyout-option-container': option.clickable !== false,\n          'disabled-option': option.disabled === true,\n          selected: option.active\n        }\"\n      >\n        <ircc-cl-lib-flyout-option\n          [config]=\"option\"\n          [value]=\"option.value | autocomplete : config.selected\"\n          [size]=\"option.size\"\n          (click)=\"optionSelected(index)\"\n          [id]=\"option.id + '_option_' + (index + 1)\"\n        ></ircc-cl-lib-flyout-option>\n      </div>\n    </cdk-virtual-scroll-viewport>\n  </div>\n</ng-template>\n\n<ng-template\n  #options\n  let-config=\"config\"\n  let-index=\"index\"\n>\n  <ircc-cl-lib-flyout-option\n    [config]=\"config\"\n    [value]=\"config.value | autocomplete : this.config.selected\"\n    [size]=\"config.size\"\n    (click)=\"optionSelected(index)\"\n    [id]=\"config.id + '_option_' + (index + 1)\"\n  ></ircc-cl-lib-flyout-option>\n</ng-template>\n<span\n  id=\"sr\"\n  class=\"sr-only\"\n  aria-live=\"polite\"\n  >{{ a11yText }}{{ currentSelected }}</span\n>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; }, propDecorators: { optionContainers: [{
                type: ViewChildren,
                args: ['option']
            }], config: [{
                type: Input
            }], id: [{
                type: Input
            }], options: [{
                type: Input
            }], disabled: [{
                type: Input
            }], selection: [{
                type: Input
            }], type: [{
                type: Input
            }], size: [{
                type: Input
            }], isSelected: [{
                type: Output
            }], onClick: [{
                type: HostListener,
                args: ['document:click', ['$event']]
            }], onArrowDown: [{
                type: HostListener,
                args: ['document:keydown.arrowdown', ['$event']]
            }], onArrowUp: [{
                type: HostListener,
                args: ['document:keydown.arrowup', ['$event']]
            }], onEnter: [{
                type: HostListener,
                args: ['document:keydown.enter', ['$event']]
            }], onHover: [{
                type: HostListener,
                args: ['mouseenter']
            }] } });

const DROPDOWN_ARIA = {
    en: 'Dropdown',
    fr: 'Menu Deroulant'
};
class DropdownComponent {
    constructor(translate) {
        this.translate = translate;
        this.config = {
            id: ''
        };
        this.id = '';
        this.label = '';
        this.placeholderText = '';
        this.btnAriaLabel = '';
        this.showPlaceholder = false;
        this.selected = false;
        this.flyoutConfig = {
            id: this.config.id + '_flyout',
            options: [
                {
                    value: 'Options empty'
                }
            ]
        };
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.id !== '')
            this.config.id = this.id;
        if (this.size)
            this.config.size = this.size;
        if (this.icon)
            this.config.icon = this.icon;
        if (this.flyout)
            this.config.flyout = this.flyout;
        if (this.label !== '')
            this.config.label = this.label;
        if (this.placeholderText !== '')
            this.config.placeholderText = this.placeholderText;
        if (this.disabled !== undefined)
            this.config.disabled = this.disabled;
        this.category === undefined
            ? undefined
            : (this.config.category = this.category);
        if (!this.config.category)
            this.config.category = ButtonCategories.primary;
        if (!this.config.label || this.config.label.trim().length == 0) {
            if (!this.config.placeholderText) {
                this.config.placeholderText = 'Default';
            }
            this.showPlaceholder = true;
        }
        if (this.config.flyout)
            this.flyoutConfig = this.config.flyout;
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
    }
    /**
     * setLang(lang: string) if a function which accepts a string value.
     * This value currently needs to be 'en' or 'en-US' to trigger English translations otherwise
     * french translations will be triggered.
     */
    setLang(lang) {
        if (lang === 'en' || lang === 'en-US') {
            this.btnAriaLabel = DROPDOWN_ARIA.en;
        }
        else {
            this.btnAriaLabel = DROPDOWN_ARIA.fr;
        }
    }
    selectedOption(e) {
        //if it receives it's event info it selects the index - if not closes flyout
        if (e) {
            this.showPlaceholder = false;
            this.config.label = e.toString();
            this.selected = !this.selected;
            this.clearFlyoutFocus(); //clear the flyout focus if the flyout is closed.
        }
        else {
            this.toggleFlyout(false);
        }
    }
    /**
     * function receives a truthy value which determines wether it closes or opens,
     * but also looks for FocusEvent to check if flyout is being interacted with
     * @param status
     * @param e
     */
    toggleFlyout(status, e) {
        let target = e === null || e === void 0 ? void 0 : e.relatedTarget;
        if (!(target === null || target === void 0 ? void 0 : target.id.includes(this.config.id)) || !e) {
            this.selected = status;
            !status && this.clearFlyoutFocus(); //clear the flyout focus if the flyout is closed.
        }
    }
    /**
     * Clear the flyout active state
     */
    clearFlyoutFocus() {
        var _a, _b;
        if ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.flyout) === null || _b === void 0 ? void 0 : _b.options) {
            this.config.flyout.options.forEach((i) => {
                i.active = false;
            });
        }
    }
}
DropdownComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DropdownComponent, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
DropdownComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: DropdownComponent, selector: "ircc-cl-lib-dropdown", inputs: { config: "config", id: "id", size: "size", label: "label", placeholderText: "placeholderText", disabled: "disabled", category: "category", icon: "icon", flyout: "flyout" }, ngImport: i0, template: "<div\n  class=\"content-container\"\n  [ngClass]=\"config.size\"\n>\n  <button\n    aria-live=\"polite\"\n    attr.aria-label=\"{{ btnAriaLabel }}\"\n    [id]=\"config.id\"\n    (click)=\"toggleFlyout(!selected)\"\n    class=\"dropdown selected-{{ selected }} {{ config.category }}\"\n    attr.category=\"{{ config.category }}\"\n  >\n    <div class=\"icon-text-container\">\n      <ircc-cl-lib-icon\n        *ngIf=\"config.icon\"\n        class=\"custom-icon\"\n        [style.color]=\"config.icon?.color\"\n        [config]=\"{ FA_keywords: config.icon?.class }\"\n      ></ircc-cl-lib-icon>\n      <p\n        *ngIf=\"showPlaceholder\"\n        class=\"placholder-text\"\n      >\n        {{ config.placeholderText || '' | translate }}\n      </p>\n      <p class=\"label-text\">{{ config.label || '' | translate }}</p>\n    </div>\n    <div\n      *ngIf=\"!selected\"\n      role=\"img\"\n    >\n      <i class=\"fa-light fa-chevron-down custom-chevron\"></i>\n    </div>\n    <div\n      *ngIf=\"selected\"\n      role=\"img\"\n    >\n      <i class=\"fa-light fa-chevron-up custom-chevron\"></i>\n    </div>\n  </button>\n</div>\n<ircc-cl-lib-flyout\n  [id]=\"config.id + '_flyout'\"\n  [size]=\"config.size\"\n  *ngIf=\"selected\"\n  [config]=\"flyoutConfig\"\n  (isSelected)=\"selectedOption($event)\"\n></ircc-cl-lib-flyout>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "component", type: FlyoutComponent, selector: "ircc-cl-lib-flyout", inputs: ["config", "id", "options", "disabled", "selection", "type", "size"], outputs: ["isSelected"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DropdownComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-dropdown', template: "<div\n  class=\"content-container\"\n  [ngClass]=\"config.size\"\n>\n  <button\n    aria-live=\"polite\"\n    attr.aria-label=\"{{ btnAriaLabel }}\"\n    [id]=\"config.id\"\n    (click)=\"toggleFlyout(!selected)\"\n    class=\"dropdown selected-{{ selected }} {{ config.category }}\"\n    attr.category=\"{{ config.category }}\"\n  >\n    <div class=\"icon-text-container\">\n      <ircc-cl-lib-icon\n        *ngIf=\"config.icon\"\n        class=\"custom-icon\"\n        [style.color]=\"config.icon?.color\"\n        [config]=\"{ FA_keywords: config.icon?.class }\"\n      ></ircc-cl-lib-icon>\n      <p\n        *ngIf=\"showPlaceholder\"\n        class=\"placholder-text\"\n      >\n        {{ config.placeholderText || '' | translate }}\n      </p>\n      <p class=\"label-text\">{{ config.label || '' | translate }}</p>\n    </div>\n    <div\n      *ngIf=\"!selected\"\n      role=\"img\"\n    >\n      <i class=\"fa-light fa-chevron-down custom-chevron\"></i>\n    </div>\n    <div\n      *ngIf=\"selected\"\n      role=\"img\"\n    >\n      <i class=\"fa-light fa-chevron-up custom-chevron\"></i>\n    </div>\n  </button>\n</div>\n<ircc-cl-lib-flyout\n  [id]=\"config.id + '_flyout'\"\n  [size]=\"config.size\"\n  *ngIf=\"selected\"\n  [config]=\"flyoutConfig\"\n  (isSelected)=\"selectedOption($event)\"\n></ircc-cl-lib-flyout>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], label: [{
                type: Input
            }], placeholderText: [{
                type: Input
            }], disabled: [{
                type: Input
            }], category: [{
                type: Input
            }], icon: [{
                type: Input
            }], flyout: [{
                type: Input
            }] } });

class LabelButtonService {
    constructor() {
        this.labelButtonClickSubj = new BehaviorSubject('');
        this.labelButtonClickObs$ = this.labelButtonClickSubj.asObservable();
    }
    buttonPress(id) {
        this.labelButtonClickSubj.next(id);
    }
}
LabelButtonService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LabelButtonService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LabelButtonService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LabelButtonService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LabelButtonService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

const ERROR_TEXT_STUB = {
    en: 'Error',
    fr: 'Erreur'
};
const HELP_ICON_ALT = {
    en: ', more information',
    fr: ", plus d'information"
};
class LabelComponent {
    constructor(translate, standAloneFunctions, labelButton) {
        this.translate = translate;
        this.standAloneFunctions = standAloneFunctions;
        this.labelButton = labelButton;
        this.config = {
            formGroup: new FormGroup({}),
            parentID: '',
            legend: false
        };
        this.labelIconText = '';
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.formGroup)
            this.config.formGroup = this.formGroup;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
        if (this.parentID)
            this.config.parentID = this.parentID;
        if (this.label)
            this.config.label = this.label;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.required)
            this.config.required = this.required;
        if (this.iconButton)
            this.config.iconButton = this.iconButton;
        if (this.topLabel)
            this.config.topLabel = this.topLabel;
        if (this.touched)
            this.config.touched = this.touched;
        if (this.legend)
            this.config.legend = this.legend;
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
    }
    setLang(lang) {
        if (lang === 'en' || lang === 'en-US') {
            // this.errorStubText = ERROR_TEXT_STUB_EN;
            this.labelIconText = HELP_ICON_ALT.en;
        }
        else {
            // this.errorStubText = ERROR_TEXT_STUB_FR;
            this.labelIconText = HELP_ICON_ALT.fr;
        }
    }
    /**
     * Output the button press
     * @param id of the button being pressed (same as component ID)
     */
    iconButtonClick() {
        this.labelButton.buttonPress(this.config.parentID);
    }
    returnLabel() {
        return !this.config.topLabel ? this.config.label : this.config.topLabel;
    }
}
LabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LabelComponent, deps: [{ token: i1.TranslateService }, { token: StandAloneFunctions }, { token: LabelButtonService }], target: i0.ɵɵFactoryTarget.Component });
LabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: { config: "config", formGroup: "formGroup", errorMessages: "errorMessages", parentID: "parentID", label: "label", desc: "desc", hint: "hint", required: "required", iconButton: "iconButton", topLabel: "topLabel", touched: "touched", legend: "legend" }, ngImport: i0, template: "<div\n  id=\"{{ config.parentID + '_label' }}\"\n  class=\"label_container\"\n  [ngClass]=\"{ extra_padding: config.label && !config.desc && !config.hint }\"\n>\n  <ng-container *ngIf=\"config.legend === true; else noLegend\">\n    <ng-container *ngIf=\"config.label\">\n      <div\n        *ngIf=\"config.label\"\n        class=\"label\"\n        [attr.for]=\"config.parentID\"\n      >\n        <div class=\"label_field_container\">\n          <div\n            class=\"required-field-container\"\n            *ngIf=\"config.required\"\n          >\n            <i class=\"fa-regular fa-asterisk required-star\"></i>\n            {{ config.label || '' | translate }}\n          </div>\n          <div *ngIf=\"!config.required\">\n            {{ config.label || '' | translate }}\n          </div>\n          <div\n            *ngIf=\"config.iconButton\"\n            class=\"icon_container\"\n          >\n            <button\n              class=\"touch_button\"\n              category=\"plain\"\n              (click)=\"iconButtonClick()\"\n              role=\"button\"\n              [attr.aria-label]=\"\n                (config.label | translate) +\n                ' ' +\n                (config.iconButton.ariaText | translate)\n              \"\n            ></button>\n            <i [class]=\"config.iconButton.iconClass\"></i>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n  </ng-container>\n  <p\n    *ngIf=\"config.desc\"\n    class=\"input-desc\"\n  >\n    {{ config.desc || '' | translate }}\n  </p>\n  <p\n    *ngIf=\"config.hint\"\n    class=\"input-hint\"\n  >\n    {{ config.hint | translate }}\n  </p>\n</div>\n\n<ng-template #noLegend>\n  <label\n    *ngIf=\"config.label\"\n    class=\"label\"\n    [attr.for]=\"config.parentID\"\n  >\n    <span class=\"label_field_container\">\n      <div\n        class=\"required-field-container\"\n        *ngIf=\"config.required\"\n      >\n        <i class=\"fa-regular fa-asterisk required-star\"></i\n        >{{ config.label || '' | translate }}\n      </div>\n      <div *ngIf=\"!config.required\">\n        {{ config.label || '' | translate }}\n      </div>\n      <div\n        *ngIf=\"config.iconButton\"\n        class=\"icon_container\"\n      >\n        <button\n          class=\"touch_button\"\n          category=\"plain\"\n          (click)=\"iconButtonClick()\"\n          role=\"button\"\n          [attr.aria-label]=\"\n            (config.label | translate) +\n            ' ' +\n            (config.iconButton.ariaText | translate)\n          \"\n        ></button>\n        <i [class]=\"config.iconButton.iconClass\"></i>\n      </div>\n    </span>\n  </label>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LabelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-label', template: "<div\n  id=\"{{ config.parentID + '_label' }}\"\n  class=\"label_container\"\n  [ngClass]=\"{ extra_padding: config.label && !config.desc && !config.hint }\"\n>\n  <ng-container *ngIf=\"config.legend === true; else noLegend\">\n    <ng-container *ngIf=\"config.label\">\n      <div\n        *ngIf=\"config.label\"\n        class=\"label\"\n        [attr.for]=\"config.parentID\"\n      >\n        <div class=\"label_field_container\">\n          <div\n            class=\"required-field-container\"\n            *ngIf=\"config.required\"\n          >\n            <i class=\"fa-regular fa-asterisk required-star\"></i>\n            {{ config.label || '' | translate }}\n          </div>\n          <div *ngIf=\"!config.required\">\n            {{ config.label || '' | translate }}\n          </div>\n          <div\n            *ngIf=\"config.iconButton\"\n            class=\"icon_container\"\n          >\n            <button\n              class=\"touch_button\"\n              category=\"plain\"\n              (click)=\"iconButtonClick()\"\n              role=\"button\"\n              [attr.aria-label]=\"\n                (config.label | translate) +\n                ' ' +\n                (config.iconButton.ariaText | translate)\n              \"\n            ></button>\n            <i [class]=\"config.iconButton.iconClass\"></i>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n  </ng-container>\n  <p\n    *ngIf=\"config.desc\"\n    class=\"input-desc\"\n  >\n    {{ config.desc || '' | translate }}\n  </p>\n  <p\n    *ngIf=\"config.hint\"\n    class=\"input-hint\"\n  >\n    {{ config.hint | translate }}\n  </p>\n</div>\n\n<ng-template #noLegend>\n  <label\n    *ngIf=\"config.label\"\n    class=\"label\"\n    [attr.for]=\"config.parentID\"\n  >\n    <span class=\"label_field_container\">\n      <div\n        class=\"required-field-container\"\n        *ngIf=\"config.required\"\n      >\n        <i class=\"fa-regular fa-asterisk required-star\"></i\n        >{{ config.label || '' | translate }}\n      </div>\n      <div *ngIf=\"!config.required\">\n        {{ config.label || '' | translate }}\n      </div>\n      <div\n        *ngIf=\"config.iconButton\"\n        class=\"icon_container\"\n      >\n        <button\n          class=\"touch_button\"\n          category=\"plain\"\n          (click)=\"iconButtonClick()\"\n          role=\"button\"\n          [attr.aria-label]=\"\n            (config.label | translate) +\n            ' ' +\n            (config.iconButton.ariaText | translate)\n          \"\n        ></button>\n        <i [class]=\"config.iconButton.iconClass\"></i>\n      </div>\n    </span>\n  </label>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: StandAloneFunctions }, { type: LabelButtonService }]; }, propDecorators: { config: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }], parentID: [{
                type: Input
            }], label: [{
                type: Input
            }], desc: [{
                type: Input
            }], hint: [{
                type: Input
            }], required: [{
                type: Input
            }], iconButton: [{
                type: Input
            }], topLabel: [{
                type: Input
            }], touched: [{
                type: Input
            }], legend: [{
                type: Input
            }] } });

const PROGRESS_INDICATOR_STEP_EN = 'Step';
const PROGRESS_INDICATOR_STEP_FR = 'Étap';
var Orientations;
(function (Orientations) {
    Orientations["horizontal"] = "horizontal";
    Orientations["vertical"] = "vertical";
})(Orientations || (Orientations = {}));
class ProgressIndicatorComponent {
    constructor(translate) {
        this.translate = translate;
        this.config = {
            id: '',
            steps: [{ tagConfig: { id: '' } }],
            orientation: 'horizontal'
        };
        this.tabClick = new EventEmitter();
        this.tabConfig = {
            id: '',
            title: ''
        };
        this.tabNavConfig = {
            id: '',
            tab: [{ id: '', title: '' }]
        };
        this.stepText = '';
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.id)
            this.config.id = this.id;
        if (this.size)
            this.config.size = this.size;
        if (this.orientation)
            this.config.orientation = this.orientation;
        if (this.steps)
            this.config.steps = this.steps;
        if (this.selected)
            this.config.selected = this.selected;
        if (!this.config.orientation)
            this.config.orientation = 'horizontal';
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
        if (this.config.selected === undefined) {
            this.config.selected = 0;
        }
    }
    tabClickFn(selected) {
        this.tabClick.emit(selected);
    }
    setLang(lang) {
        if (lang === 'en' || lang === 'en-US') {
            this.stepText = PROGRESS_INDICATOR_STEP_EN;
        }
        else {
            this.stepText = PROGRESS_INDICATOR_STEP_FR;
        }
    }
}
ProgressIndicatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ProgressIndicatorComponent, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
ProgressIndicatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ProgressIndicatorComponent, selector: "ircc-cl-lib-progress-indicator", inputs: { config: "config", id: "id", size: "size", orientation: "orientation", steps: "steps", selected: "selected" }, outputs: { tabClick: "tabClick" }, ngImport: i0, template: "<div\n  [class]=\"config.orientation\"\n  class=\"{{ config?.size }} {{ config?.orientation }} main-container\"\n>\n  <div\n    class=\"container-plus-line\"\n    *ngFor=\"let step of config.steps; let i = index\"\n  >\n    <nav\n      class=\"progress-nav\"\n      role=\"navigation\"\n    >\n      <button\n        role=\"tab\"\n        class=\"container\"\n        [ngClass]=\"config.size\"\n        category=\"plain\"\n        [attr.disabled]=\"step.tagConfig.type === 'locked' ? 'disabled' : null\"\n        (click)=\"tabClickFn(i)\"\n      >\n        <div class=\"except-line\">\n          <button\n            tabindex=\"-1\"\n            *ngIf=\"i === config.selected\"\n            selected\n            class=\"tags-btn\"\n            [id]=\"config.id + '_step_' + i\"\n            [attr.aria-label]=\"stepText + ' ' + (i + 1) + ' selected'\"\n          >\n            {{ stepText + ' ' + (i + 1) }}\n          </button>\n          <button\n            tabindex=\"-1\"\n            *ngIf=\"i !== config.selected\"\n            class=\"tags-btn-plus\"\n            [id]=\"config.id + '_step_' + i\"\n            [attr.aria-label]=\"stepText + ' ' + (i + 1)\"\n          >\n            {{ stepText + ' ' + (i + 1) }}\n          </button>\n          <span\n            class=\"stepTitle\"\n            [innerHTML]=\"step.title || '' | translate\"\n          ></span>\n          <div [ngClass]=\"{ small: config.size === 'small' }\">\n            <ircc-cl-lib-progress-tags\n              [config]=\"step.tagConfig\"\n            ></ircc-cl-lib-progress-tags>\n          </div>\n        </div>\n      </button>\n    </nav>\n    <div\n      [ngClass]=\"{ 'green-line': step.tagConfig.type === 'success' }\"\n      class=\"line\"\n    ></div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ProgressTagsComponent, selector: "ircc-cl-lib-progress-tags", inputs: ["config", "id", "type", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ProgressIndicatorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-progress-indicator', template: "<div\n  [class]=\"config.orientation\"\n  class=\"{{ config?.size }} {{ config?.orientation }} main-container\"\n>\n  <div\n    class=\"container-plus-line\"\n    *ngFor=\"let step of config.steps; let i = index\"\n  >\n    <nav\n      class=\"progress-nav\"\n      role=\"navigation\"\n    >\n      <button\n        role=\"tab\"\n        class=\"container\"\n        [ngClass]=\"config.size\"\n        category=\"plain\"\n        [attr.disabled]=\"step.tagConfig.type === 'locked' ? 'disabled' : null\"\n        (click)=\"tabClickFn(i)\"\n      >\n        <div class=\"except-line\">\n          <button\n            tabindex=\"-1\"\n            *ngIf=\"i === config.selected\"\n            selected\n            class=\"tags-btn\"\n            [id]=\"config.id + '_step_' + i\"\n            [attr.aria-label]=\"stepText + ' ' + (i + 1) + ' selected'\"\n          >\n            {{ stepText + ' ' + (i + 1) }}\n          </button>\n          <button\n            tabindex=\"-1\"\n            *ngIf=\"i !== config.selected\"\n            class=\"tags-btn-plus\"\n            [id]=\"config.id + '_step_' + i\"\n            [attr.aria-label]=\"stepText + ' ' + (i + 1)\"\n          >\n            {{ stepText + ' ' + (i + 1) }}\n          </button>\n          <span\n            class=\"stepTitle\"\n            [innerHTML]=\"step.title || '' | translate\"\n          ></span>\n          <div [ngClass]=\"{ small: config.size === 'small' }\">\n            <ircc-cl-lib-progress-tags\n              [config]=\"step.tagConfig\"\n            ></ircc-cl-lib-progress-tags>\n          </div>\n        </div>\n      </button>\n    </nav>\n    <div\n      [ngClass]=\"{ 'green-line': step.tagConfig.type === 'success' }\"\n      class=\"line\"\n    ></div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], orientation: [{
                type: Input
            }], steps: [{
                type: Input
            }], selected: [{
                type: Input
            }], tabClick: [{
                type: Output
            }] } });

class BreadcrumbLinkComponent {
    constructor() {
        this.config = {
            text: '',
            overflow: false
        };
    }
}
BreadcrumbLinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BreadcrumbLinkComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
BreadcrumbLinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: BreadcrumbLinkComponent, selector: "ircc-cl-lib-breadcrumb-link", inputs: { config: "config" }, ngImport: i0, template: "<ng-container *ngIf=\"config.href\">\n  <a\n    class=\"breadcrumb-anchor\"\n    [href]=\"config.href\"\n    tabindex=\"-1\"\n    >{{ config.text | translate }}\n  </a>\n</ng-container>\n<ng-container *ngIf=\"config.routerLink\">\n  <a\n    class=\"breadcrumb-anchor\"\n    type=\"button\"\n    tabindex=\"-1\"\n    [routerLink]=\"config.routerLink\"\n    >{{ config.text | translate }}\n  </a>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BreadcrumbLinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-breadcrumb-link', template: "<ng-container *ngIf=\"config.href\">\n  <a\n    class=\"breadcrumb-anchor\"\n    [href]=\"config.href\"\n    tabindex=\"-1\"\n    >{{ config.text | translate }}\n  </a>\n</ng-container>\n<ng-container *ngIf=\"config.routerLink\">\n  <a\n    class=\"breadcrumb-anchor\"\n    type=\"button\"\n    tabindex=\"-1\"\n    [routerLink]=\"config.routerLink\"\n    >{{ config.text | translate }}\n  </a>\n</ng-container>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { config: [{
                type: Input
            }] } });

/**
 * @see https://stackblitz.com/edit/angular-mutationobserver-example?file=app%2Fapp.module.ts,app%2Fdom-change.directive.ts,app%2Fapp.component.ts
 */
class DomChangeDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.domChange = new EventEmitter();
        const element = this.elementRef.nativeElement;
        this.changes = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => this.domChange.emit(mutation));
        });
        this.changes.observe(element, {
            attributes: true,
            childList: true,
            characterData: true
        });
    }
    ngOnDestroy() {
        this.changes.disconnect();
    }
}
DomChangeDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DomChangeDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
DomChangeDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.12", type: DomChangeDirective, selector: "[domChange]", outputs: { domChange: "domChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DomChangeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[domChange]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { domChange: [{
                type: Output
            }] } });

var LinkType;
(function (LinkType) {
    LinkType["href"] = "href";
    LinkType["routerLink"] = "routerLink";
})(LinkType || (LinkType = {}));
class BreadcrumbComponent {
    constructor(translate, standalone, renderer, changeRef) {
        var _a;
        this.translate = translate;
        this.standalone = standalone;
        this.renderer = renderer;
        this.changeRef = changeRef;
        this.config = {
            id: '',
            baseUrlKey: '',
            type: 'href'
        };
        this.id = '';
        this.baseUrl = '';
        this.separatorIcon = {
            id: 'breadcrumb_separator',
            category: 'custom',
            size: (_a = this.config) === null || _a === void 0 ? void 0 : _a.size,
            icon: {
                class: 'fa-light fa-ellipsis',
                color: 'var(--text-primary)'
            },
            ariaLabel: ''
        };
        this.displayOverflow = false;
        this.maxHeight = 0; // Max height of element in px
        this.isChildOverflow = false;
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.id && this.id !== '')
            this.config.id = this.id;
        if (this.size)
            this.config.size = this.size;
        if (this.type)
            this.config.type = this.type;
        if (this.baseUrlKey)
            this.config.baseUrlKey = this.baseUrlKey;
        this.createLinks();
        this.separatorIcon.size = this.config.size;
        this.maxHeight = this.getMaxHeight();
        this.separatorIcon.ariaLabel = this.translate.instant('ACC_DEMO.BREADCRUMB_COMPONENT.ADDITIONAL_LINKS');
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.createOverflows();
            this.isChildOverflow = this.getChildOverflow();
            this.changeRef.detectChanges();
        }, 500);
    }
    ngOnChanges(changes) {
        var _a, _b, _c, _d;
        // If changing size, update max height
        if (!changes['config'].firstChange &&
            changes['config'].currentValue.size !==
                changes['config'].previousValue.size) {
            this.maxHeight = this.getMaxHeight();
        }
        // If changing link type, recreate all links
        if (!changes['config'].firstChange &&
            changes['config'].currentValue.type !==
                changes['config'].previousValue.type) {
            this.createLinks();
        }
        if (((_a = this.config) === null || _a === void 0 ? void 0 : _a.links) && ((_b = this.config) === null || _b === void 0 ? void 0 : _b.links.length) > 0) {
            if (this.config.type == 'routerLink') {
                (_c = this.config) === null || _c === void 0 ? void 0 : _c.links.forEach((link) => {
                    delete link.href;
                });
            }
            else {
                (_d = this.config) === null || _d === void 0 ? void 0 : _d.links.forEach((link) => {
                    delete link.routerLink;
                });
            }
        }
        this.separatorIcon.size = this.config.size;
    }
    /**
     * Create href or routerLinks
     */
    createLinks() {
        var _a, _b, _c;
        this.baseUrl = this.standalone.getBaseUrl('', this.config.baseUrlKey);
        if (this.config.links && this.config.links.length > 1) {
            let prev;
            (_a = this.config) === null || _a === void 0 ? void 0 : _a.links.forEach((link, i) => {
                if (i === 0) {
                    link[this.config.type] = this.baseUrl;
                    prev = link[this.config.type];
                }
                else if (link.linkKey) {
                    link[this.config.type] =
                        prev + this.translate.instant(link.linkKey) + '/';
                    prev = link[this.config.type];
                }
                link.overflow = false;
            });
            this.overflowLinks = (_b = this.config) === null || _b === void 0 ? void 0 : _b.links.filter((link) => link.overflow);
            this.normalLinks = (_c = this.config) === null || _c === void 0 ? void 0 : _c.links.filter((link) => !link.overflow);
        }
    }
    getMaxHeight() {
        const containerElement = this.divRef && this.divRef.nativeElement;
        if (containerElement == undefined)
            return 0;
        const tempElement = this.renderer.createElement('p');
        const text = this.renderer.createText('Test');
        this.renderer.appendChild(tempElement, text);
        this.renderer.addClass(tempElement, 'breadcrumb-child');
        this.renderer.appendChild(containerElement, tempElement);
        const maxHeight = tempElement.offsetHeight;
        this.renderer.removeChild(containerElement, tempElement);
        // Calculate based on elipsis icon size to p tag ratio
        return maxHeight * 1.375;
    }
    createOverflows() {
        var _a, _b, _c, _d;
        if (this.divRef &&
            ((_a = this.divRef) === null || _a === void 0 ? void 0 : _a.nativeElement.offsetHeight) <= this.maxHeight)
            return;
        if (this.config.links && this.config.links.length > 1) {
            const linksLength = this.config.links.length;
            const overflow = (_b = this.config) === null || _b === void 0 ? void 0 : _b.links.find((link, i) => i > 0 && i < linksLength - 1 && !link.overflow);
            if (overflow)
                overflow.overflow = true;
            this.overflowLinks = (_c = this.config) === null || _c === void 0 ? void 0 : _c.links.filter((link) => link.overflow);
            this.normalLinks = (_d = this.config) === null || _d === void 0 ? void 0 : _d.links.filter((link) => !link.overflow);
        }
    }
    onResize(event) {
        this.overflowLinks = [];
        this.normalLinks = [];
        this.createLinks();
        this.createOverflows();
        this.isChildOverflow = this.getChildOverflow();
    }
    flipOverflow(buttonId) {
        this.displayOverflow = !this.displayOverflow;
    }
    // Check if child page title overflows to 2nd line
    getChildOverflow() {
        if (this.childRef) {
            return (this.childRef.nativeElement.offsetWidth <
                this.childRef.nativeElement.scrollWidth);
        }
        else {
            return false;
        }
    }
}
BreadcrumbComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BreadcrumbComponent, deps: [{ token: i1.TranslateService }, { token: StandAloneFunctions }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
BreadcrumbComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: BreadcrumbComponent, selector: "ircc-cl-lib-breadcrumb", inputs: { config: "config", id: "id", size: "size", type: "type", baseUrlKey: "baseUrlKey" }, host: { listeners: { "window:resize": "onResize($event)" } }, viewQueries: [{ propertyName: "divRef", first: true, predicate: ["breadcrumb_div"], descendants: true }, { propertyName: "childRef", first: true, predicate: ["breadcrumb_child"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<nav\n  class=\"{{ config.size }}\"\n  (domChange)=\"createOverflows()\"\n  [attr.aria-label]=\"'Breadcrumb.Title' | translate\"\n  #breadcrumb_div\n>\n  <ng-container\n    *ngFor=\"let link of normalLinks; first as first; last as last; index as i\"\n  >\n    <ng-container *ngIf=\"first\">\n      <ircc-cl-lib-breadcrumb-link\n        tabindex=\"0\"\n        class=\"breadcrumb-root\"\n        [config]=\"link\"\n      ></ircc-cl-lib-breadcrumb-link>\n      <div\n        *ngIf=\"overflowLinks && overflowLinks.length > 0\"\n        class=\"overflow-container\"\n      >\n        <ircc-cl-lib-icon\n          [config]=\"{ FA_keywords: 'fa-light fa-chevron-right' }\"\n          id=\"overflow\"\n        ></ircc-cl-lib-icon>\n        <ircc-cl-lib-icon-button\n          (clickEvent)=\"flipOverflow($event)\"\n          class=\"elipsis-icon\"\n          [config]=\"separatorIcon\"\n        ></ircc-cl-lib-icon-button>\n        <div\n          class=\"overflow-menu\"\n          *ngIf=\"displayOverflow && overflowLinks && overflowLinks.length > 0\"\n        >\n          <ng-container *ngFor=\"let link of overflowLinks\">\n            <ircc-cl-lib-breadcrumb-link\n              tabindex=\"0\"\n              class=\"breadcrumb-overflow\"\n              [config]=\"link\"\n            ></ircc-cl-lib-breadcrumb-link>\n          </ng-container>\n        </div>\n      </div>\n    </ng-container>\n    <ng-container *ngIf=\"!first && !last\">\n      <ircc-cl-lib-icon\n        [config]=\"{ FA_keywords: 'fa-light fa-chevron-right' }\"\n      ></ircc-cl-lib-icon>\n      <ircc-cl-lib-breadcrumb-link\n        tabindex=\"0\"\n        class=\"breadcrumb-item\"\n        [config]=\"link\"\n      ></ircc-cl-lib-breadcrumb-link>\n    </ng-container>\n    <ng-container *ngIf=\"last\">\n      <ircc-cl-lib-icon\n        [config]=\"{ FA_keywords: 'fa-light fa-chevron-right' }\"\n        class=\"\"\n      ></ircc-cl-lib-icon>\n      <p\n        class=\"breadcrumb-child\"\n        #breadcrumb_child\n      >\n        <span *ngIf=\"!isChildOverflow\">{{ link.text }}</span>\n        <abbr\n          *ngIf=\"isChildOverflow\"\n          [title]=\"link.text\"\n          >{{ link.text }}</abbr\n        >\n      </p>\n    </ng-container>\n  </ng-container>\n</nav>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: BreadcrumbLinkComponent, selector: "ircc-cl-lib-breadcrumb-link", inputs: ["config"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "component", type: IconButtonComponent, selector: "ircc-cl-lib-icon-button", inputs: ["config", "id", "category", "size", "ariaLabel", "disabled", "icon"], outputs: ["clickEvent"] }, { kind: "directive", type: DomChangeDirective, selector: "[domChange]", outputs: ["domChange"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-breadcrumb', template: "<nav\n  class=\"{{ config.size }}\"\n  (domChange)=\"createOverflows()\"\n  [attr.aria-label]=\"'Breadcrumb.Title' | translate\"\n  #breadcrumb_div\n>\n  <ng-container\n    *ngFor=\"let link of normalLinks; first as first; last as last; index as i\"\n  >\n    <ng-container *ngIf=\"first\">\n      <ircc-cl-lib-breadcrumb-link\n        tabindex=\"0\"\n        class=\"breadcrumb-root\"\n        [config]=\"link\"\n      ></ircc-cl-lib-breadcrumb-link>\n      <div\n        *ngIf=\"overflowLinks && overflowLinks.length > 0\"\n        class=\"overflow-container\"\n      >\n        <ircc-cl-lib-icon\n          [config]=\"{ FA_keywords: 'fa-light fa-chevron-right' }\"\n          id=\"overflow\"\n        ></ircc-cl-lib-icon>\n        <ircc-cl-lib-icon-button\n          (clickEvent)=\"flipOverflow($event)\"\n          class=\"elipsis-icon\"\n          [config]=\"separatorIcon\"\n        ></ircc-cl-lib-icon-button>\n        <div\n          class=\"overflow-menu\"\n          *ngIf=\"displayOverflow && overflowLinks && overflowLinks.length > 0\"\n        >\n          <ng-container *ngFor=\"let link of overflowLinks\">\n            <ircc-cl-lib-breadcrumb-link\n              tabindex=\"0\"\n              class=\"breadcrumb-overflow\"\n              [config]=\"link\"\n            ></ircc-cl-lib-breadcrumb-link>\n          </ng-container>\n        </div>\n      </div>\n    </ng-container>\n    <ng-container *ngIf=\"!first && !last\">\n      <ircc-cl-lib-icon\n        [config]=\"{ FA_keywords: 'fa-light fa-chevron-right' }\"\n      ></ircc-cl-lib-icon>\n      <ircc-cl-lib-breadcrumb-link\n        tabindex=\"0\"\n        class=\"breadcrumb-item\"\n        [config]=\"link\"\n      ></ircc-cl-lib-breadcrumb-link>\n    </ng-container>\n    <ng-container *ngIf=\"last\">\n      <ircc-cl-lib-icon\n        [config]=\"{ FA_keywords: 'fa-light fa-chevron-right' }\"\n        class=\"\"\n      ></ircc-cl-lib-icon>\n      <p\n        class=\"breadcrumb-child\"\n        #breadcrumb_child\n      >\n        <span *ngIf=\"!isChildOverflow\">{{ link.text }}</span>\n        <abbr\n          *ngIf=\"isChildOverflow\"\n          [title]=\"link.text\"\n          >{{ link.text }}</abbr\n        >\n      </p>\n    </ng-container>\n  </ng-container>\n</nav>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: StandAloneFunctions }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], baseUrlKey: [{
                type: Input
            }], divRef: [{
                type: ViewChild,
                args: ['breadcrumb_div', { static: false }]
            }], childRef: [{
                type: ViewChild,
                args: ['breadcrumb_child', { static: false }]
            }], onResize: [{
                type: HostListener,
                args: ['window:resize', ['$event']]
            }] } });

var IndicatorType;
(function (IndicatorType) {
    IndicatorType[IndicatorType["dot"] = 0] = "dot";
    IndicatorType[IndicatorType["text"] = 1] = "text";
    IndicatorType[IndicatorType["number"] = 2] = "number";
})(IndicatorType || (IndicatorType = {}));
var IndicatorTreatment;
(function (IndicatorTreatment) {
    IndicatorTreatment["strong"] = "strong";
    IndicatorTreatment["weak"] = "weak";
})(IndicatorTreatment || (IndicatorTreatment = {}));
var IndicatorPurpose;
(function (IndicatorPurpose) {
    IndicatorPurpose["status"] = "status";
    IndicatorPurpose["palette"] = "palette";
})(IndicatorPurpose || (IndicatorPurpose = {}));
var IndicatorStatus;
(function (IndicatorStatus) {
    IndicatorStatus["information"] = "information";
    IndicatorStatus["warning"] = "warning";
    IndicatorStatus["critical"] = "critical";
    IndicatorStatus["neutral"] = "neutral";
    IndicatorStatus["primary"] = "primary";
    IndicatorStatus["success"] = "success";
})(IndicatorStatus || (IndicatorStatus = {}));
var IndicatorPalette;
(function (IndicatorPalette) {
    IndicatorPalette[IndicatorPalette["teal"] = 0] = "teal";
    IndicatorPalette[IndicatorPalette["orange"] = 1] = "orange";
    IndicatorPalette[IndicatorPalette["red"] = 2] = "red";
    IndicatorPalette[IndicatorPalette["grey"] = 3] = "grey";
    IndicatorPalette[IndicatorPalette["blue"] = 4] = "blue";
    IndicatorPalette[IndicatorPalette["green"] = 5] = "green";
    IndicatorPalette[IndicatorPalette["purple"] = 6] = "purple";
    IndicatorPalette[IndicatorPalette["navy"] = 7] = "navy";
})(IndicatorPalette || (IndicatorPalette = {}));
class IndicatorComponent {
    constructor() {
        this.config = {
            type: 'text',
            category: IndicatorTreatment.weak,
            purpose: IndicatorPurpose.status,
            tabIndex: -1
        };
        this.tabIndex = undefined;
        this.EIndicatorStatus = IndicatorStatus;
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.size)
            this.config.size = this.size;
        if (this.type)
            this.config.type = this.type;
        if (this.icon)
            this.config.icon = this.icon;
        if (this.category)
            this.config.category = this.category;
        if (this.purpose)
            this.config.purpose = this.purpose;
        if (this.status)
            this.config.status = this.status;
        if (this.palette)
            this.config.palette = this.palette;
        if (this.ariaLabel)
            this.config.ariaLabel = this.ariaLabel;
        if (!this.tabIndex)
            this.config.tabIndex = -1;
        this.checkLabelRounded();
        this.checkNumber();
        this.tabIndex !== undefined
            ? (this.config.tabIndex = this.tabIndex)
            : undefined;
    }
    ngAfterViewInit() {
        setTimeout(() => this.checkLabelLength());
    }
    ngOnChanges(changes) {
        this.checkNumber();
        this.checkLabelRounded();
        this.checkLabelLength();
        setTimeout(() => this.checkLabelLength());
    }
    // Check if number exceeds 99
    checkNumber() {
        var _a;
        if (this.config.type === 'number' &&
            ((_a = this.config) === null || _a === void 0 ? void 0 : _a.label) &&
            this.config.label > 99) {
            this.config.label = '99+';
        }
    }
    // If label only have 1 character, it should be rounded
    checkLabelRounded() {
        var _a;
        if (typeof ((_a = this.config) === null || _a === void 0 ? void 0 : _a.label) === 'string') {
            this.rounded = this.config.label.length == 1 && !this.config.icon;
        }
    }
    // Check if div exceeds 200px
    checkLabelLength() {
        var _a, _b, _c, _d;
        if (this.config.type !== 'text')
            return;
        // Max 200px - padding 8px x2
        this.abbr = ((((_b = (_a = this.label) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.offsetWidth) &&
            ((_d = (_c = this.label) === null || _c === void 0 ? void 0 : _c.nativeElement) === null || _d === void 0 ? void 0 : _d.offsetWidth) > 184));
    }
}
IndicatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IndicatorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IndicatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IndicatorComponent, selector: "ircc-cl-lib-indicator", inputs: { config: "config", size: "size", type: "type", icon: "icon", category: "category", purpose: "purpose", status: "status", palette: "palette", ariaLabel: "ariaLabel", tabIndex: "tabIndex" }, viewQueries: [{ propertyName: "label", first: true, predicate: ["label"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  [ngClass]=\"['indicator-container', config.size ?? '']\"\n    [attr.aria-label]=\"\n    (config.ariaLabel ?? 'Indicator.Heading' | translate) +\n    ' ' +\n    (config.label ?? '')\n  \"\n  [tabindex]=\"config.tabIndex\"\n  role=\"group\"\n>\n  <div\n    *ngIf=\"config.type === 'text' || config.type === 'number'\"\n    #label\n    [ngClass]=\"[\n      config.type,\n      config.category,\n      config.purpose === 'status'\n        ? EIndicatorStatus[config.status ?? 'information']\n        : '',\n      config.purpose === 'palette' ? config.palette : '',\n      rounded ? 'rounded' : '',\n      config.label === '99+' ? 'num-lg' : '',\n      abbr ? 'abbr' : ''\n    ]\"\n  >\n    <ircc-cl-lib-icon\n      *ngIf=\"config.type === 'text' && config?.icon\"\n      [config]=\"{ FA_keywords: config.icon }\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n    <ng-container *ngIf=\"abbr; else nonAbbr\">\n      <span class=\"abbr\"\n        ><abbr [title]=\"config.label\">{{ config.label }}</abbr></span\n      >\n    </ng-container>\n    <ng-template #nonAbbr>\n      <span>{{ config.label }}</span>\n    </ng-template>\n  </div>\n  <span\n    *ngIf=\"config.type === 'dot'\"\n    [ngClass]=\"[\n      config.icon ? 'dot-icon' : '',\n      config.type,\n      config.category,\n      config.purpose === 'status'\n        ? EIndicatorStatus[config.status ?? 'information']\n        : '',\n      config.purpose === 'palette' ? config.palette : ''\n    ]\"\n  >\n    <ircc-cl-lib-icon\n      *ngIf=\"config?.icon\"\n      [config]=\"{ FA_keywords: config.icon }\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n  </span>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IndicatorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-indicator', template: "<div\n  [ngClass]=\"['indicator-container', config.size ?? '']\"\n    [attr.aria-label]=\"\n    (config.ariaLabel ?? 'Indicator.Heading' | translate) +\n    ' ' +\n    (config.label ?? '')\n  \"\n  [tabindex]=\"config.tabIndex\"\n  role=\"group\"\n>\n  <div\n    *ngIf=\"config.type === 'text' || config.type === 'number'\"\n    #label\n    [ngClass]=\"[\n      config.type,\n      config.category,\n      config.purpose === 'status'\n        ? EIndicatorStatus[config.status ?? 'information']\n        : '',\n      config.purpose === 'palette' ? config.palette : '',\n      rounded ? 'rounded' : '',\n      config.label === '99+' ? 'num-lg' : '',\n      abbr ? 'abbr' : ''\n    ]\"\n  >\n    <ircc-cl-lib-icon\n      *ngIf=\"config.type === 'text' && config?.icon\"\n      [config]=\"{ FA_keywords: config.icon }\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n    <ng-container *ngIf=\"abbr; else nonAbbr\">\n      <span class=\"abbr\"\n        ><abbr [title]=\"config.label\">{{ config.label }}</abbr></span\n      >\n    </ng-container>\n    <ng-template #nonAbbr>\n      <span>{{ config.label }}</span>\n    </ng-template>\n  </div>\n  <span\n    *ngIf=\"config.type === 'dot'\"\n    [ngClass]=\"[\n      config.icon ? 'dot-icon' : '',\n      config.type,\n      config.category,\n      config.purpose === 'status'\n        ? EIndicatorStatus[config.status ?? 'information']\n        : '',\n      config.purpose === 'palette' ? config.palette : ''\n    ]\"\n  >\n    <ircc-cl-lib-icon\n      *ngIf=\"config?.icon\"\n      [config]=\"{ FA_keywords: config.icon }\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n  </span>\n</div>\n" }]
        }], propDecorators: { config: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], icon: [{
                type: Input
            }], category: [{
                type: Input
            }], purpose: [{
                type: Input
            }], status: [{
                type: Input
            }], palette: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], label: [{
                type: ViewChild,
                args: ['label', { static: false }]
            }] } });

const SPINNER_LABELS_EN = ['Loading', 'Success', 'Error'];
const SPINNER_LABELS_FR = ['Chargement', 'Succès', 'Erreur'];
var SpinnerType;
(function (SpinnerType) {
    SpinnerType["active"] = "active";
    SpinnerType["success"] = "success";
    SpinnerType["critical"] = "critical";
})(SpinnerType || (SpinnerType = {}));
class SpinnerComponent {
    constructor(translate) {
        this.translate = translate;
        this.text = [];
        this.config = {
            id: ''
        };
        this.id = '';
    }
    ngOnInit() {
        //set config from individual options, if present
        if (this.id !== '')
            this.config.id = this.id;
        if (this.type)
            this.config.type = this.type;
        if (this.size)
            this.config.size = this.size;
        if (this.orientation)
            this.config.orientation = this.orientation;
        if (this.label !== '')
            this.config.label = this.label;
        if (this.description !== '')
            this.config.description = this.description;
        if (!this.config.orientation)
            this.config.orientation = 'horizontal';
        if (!this.config.size)
            this.config.size = 'large';
        this.removeVertical();
        this.setTypeTitle();
        this.translate.onLangChange.subscribe(() => {
            this.setTypeTitle();
        });
    }
    ngOnChanges() {
        this.setTypeTitle();
    }
    setTypeTitle() {
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            this.text = SPINNER_LABELS_EN;
        }
        else {
            this.text = SPINNER_LABELS_FR;
        }
    }
    removeVertical() {
        if (this.config.size !== 'large' &&
            this.config.orientation === 'vertical') {
            this.config.orientation = 'horizontal';
        }
    }
    getSuccessTitle() {
        return (this.config.label || this.config.description) ? '' : this.text[1];
    }
    getErrorTitle() {
        return (this.config.label || this.config.description) ? '' : this.text[2];
    }
}
SpinnerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SpinnerComponent, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
SpinnerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: SpinnerComponent, selector: "ircc-cl-lib-spinner", inputs: { config: "config", id: "id", type: "type", size: "size", orientation: "orientation", label: "label", description: "description" }, usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"{{ config.size }} {{ config.orientation }}\"\n  id=\"{{ config.id }}\"\n  aria-live=\"polite\"\n>\n  <div\n    class=\"spinner-container\"\n    [ngClass]=\"{\n      active: config.type === 'active',\n      success: config.type === 'success',\n      critical: config.type === 'critical'\n    }\"\n  >\n    <ng-container [ngSwitch]=\"config.type\">\n      <div\n        *ngSwitchCase=\"'success'\"\n        class=\"container\"\n      >\n        <div class=\"icon-div\">\n          <ircc-cl-lib-icon\n            [config]=\"{\n              FA_keywords: 'fa-check fa-regular',\n              ariaLabel: getSuccessTitle()\n            }\"\n            class=\"spinner-icon\"\n          ></ircc-cl-lib-icon>\n        </div>\n        <div class=\"text\">\n          <div\n            class=\"label\"\n            [innerHTML]=\"config.label\"\n          ></div>\n          <div\n            *ngIf=\"config.size === 'large'\"\n            class=\"desc\"\n            [innerHTML]=\"config.description\"\n          ></div>\n        </div>\n      </div>\n      <div\n        *ngSwitchCase=\"'critical'\"\n        class=\"container\"\n      >\n        <div class=\"icon-div\">\n          <ircc-cl-lib-icon\n            [config]=\"{\n              FA_keywords: 'fa-exclamation fa-regular',\n              ariaLabel: getErrorTitle()\n            }\"\n            class=\"spinner-icon\"\n          ></ircc-cl-lib-icon>\n        </div>\n        <div class=\"text\">\n          <div\n            class=\"label\"\n            [innerHTML]=\"config.label\"\n          ></div>\n          <div\n            *ngIf=\"config.size === 'large'\"\n            class=\"desc\"\n            [innerHTML]=\"config.description\"\n          ></div>\n        </div>\n      </div>\n      <div\n        *ngSwitchDefault\n        class=\"container\"\n      >\n        <div class=\"icon-div\">\n          <img\n            src=\"./src/assets/icons/spinner-states.svg\"\n            [attr.alt]=\"config.label || config.description ? '' : text[0]\"\n            class=\"animated-icon loading-icon\"\n          />\n        </div>\n        <div class=\"text\">\n          <div\n            class=\"label\"\n            [innerHTML]=\"config.label\"\n          ></div>\n          <div\n            *ngIf=\"config.size === 'large'\"\n            class=\"desc\"\n            [innerHTML]=\"config.description\"\n          ></div>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i2.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-spinner', template: "<div\n  class=\"{{ config.size }} {{ config.orientation }}\"\n  id=\"{{ config.id }}\"\n  aria-live=\"polite\"\n>\n  <div\n    class=\"spinner-container\"\n    [ngClass]=\"{\n      active: config.type === 'active',\n      success: config.type === 'success',\n      critical: config.type === 'critical'\n    }\"\n  >\n    <ng-container [ngSwitch]=\"config.type\">\n      <div\n        *ngSwitchCase=\"'success'\"\n        class=\"container\"\n      >\n        <div class=\"icon-div\">\n          <ircc-cl-lib-icon\n            [config]=\"{\n              FA_keywords: 'fa-check fa-regular',\n              ariaLabel: getSuccessTitle()\n            }\"\n            class=\"spinner-icon\"\n          ></ircc-cl-lib-icon>\n        </div>\n        <div class=\"text\">\n          <div\n            class=\"label\"\n            [innerHTML]=\"config.label\"\n          ></div>\n          <div\n            *ngIf=\"config.size === 'large'\"\n            class=\"desc\"\n            [innerHTML]=\"config.description\"\n          ></div>\n        </div>\n      </div>\n      <div\n        *ngSwitchCase=\"'critical'\"\n        class=\"container\"\n      >\n        <div class=\"icon-div\">\n          <ircc-cl-lib-icon\n            [config]=\"{\n              FA_keywords: 'fa-exclamation fa-regular',\n              ariaLabel: getErrorTitle()\n            }\"\n            class=\"spinner-icon\"\n          ></ircc-cl-lib-icon>\n        </div>\n        <div class=\"text\">\n          <div\n            class=\"label\"\n            [innerHTML]=\"config.label\"\n          ></div>\n          <div\n            *ngIf=\"config.size === 'large'\"\n            class=\"desc\"\n            [innerHTML]=\"config.description\"\n          ></div>\n        </div>\n      </div>\n      <div\n        *ngSwitchDefault\n        class=\"container\"\n      >\n        <div class=\"icon-div\">\n          <img\n            src=\"./src/assets/icons/spinner-states.svg\"\n            [attr.alt]=\"config.label || config.description ? '' : text[0]\"\n            class=\"animated-icon loading-icon\"\n          />\n        </div>\n        <div class=\"text\">\n          <div\n            class=\"label\"\n            [innerHTML]=\"config.label\"\n          ></div>\n          <div\n            *ngIf=\"config.size === 'large'\"\n            class=\"desc\"\n            [innerHTML]=\"config.description\"\n          ></div>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], type: [{
                type: Input
            }], size: [{
                type: Input
            }], orientation: [{
                type: Input
            }], label: [{
                type: Input
            }], description: [{
                type: Input
            }] } });

class DynamicImageComponent {
    constructor(translate, renderer, el) {
        this.translate = translate;
        this.renderer = renderer;
        this.el = el;
        this.config = {
            id: '',
            breakpoints: [{ maxWidth: DSViewPortSize.default, src: '' }],
            altText: '',
            defaultSrc: '',
            lazyLoad: false
        };
        this.id = '';
        this.altText = '';
        this.defaultSrc = '';
        this.lazyLoad = false;
    }
    ngOnInit() {
        if (this.id)
            this.config.id = this.id;
        if (this.breakpoints)
            this.config.breakpoints = this.breakpoints;
        if (this.altText)
            this.config.altText = this.altText;
        if (this.defaultSrc)
            this.config.defaultSrc = this.defaultSrc;
        if (this.lazyLoad)
            this.config.lazyLoad = this.lazyLoad;
    }
    ngAfterViewInit() {
        this.updateImageSrc();
        window.addEventListener('resize', () => this.updateImageSrc());
    }
    updateImageSrc() {
        var _a, _b, _c;
        if ((_a = this.image) === null || _a === void 0 ? void 0 : _a.nativeElement) {
            const screenWidth = window.innerWidth;
            // Find the matching breakpoint for the current screen width
            const breakpoint = this.config.breakpoints.find((breakpoint) => screenWidth <= breakpoint.maxWidth);
            if (breakpoint) {
                // Set the src attribute of the image to the matched breakpoint's src
                this.renderer.setAttribute((_b = this.image) === null || _b === void 0 ? void 0 : _b.nativeElement, 'src', breakpoint.src);
            }
            else {
                // If no matching breakpoint is found, use the default src image
                this.renderer.setAttribute((_c = this.image) === null || _c === void 0 ? void 0 : _c.nativeElement, 'src', this.config.defaultSrc);
            }
        }
    }
}
DynamicImageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DynamicImageComponent, deps: [{ token: i1.TranslateService }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
DynamicImageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: DynamicImageComponent, selector: "ircc-cl-lib-dynamic-image", inputs: { config: "config", id: "id", breakpoints: "breakpoints", altText: "altText", defaultSrc: "defaultSrc", lazyLoad: "lazyLoad" }, viewQueries: [{ propertyName: "image", first: true, predicate: ["image"], descendants: true, static: true }], ngImport: i0, template: "<div\n  id=\"{{ config.id + '-container' }}\"\n  class=\"dynamic-image-wrapper\"\n>\n  <img\n    #image\n    [alt]=\"config.altText || '' | translate\"\n    [attr.loading]=\"config.lazyLoad ? 'lazy' : null\"\n  />\n</div>\n", dependencies: [{ kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DynamicImageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-dynamic-image', template: "<div\n  id=\"{{ config.id + '-container' }}\"\n  class=\"dynamic-image-wrapper\"\n>\n  <img\n    #image\n    [alt]=\"config.altText || '' | translate\"\n    [attr.loading]=\"config.lazyLoad ? 'lazy' : null\"\n  />\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { image: [{
                type: ViewChild,
                args: ['image', { static: true }]
            }], config: [{
                type: Input
            }], id: [{
                type: Input
            }], breakpoints: [{
                type: Input
            }], altText: [{
                type: Input
            }], defaultSrc: [{
                type: Input
            }], lazyLoad: [{
                type: Input
            }] } });

const IrccDsSharedComponents$1 = [autocompletePipe];
class IrccDsAngularPipesdModule {
}
IrccDsAngularPipesdModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularPipesdModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularPipesdModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularPipesdModule, declarations: [autocompletePipe], imports: [CommonModule, TranslateModule, RouterModule], exports: [CommonModule,
        TranslateModule,
        RouterModule, autocompletePipe] });
IrccDsAngularPipesdModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularPipesdModule, imports: [CommonModule, TranslateModule, RouterModule, CommonModule,
        TranslateModule,
        RouterModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularPipesdModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...IrccDsSharedComponents$1],
                    imports: [CommonModule, TranslateModule, RouterModule],
                    exports: [
                        CommonModule,
                        TranslateModule,
                        RouterModule,
                        ...IrccDsSharedComponents$1
                    ]
                }]
        }] });

const IrccDsSharedComponents = [
    ButtonComponent,
    BreadcrumbComponent,
    BreadcrumbLinkComponent,
    IconComponent,
    IconButtonComponent,
    IndicatorComponent,
    TabsComponent,
    ProgressTagsComponent,
    DropdownComponent,
    LabelComponent,
    ProgressTagsComponent,
    ProgressIndicatorComponent,
    SpinnerComponent,
    FlyoutComponent,
    FlyoutOptionComponent,
    DynamicImageComponent
];
class IrccDsAngularComponentsSharedModule {
}
IrccDsAngularComponentsSharedModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularComponentsSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularComponentsSharedModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularComponentsSharedModule, declarations: [ButtonComponent,
        BreadcrumbComponent,
        BreadcrumbLinkComponent,
        IconComponent,
        IconButtonComponent,
        IndicatorComponent,
        TabsComponent,
        ProgressTagsComponent,
        DropdownComponent,
        LabelComponent,
        ProgressTagsComponent,
        ProgressIndicatorComponent,
        SpinnerComponent,
        FlyoutComponent,
        FlyoutOptionComponent,
        DynamicImageComponent, DomChangeDirective], imports: [CommonModule,
        TranslateModule,
        RouterModule,
        ScrollingModule,
        ScrollingModule$1,
        IrccDsAngularPipesdModule], exports: [CommonModule,
        TranslateModule,
        RouterModule,
        ScrollingModule,
        ScrollingModule$1, ButtonComponent,
        BreadcrumbComponent,
        BreadcrumbLinkComponent,
        IconComponent,
        IconButtonComponent,
        IndicatorComponent,
        TabsComponent,
        ProgressTagsComponent,
        DropdownComponent,
        LabelComponent,
        ProgressTagsComponent,
        ProgressIndicatorComponent,
        SpinnerComponent,
        FlyoutComponent,
        FlyoutOptionComponent,
        DynamicImageComponent] });
IrccDsAngularComponentsSharedModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularComponentsSharedModule, imports: [CommonModule,
        TranslateModule,
        RouterModule,
        ScrollingModule,
        ScrollingModule$1,
        IrccDsAngularPipesdModule, CommonModule,
        TranslateModule,
        RouterModule,
        ScrollingModule,
        ScrollingModule$1] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularComponentsSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...IrccDsSharedComponents, DomChangeDirective],
                    imports: [
                        CommonModule,
                        TranslateModule,
                        RouterModule,
                        ScrollingModule,
                        ScrollingModule$1,
                        IrccDsAngularPipesdModule
                    ],
                    exports: [
                        CommonModule,
                        TranslateModule,
                        RouterModule,
                        ScrollingModule,
                        ScrollingModule$1,
                        ...IrccDsSharedComponents
                    ]
                }]
        }] });

class IrccDsAngularBannerModule {
}
IrccDsAngularBannerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularBannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularBannerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularBannerModule, declarations: [BannerComponent], imports: [IrccDsAngularComponentsSharedModule, CommonModule, TranslateModule], exports: [BannerComponent] });
IrccDsAngularBannerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularBannerModule, imports: [IrccDsAngularComponentsSharedModule, CommonModule, TranslateModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularBannerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [BannerComponent],
                    imports: [IrccDsAngularComponentsSharedModule, CommonModule, TranslateModule],
                    exports: [BannerComponent]
                }]
        }] });

class ErrorComponent {
    constructor() { }
    ngOnInit() {
        //Initial null and override check:
        if (!this.config)
            this.config = {
                id: '',
                errorLOV: ''
            };
        this.portInputValues();
    }
    ngOnChanges(changes) {
        this.portInputValues();
    }
    portInputValues() {
        var _a, _b;
        if (this.config) {
            if (this.id)
                this.config.id = this.id;
            if (this.errorLOV)
                this.config.errorLOV = this.errorLOV;
            if (this.icon)
                this.config.icon = this.icon;
            if (this.size)
                this.config.size = this.size;
            this.iconConfig = {
                FA_keywords: (_b = (_a = this.config.icon) === null || _a === void 0 ? void 0 : _a.class) !== null && _b !== void 0 ? _b : 'fa-light fa-circle-exclamation',
                size: this.config.size
            };
        }
    }
}
ErrorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ErrorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ErrorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: { config: "config", id: "id", errorLOV: "errorLOV", icon: "icon", size: "size" }, usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"{{ config?.size }} errorComponent\"\n  id=\"{{ config?.id }}\"\n  [ngClass]=\"{ errorContainer: config?.id?.endsWith('error0') }\"\n>\n  <ircc-cl-lib-icon\n    *ngIf=\"config?.id?.endsWith('error0') && iconConfig\"\n    [config]=\"iconConfig\"\n    class=\"errorIcon\"\n  ></ircc-cl-lib-icon>\n  <p\n    [ngClass]=\"{ additionalError: !config?.id?.endsWith('error0') }\"\n    class=\"errorText\"\n  >\n    {{ config?.errorLOV || '' | translate }}\n  </p>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ErrorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-error', template: "<div\n  class=\"{{ config?.size }} errorComponent\"\n  id=\"{{ config?.id }}\"\n  [ngClass]=\"{ errorContainer: config?.id?.endsWith('error0') }\"\n>\n  <ircc-cl-lib-icon\n    *ngIf=\"config?.id?.endsWith('error0') && iconConfig\"\n    [config]=\"iconConfig\"\n    class=\"errorIcon\"\n  ></ircc-cl-lib-icon>\n  <p\n    [ngClass]=\"{ additionalError: !config?.id?.endsWith('error0') }\"\n    class=\"errorText\"\n  >\n    {{ config?.errorLOV || '' | translate }}\n  </p>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], errorLOV: [{
                type: Input
            }], icon: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

var InputTypes;
(function (InputTypes) {
    InputTypes["text"] = "text";
    InputTypes["password"] = "password";
    InputTypes["autocomplete"] = "autocomplete";
})(InputTypes || (InputTypes = {}));
const ARIA_TEXT = {
    en: {
        btnTypePasswordAriaLabel: 'password eye icon',
        btnTypePasswordShowAriaLabel: 'display password text',
        btnTypePasswordHideAriaLabel: 'mark password text',
        btnTypeAutoCompleteClear: 'clear text'
    },
    fr: {
        btnTypePasswordAriaLabel: "icône d'oeil de mot de passe",
        btnTypePasswordShowAriaLabel: 'afficher le texte du mot de passe',
        btnTypePasswordHideAriaLabel: 'mark password text',
        btnTypeAutoCompleteClear: 'Effacer le texte'
    }
};
class InputComponent {
    constructor(standAloneFunctions, translate, changeDetectorRef, renderer) {
        this.standAloneFunctions = standAloneFunctions;
        this.translate = translate;
        this.changeDetectorRef = changeDetectorRef;
        this.renderer = renderer;
        this.formGroupEmpty = new FormGroup({});
        /**
         * Note: DON'T include default values of '' unless it REALLY makes sense to do so - instead, make them optional.
         * The config input is where you declare the inputs desired properties such as labels, hints, descriptions, etc. where only the id and form group are mandatory properties. Refer to IInputComponentConfig interface.
         */
        this.config = {
            id: '',
            formGroup: new FormGroup({})
        };
        /**
         * The input id is used to identify the component uniquely for subscribing to value changes and errors
         */
        this.id = '';
        /**
         * FormGroup aggregates the values of each child FormControl into one object, with each control name as the key. It calculates its status by reducing the status values of its children. For example, if one of the controls in a group is invalid, the entire group becomes invalid.
         */
        this.formGroup = this.formGroupEmpty;
        /**
         * Type refers to the 2 different input options: basic text or password as the password type has additional configuration
         */
        this.type = InputTypes.password;
        this.focusEvent = new EventEmitter();
        this.disabled = false;
        this.focusState = false;
        this.typeControl = InputTypes.text;
        this.btnAriaLabel = '';
        this.btnAriaLabelHide = '';
        this.btnAriaLabelShow = '';
        this.btnAriaTypeAutoCompleteClear = '';
        this.errorIds = [];
        this.errorAria = '';
        this.labelConfig = {
            formGroup: this.config.formGroup,
            parentID: ''
        };
        this.touched = false;
        this.errorStubText = '';
        this.currentStatus = 'VALID';
        this.buttonAutoCompleteClear = {
            id: `${this.config.id}-button-autocomplete`,
            category: 'custom',
            size: 'extraSmall',
            icon: {
                class: 'fa-solid fa-circle-xmark',
                color: 'var(--neutral-text)'
            }
        };
        this.buttonAutoCompleteClearClicked = false;
        //Removed '!' and added null case in onChange
        this.onTouch = () => {
            var _a, _b, _c, _d;
            if (((_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched) === false) {
                (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.markAsTouched();
            }
        };
        this.onChange = (value) => {
            var _a;
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(value);
        };
        //set config from individual options, if present
        if (this.formGroup !== this.formGroupEmpty) {
            this.config.formGroup = this.formGroup;
        }
        if (this.id !== '') {
            this.config.id = this.id;
        }
        if (!this.config.type) {
            this.config.type = InputTypes.text;
        }
        else if (this.config.type === InputTypes.password) {
            this.showPassword = false;
            this.typeControl = InputTypes.password;
        }
        if (this.size)
            this.config.size = this.size;
        if (this.label)
            this.config.label = this.label;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.required)
            this.config.required = this.required;
        if (this.placeholder)
            this.config.placeholder = this.placeholder;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
    }
    ngAfterContentChecked() {
        this.changeDetectorRef.detectChanges();
    }
    /**
     * When the page loads, we initialize the form with it's controls, labels, and config, and detect value changes and errors. setLang detects changes to the language toggle to serve the correct text
     */
    ngOnInit() {
        var _a, _b;
        const retControl = this.config.formGroup.get(this.config.id);
        if (retControl) {
            this.formControl = retControl;
        }
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
        this.type === InputTypes.text
            ? (this.showPassword = false)
            : (this.showPassword = true);
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        //set disable to true when form is disabled
        this.config.formGroup.valueChanges.subscribe((change) => {
            var _a;
            this.disabled = (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.disabled;
        });
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
        this.currentStatus =
            ((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.status) || 'DISABLED';
        switch (this.currentStatus) {
            case 'DISABLED':
                this.setDisabledState(true);
                break;
            default:
                this.setDisabledState(false);
        } //Get the error text when the formControl value changes
        (_b = this.config.formGroup
            .get(this.config.id)) === null || _b === void 0 ? void 0 : _b.statusChanges.subscribe((change) => {
            this.getAriaErrorText();
            if (change !== this.currentStatus) {
                this.currentStatus = change;
                switch (this.currentStatus) {
                    case 'DISABLED':
                        this.setDisabledState(true);
                        break;
                    default:
                        this.setDisabledState(false);
                }
            }
        });
    }
    /**
     * Get the aria error text for the label
     */
    getAriaErrorText() {
        var _a;
        if (this.config.errorMessages) {
            (_a = this.formControl) === null || _a === void 0 ? void 0 : _a.markAsDirty();
            this.errorAria = this.standAloneFunctions.getErrorAria(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
    }
    /**
     * Set a boolean representing the touched state to true and trigger getAriaErrorText()
     */
    onTouchedLabel() {
        this.touched = true;
        this.getAriaErrorText();
        setTimeout(() => {
            // Do not emit blur event after clicking clear button
            if (!this.buttonAutoCompleteClearClicked) {
                this.focusEvent.emit(false);
            }
            this.buttonAutoCompleteClearClicked = false;
        }, 100);
    }
    onFocus() {
        var _a;
        if (!((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.disabled)) {
            this.focusEvent.emit(true);
        }
    }
    /**
     * setLang detects changes to the language toggle to serve the correct aria error text
     */
    setLang(lang) {
        this.getAriaErrorText();
        if (lang === 'en' || lang === 'en-US') {
            this.errorStubText = ERROR_TEXT_STUB.en;
            this.btnAriaLabel = ARIA_TEXT.en.btnTypePasswordAriaLabel;
            this.btnAriaLabelHide = ARIA_TEXT.en.btnTypePasswordHideAriaLabel;
            this.btnAriaLabelShow = ARIA_TEXT.en.btnTypePasswordShowAriaLabel;
            this.btnAriaTypeAutoCompleteClear = ARIA_TEXT.en.btnTypeAutoCompleteClear;
        }
        else {
            this.errorStubText = ERROR_TEXT_STUB.fr;
            this.btnAriaLabel = ARIA_TEXT.fr.btnTypePasswordAriaLabel;
            this.btnAriaLabelHide = ARIA_TEXT.fr.btnTypePasswordHideAriaLabel;
            this.btnAriaLabelShow = ARIA_TEXT.fr.btnTypePasswordShowAriaLabel;
            this.btnAriaTypeAutoCompleteClear = ARIA_TEXT.en.btnTypeAutoCompleteClear;
        }
    }
    /**
     * A lifecycle hook that is called when any data-bound property of a directive changes.
     */
    ngOnChanges() {
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
        else {
            this.errorIds = [];
        }
        if (this.config.type === InputTypes.autocomplete) {
            this.typeControl = InputTypes.text;
        }
        else if (this.config.type) {
            this.typeControl = this.config.type;
        }
        this.showPassword =
            this.config.type === InputTypes.password &&
                this.typeControl === InputTypes.text;
    }
    /**
     * Apply focus state
     */
    focusInput(focusValue) {
        this.focusState = !focusValue;
    }
    /**
     * Toggle the password field
     */
    hideShow() {
        this.showPassword = !this.showPassword;
        if (this.showPassword) {
            this.typeControl = InputTypes.text;
        }
        else {
            this.typeControl = InputTypes.password;
        }
    }
    clearvalue() {
        var _a;
        this.buttonAutoCompleteClearClicked = true;
        this.config.formGroup.controls[this.config.id].setValue('');
        this.renderer.selectRootElement((_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.nativeElement).focus();
        this.focusEvent.emit(true);
    }
    /**
     * Prevents the info button from being triggered and marks the input as touched.
     * @param event
     */
    enterEvent(event) {
        var _a;
        event.preventDefault();
        (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.markAsTouched();
        this.focusEvent.emit(false);
    }
    escapeEvent(event) {
        var _a;
        event.preventDefault();
        (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.markAsTouched();
        this.focusEvent.emit(false);
    }
    changeValue(event) {
        this.writeValue(event.srcElement.value);
        this.onTouch();
    }
    writeValue(value) {
        this.onChange(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    /**
     * Apply a disabled state
     */
    setDisabledState(isDisabled) {
        var _a, _b;
        if (isDisabled) {
            (_a = this.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.disable();
        }
        else {
            (_b = this.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.enable();
        }
    }
    /**
     * Return error state from FormGroup, must be touched & invalid
     */
    get getErrorState() {
        var _a, _b, _c;
        return ((_c = (((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.touched) &&
            ((_b = this.config.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.invalid))) !== null && _c !== void 0 ? _c : false);
    }
    get getValueLength() {
        var _a, _b;
        if ((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.value) {
            return (_b = this.config.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.value.length;
        }
        else {
            return 0;
        }
    }
}
InputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: InputComponent, deps: [{ token: StandAloneFunctions }, { token: i1.TranslateService }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
InputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: InputComponent, selector: "ircc-cl-lib-input", inputs: { config: "config", id: "id", formGroup: "formGroup", type: "type", size: "size", label: "label", hint: "hint", desc: "desc", required: "required", placeholder: "placeholder", errorMessages: "errorMessages" }, outputs: { focusEvent: "focusEvent" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => InputComponent),
            multi: true
        }
    ], viewQueries: [{ propertyName: "inputEl", first: true, predicate: ["inputEl"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  id=\"{{ config.id + '_container' }}\"\n  class=\"input-wrapper\"\n>\n  <form\n    [formGroup]=\"config.formGroup\"\n    [attr.autocomplete]=\"config.type !== 'autocomplete' ? true : false\"\n  >\n    <div\n      class=\"input-container\"\n      [ngClass]=\"config.size\"\n    >\n      <div class=\"input-text\">\n        <ircc-cl-lib-label\n          [config]=\"labelConfig\"\n          [attr.size]=\"config.size\"\n        ></ircc-cl-lib-label>\n        <div\n          class=\"input-content-area\"\n          [ngClass]=\"focusState === true ? 'focus' : ''\"\n        >\n          <!-- ngModel doesn't mind undefined values, apparently\n          TODO: Should probably change the (keyup) to (onblur) -->\n          <input\n            (blur)=\"onTouchedLabel()\"\n            (focus)=\"onFocus()\"\n            (change)=\"changeValue($event)\"\n            name=\"{{ config.id }}\"\n            class=\"input-field\"\n            placeholder=\"{{ config.placeholder || '' | translate }}\"\n            tabindex=\"0\"\n            [ngClass]=\"\n              config.type === 'password'\n                ? 'input-password-field'\n                : 'input-text-field'\n            \"\n            #inputEl\n            [type]=\"typeControl\"\n            [id]=\"config.id\"\n            [formControlName]=\"config.id\"\n            (keydown.enter)=\"enterEvent($event)\"\n            (keydown.escape)=\"escapeEvent($event)\"\n            [attr.aria-invalid]=\"formControl?.invalid\"\n            [attr.aria-live]=\"'off'\"\n            [attr.aria-label]=\"\n              formControl?.invalid && touched\n                ? (config.label || '' | translate) +\n                  ' ' +\n                  (config.desc || '' | translate) +\n                  ' ' +\n                  (config.hint || '' | translate) +\n                  ' ' +\n                  (errorStubText + ': ' + errorAria)\n                : (config.label || '' | translate) +\n                  ' ' +\n                  (config.desc || '' | translate) +\n                  ' ' +\n                  (config.hint || '' | translate)\n            \"\n          />\n\n          <button\n            *ngIf=\"config.type === 'password'\"\n            role=\"button\"\n            category=\"plain\"\n            tabindex=\"0\"\n            class=\"passwordIcon\"\n            (click)=\"hideShow()\"\n            [disabled]=\"currentStatus === 'DISABLED'\"\n            attr.aria-label=\"{{ btnAriaLabel }}\"\n            aria-live=\"polite\"\n          >\n            <div\n              *ngIf=\"showPassword\"\n              role=\"img\"\n              attr.aria-label=\"{{ btnAriaLabelHide }}\"\n            >\n              <i class=\"fa-solid fa-eye-slash\"></i>\n            </div>\n            <div\n              *ngIf=\"!showPassword\"\n              role=\"img\"\n              attr.aria-label=\"{{ btnAriaLabelShow }}\"\n            >\n              <i class=\"fa-solid fa-eye\"></i>\n            </div>\n          </button>\n\n          <ng-container\n            *ngIf=\"config.type === 'autocomplete' && getValueLength > 0\"\n          >\n            <ircc-cl-lib-icon-button\n              class=\"autocompleteicon\"\n              (clickEvent)=\"clearvalue()\"\n              [config]=\"buttonAutoCompleteClear\"\n              [attr.size]=\"config.size\"\n            ></ircc-cl-lib-icon-button>\n          </ng-container>\n        </div>\n      </div>\n      <div aria-live=\"polite\">\n        <div *ngIf=\"config.formGroup.get(config.id)?.touched && currentStatus === 'INVALID'\">\n          <span class=\"sr-only\">{{\n            errorStubText + ': ' + (config.label || '' | translate) + ': '\n          }}</span>\n          <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n            <div\n              *ngIf=\"formControl?.errors?.[errors.key]\"\n              class=\"radio-errors\"\n            >\n              <ircc-cl-lib-error\n                [id]=\"errors.id\"\n                [errorLOV]=\"errors.errorLOV\"\n                [size]=\"config.size\"\n              ></ircc-cl-lib-error>\n            </div>\n          </ng-container>\n        </div>\n      </div>\n    </div>\n  </form>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconButtonComponent, selector: "ircc-cl-lib-icon-button", inputs: ["config", "id", "category", "size", "ariaLabel", "disabled", "icon"], outputs: ["clickEvent"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "directive", type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i5.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i5.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i5.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: InputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-input', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => InputComponent),
                            multi: true
                        }
                    ], template: "<div\n  id=\"{{ config.id + '_container' }}\"\n  class=\"input-wrapper\"\n>\n  <form\n    [formGroup]=\"config.formGroup\"\n    [attr.autocomplete]=\"config.type !== 'autocomplete' ? true : false\"\n  >\n    <div\n      class=\"input-container\"\n      [ngClass]=\"config.size\"\n    >\n      <div class=\"input-text\">\n        <ircc-cl-lib-label\n          [config]=\"labelConfig\"\n          [attr.size]=\"config.size\"\n        ></ircc-cl-lib-label>\n        <div\n          class=\"input-content-area\"\n          [ngClass]=\"focusState === true ? 'focus' : ''\"\n        >\n          <!-- ngModel doesn't mind undefined values, apparently\n          TODO: Should probably change the (keyup) to (onblur) -->\n          <input\n            (blur)=\"onTouchedLabel()\"\n            (focus)=\"onFocus()\"\n            (change)=\"changeValue($event)\"\n            name=\"{{ config.id }}\"\n            class=\"input-field\"\n            placeholder=\"{{ config.placeholder || '' | translate }}\"\n            tabindex=\"0\"\n            [ngClass]=\"\n              config.type === 'password'\n                ? 'input-password-field'\n                : 'input-text-field'\n            \"\n            #inputEl\n            [type]=\"typeControl\"\n            [id]=\"config.id\"\n            [formControlName]=\"config.id\"\n            (keydown.enter)=\"enterEvent($event)\"\n            (keydown.escape)=\"escapeEvent($event)\"\n            [attr.aria-invalid]=\"formControl?.invalid\"\n            [attr.aria-live]=\"'off'\"\n            [attr.aria-label]=\"\n              formControl?.invalid && touched\n                ? (config.label || '' | translate) +\n                  ' ' +\n                  (config.desc || '' | translate) +\n                  ' ' +\n                  (config.hint || '' | translate) +\n                  ' ' +\n                  (errorStubText + ': ' + errorAria)\n                : (config.label || '' | translate) +\n                  ' ' +\n                  (config.desc || '' | translate) +\n                  ' ' +\n                  (config.hint || '' | translate)\n            \"\n          />\n\n          <button\n            *ngIf=\"config.type === 'password'\"\n            role=\"button\"\n            category=\"plain\"\n            tabindex=\"0\"\n            class=\"passwordIcon\"\n            (click)=\"hideShow()\"\n            [disabled]=\"currentStatus === 'DISABLED'\"\n            attr.aria-label=\"{{ btnAriaLabel }}\"\n            aria-live=\"polite\"\n          >\n            <div\n              *ngIf=\"showPassword\"\n              role=\"img\"\n              attr.aria-label=\"{{ btnAriaLabelHide }}\"\n            >\n              <i class=\"fa-solid fa-eye-slash\"></i>\n            </div>\n            <div\n              *ngIf=\"!showPassword\"\n              role=\"img\"\n              attr.aria-label=\"{{ btnAriaLabelShow }}\"\n            >\n              <i class=\"fa-solid fa-eye\"></i>\n            </div>\n          </button>\n\n          <ng-container\n            *ngIf=\"config.type === 'autocomplete' && getValueLength > 0\"\n          >\n            <ircc-cl-lib-icon-button\n              class=\"autocompleteicon\"\n              (clickEvent)=\"clearvalue()\"\n              [config]=\"buttonAutoCompleteClear\"\n              [attr.size]=\"config.size\"\n            ></ircc-cl-lib-icon-button>\n          </ng-container>\n        </div>\n      </div>\n      <div aria-live=\"polite\">\n        <div *ngIf=\"config.formGroup.get(config.id)?.touched && currentStatus === 'INVALID'\">\n          <span class=\"sr-only\">{{\n            errorStubText + ': ' + (config.label || '' | translate) + ': '\n          }}</span>\n          <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n            <div\n              *ngIf=\"formControl?.errors?.[errors.key]\"\n              class=\"radio-errors\"\n            >\n              <ircc-cl-lib-error\n                [id]=\"errors.id\"\n                [errorLOV]=\"errors.errorLOV\"\n                [size]=\"config.size\"\n              ></ircc-cl-lib-error>\n            </div>\n          </ng-container>\n        </div>\n      </div>\n    </div>\n  </form>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: StandAloneFunctions }, { type: i1.TranslateService }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], type: [{
                type: Input
            }], size: [{
                type: Input
            }], label: [{
                type: Input
            }], hint: [{
                type: Input
            }], desc: [{
                type: Input
            }], required: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }], focusEvent: [{
                type: Output
            }], inputEl: [{
                type: ViewChild,
                args: ['inputEl']
            }] } });

class RadioInputComponent {
    constructor(standAloneFunctions, translate) {
        this.standAloneFunctions = standAloneFunctions;
        this.translate = translate;
        this.formGroupEmpty = new FormGroup({});
        this.touched = false;
        this.errorIds = [];
        this.currentStatus = 'VALID';
        this.config = {
            id: '',
            formGroup: this.formGroupEmpty
        };
        this.id = '';
        this.formGroup = this.formGroupEmpty;
        this.labelConfig = {
            formGroup: this.config.formGroup,
            parentID: ''
        };
        this.errorStubText = '';
        this.errorAria = '';
        this.onTouch = () => {
            var _a, _b, _c, _d;
            if (((_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched) === false) {
                (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.markAsTouched();
            }
        };
        this.onChange = (value) => {
            var _a;
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(value);
        };
    }
    changeValue(event) {
        this.writeValue(event.srcElement.value);
        this.onTouch();
    }
    writeValue(value) {
        this.onChange(value);
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouch = onTouched;
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouch();
            this.touched = true;
        }
    }
    ngOnInit() {
        var _a, _b;
        const retControl = this.config.formGroup.get(this.config.id);
        if (retControl) {
            this.formControl = retControl;
        }
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        //set config from individual options, if present
        if (this.id !== '')
            this.config.id = this.id;
        if (this.formGroup !== this.formGroupEmpty)
            this.config.formGroup = this.formGroup;
        if (this.size)
            this.config.size = this.size;
        if (this.label)
            this.config.label = this.label;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.required)
            this.config.required = this.required;
        if (this.options)
            this.config.options = this.options;
        if (this.disabled)
            this.config.disabled = this.disabled;
        if (this.error)
            this.config.error = this.error;
        if (this.validators)
            this.config.validators = this.validators;
        if (this.helpText)
            this.config.helpText = this.helpText;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
        this.currentStatus = ((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.status) || 'DISABLED';
        this.toggleDisabledState();
        (_b = this.config.formGroup
            .get(this.config.id)) === null || _b === void 0 ? void 0 : _b.statusChanges.subscribe((change) => {
            this.getAriaErrorText();
            if (change !== this.currentStatus) {
                this.currentStatus = change;
                this.toggleDisabledState();
            }
        });
    }
    toggleDisabledState() {
        switch (this.currentStatus) {
            case 'DISABLED':
                this.setDisabledState(true);
                break;
            default:
                this.setDisabledState(false);
                break;
        }
    }
    ngOnChanges() {
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
    }
    /**
     * Get the aria error text for the label
     */
    getAriaErrorText() {
        var _a;
        if (this.config.errorMessages) {
            (_a = this.formControl) === null || _a === void 0 ? void 0 : _a.markAsDirty();
            this.errorAria = this.standAloneFunctions.getErrorAria(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
    }
    /**
     * Set a boolean representing the touched state to true and trigger getAriaErrorText()
     */
    onTouchedLabel() {
        this.touched = true;
        this.getAriaErrorText();
    }
    setLang(lang) {
        this.getAriaErrorText();
        if (lang === 'en' || lang === 'en-US') {
            this.errorStubText = ERROR_TEXT_STUB.en;
        }
        else {
            this.errorStubText = ERROR_TEXT_STUB.fr;
        }
    }
    setDisabledState(isDisabled) {
        var _a, _b;
        if (isDisabled) {
            (_a = this.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.disable();
        }
        else {
            (_b = this.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.enable();
        }
    }
}
RadioInputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: RadioInputComponent, deps: [{ token: StandAloneFunctions }, { token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
RadioInputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: RadioInputComponent, selector: "ircc-cl-lib-radio-input", inputs: { config: "config", id: "id", formGroup: "formGroup", size: "size", label: "label", desc: "desc", hint: "hint", required: "required", options: "options", disabled: "disabled", error: "error", validators: "validators", helpText: "helpText", errorMessages: "errorMessages" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            multi: true,
            useExisting: forwardRef(() => RadioInputComponent) //This allows the error state to be turned off and on again
        }
    ], usesOnChanges: true, ngImport: i0, template: "<form\n  [formGroup]=\"config.formGroup\"\n  [ngClass]=\"config.size\"\n>\n  <ircc-cl-lib-label\n    [config]=\"labelConfig\"\n    [attr.size]=\"config.size\"\n    [legend]=\"true\"\n  ></ircc-cl-lib-label>\n  <div class=\"radio-buttons\">\n    <div\n      *ngFor=\"let option of config.options; let index = index\"\n      class=\"radio\"\n    >\n      <!-- TODO: See if we can remove the error state from here, since it is controlled by the formControl -->\n      <input\n        (blur)=\"touched = true\"\n        type=\"radio\"\n        value=\"{{ option.value || option.text }}\"\n        id=\"{{ config.id + index }}\"\n        (click)=\"standAloneFunctions.wasTouched(config.formGroup, config.id)\"\n        [formControlName]=\"config.id ? config.id : 'formControl'\"\n        [ngClass]=\"option?.sizeOverride ? option?.sizeOverride : config.size\"\n        [attr.aria-invalid]=\"formControl?.invalid\"\n        [attr.aria-live]=\"'off'\"\n        [attr.aria-label]=\"\n          formControl?.invalid && touched\n            ? (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate) +\n              ' ' +\n              (config.helpText || '' | translate) +\n              ' ' +\n              (option.text || '' | translate) +\n              ' ' +\n              (errorStubText + ': ' + errorAria)\n            : (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate) +\n              ' ' +\n              (config.helpText || '' | translate) +\n              ' ' +\n              (option.text || '' | translate)\n        \"\n      />\n      <label\n        for=\"{{ config.id + index }}\"\n        [ngClass]=\"\n          option?.sizeOverride\n            ? option?.sizeOverride + '_label'\n            : config.size + '_label'\n        \"\n        >{{ option.text || '' | translate }}</label\n      >\n    </div>\n  </div>\n  <div aria-live=\"polite\">\n    <ng-container *ngIf=\"config.formGroup.get(config.id)?.touched && currentStatus === 'INVALID'\">\n      <span class=\"sr-only\">{{\n        errorStubText + ': ' + (config.label || '' | translate) + ': '\n      }}</span>\n      <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n        <div\n          *ngIf=\"formControl?.errors?.[errors.key]\"\n          class=\"radio-errors\"\n        >\n          <ircc-cl-lib-error\n            [id]=\"errors.id\"\n            [errorLOV]=\"errors.errorLOV\"\n            [size]=\"config.size\"\n          ></ircc-cl-lib-error>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</form>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "directive", type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i5.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i5.RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: ["name", "formControlName", "value"] }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i5.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i5.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: RadioInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-radio-input', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            multi: true,
                            useExisting: forwardRef(() => RadioInputComponent) //This allows the error state to be turned off and on again
                        }
                    ], template: "<form\n  [formGroup]=\"config.formGroup\"\n  [ngClass]=\"config.size\"\n>\n  <ircc-cl-lib-label\n    [config]=\"labelConfig\"\n    [attr.size]=\"config.size\"\n    [legend]=\"true\"\n  ></ircc-cl-lib-label>\n  <div class=\"radio-buttons\">\n    <div\n      *ngFor=\"let option of config.options; let index = index\"\n      class=\"radio\"\n    >\n      <!-- TODO: See if we can remove the error state from here, since it is controlled by the formControl -->\n      <input\n        (blur)=\"touched = true\"\n        type=\"radio\"\n        value=\"{{ option.value || option.text }}\"\n        id=\"{{ config.id + index }}\"\n        (click)=\"standAloneFunctions.wasTouched(config.formGroup, config.id)\"\n        [formControlName]=\"config.id ? config.id : 'formControl'\"\n        [ngClass]=\"option?.sizeOverride ? option?.sizeOverride : config.size\"\n        [attr.aria-invalid]=\"formControl?.invalid\"\n        [attr.aria-live]=\"'off'\"\n        [attr.aria-label]=\"\n          formControl?.invalid && touched\n            ? (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate) +\n              ' ' +\n              (config.helpText || '' | translate) +\n              ' ' +\n              (option.text || '' | translate) +\n              ' ' +\n              (errorStubText + ': ' + errorAria)\n            : (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate) +\n              ' ' +\n              (config.helpText || '' | translate) +\n              ' ' +\n              (option.text || '' | translate)\n        \"\n      />\n      <label\n        for=\"{{ config.id + index }}\"\n        [ngClass]=\"\n          option?.sizeOverride\n            ? option?.sizeOverride + '_label'\n            : config.size + '_label'\n        \"\n        >{{ option.text || '' | translate }}</label\n      >\n    </div>\n  </div>\n  <div aria-live=\"polite\">\n    <ng-container *ngIf=\"config.formGroup.get(config.id)?.touched && currentStatus === 'INVALID'\">\n      <span class=\"sr-only\">{{\n        errorStubText + ': ' + (config.label || '' | translate) + ': '\n      }}</span>\n      <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n        <div\n          *ngIf=\"formControl?.errors?.[errors.key]\"\n          class=\"radio-errors\"\n        >\n          <ircc-cl-lib-error\n            [id]=\"errors.id\"\n            [errorLOV]=\"errors.errorLOV\"\n            [size]=\"config.size\"\n          ></ircc-cl-lib-error>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</form>\n" }]
        }], ctorParameters: function () { return [{ type: StandAloneFunctions }, { type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], size: [{
                type: Input
            }], label: [{
                type: Input
            }], desc: [{
                type: Input
            }], hint: [{
                type: Input
            }], required: [{
                type: Input
            }], options: [{
                type: Input
            }], disabled: [{
                type: Input
            }], error: [{
                type: Input
            }], validators: [{
                type: Input
            }], helpText: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }] } });

class MultiCheckboxService {
    constructor() {
        //This is a subject, we're making subject => observable after
        // Anytime change to subject, it will propagate out to all other things related to it
        this.multiCheckboxEventSubj = new Subject();
        this.multiCheckboxEventObs$ = this.multiCheckboxEventSubj.asObservable(); //Use this for any events we need propagated up to parents
        this.multiCheckboxErrorSubj = new Subject();
        this.multiCheckboxErrorObs$ = this.multiCheckboxErrorSubj.asObservable();
    }
    /**
     * Broadcast element events
     * @param event: ImultiCheckboxEvent where id is the id of the component broadcasting and event is the Event
     */
    checkEvent(event) {
        this.multiCheckboxEventSubj.next(event);
    }
    errorEvent(event) {
        this.multiCheckboxErrorSubj.next(event);
    }
    /**
     * Checks to see if an AbstractControl is valid or not.
     * @param control: AbstractControl field that we are checking
     * @param field: string, name of the field we are checking
     */
    checkField(id) {
        //is the control valid
        this.errorEvent(id);
    }
}
MultiCheckboxService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: MultiCheckboxService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MultiCheckboxService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: MultiCheckboxService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: MultiCheckboxService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class CheckboxComponent {
    constructor(standAloneFunctions, translate, multicheckboxService) {
        this.standAloneFunctions = standAloneFunctions;
        this.translate = translate;
        this.multicheckboxService = multicheckboxService;
        this.formGroupEmpty = new FormGroup({});
        //TODO: Add output - consider using a formControl as output rather than anything else. Many different approaches are possible
        this.config = {
            id: '',
            formGroup: this.formGroupEmpty,
            size: DSSizes.large,
            label: '',
            inlineLabel: ''
        };
        this.formGroup = this.formGroupEmpty;
        this.id = '';
        this.label = '';
        this.isDisabled = false;
        this.errorIds = [];
        this.labelConfig = {
            formGroup: this.config.formGroup,
            parentID: ''
        };
        this.touched = false;
        this.errorAria = '';
        this.errorStubText = '';
        this.currentStatus = 'VALID';
        this.currentTouch = false;
        this.onTouch = () => {
            var _a, _b, _c, _d;
            if (((_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched) === false) {
                (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.markAsTouched();
            }
        };
        this.onChange = (value) => {
            var _a;
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(value);
        };
    }
    changeValue(event) {
        this.writeValue(event.srcElement.value);
        this.onTouch();
    }
    writeValue(value) {
        this.onChange(value);
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouch = onTouched;
    }
    /**
     * This is used automatically by the parent formControl. It is used in the template to set the label to disabled
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        var _a, _b;
        if (isDisabled) {
            (_a = this.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.disable();
        }
        else {
            (_b = this.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.enable();
        }
    }
    ngOnInit() {
        var _a, _b, _c, _d;
        const retControl = this.config.formGroup.get(this.config.id);
        if (retControl) {
            this.formControl = retControl;
        }
        this.configSub = this.multicheckboxService.multiCheckboxEventObs$.subscribe((response) => {
            var _a;
            if (response.id === this.config.id) {
                (_a = this.config.formGroup
                    .get(this.config.id)) === null || _a === void 0 ? void 0 : _a.patchValue(response.event, { emitEvent: false });
            }
        });
        (_a = this.config.formGroup
            .get(this.config.id)) === null || _a === void 0 ? void 0 : _a.valueChanges.subscribe((event) => {
            this.multicheckboxService.checkEvent({
                id: this.config.id,
                event: event
            });
        });
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        //set config from individual options, if present
        if (this.formGroup !== this.formGroupEmpty) {
            this.config.formGroup = this.formGroup;
        }
        if (this.id)
            this.config.id = this.id;
        if (this.label)
            this.config.label = this.label;
        if (this.required)
            this.config.required = this.required;
        if (this.size)
            this.config.size = this.size;
        if (this.mixed)
            this.config.mixed = this.mixed;
        if (this.inlineLabel)
            this.config.inlineLabel = this.inlineLabel;
        if (this.inlineLabelBold)
            this.config.inlineLabelBold = this.inlineLabelBold;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
        if (!((_b = this.config) === null || _b === void 0 ? void 0 : _b.size))
            this.config.size = DSSizes.large;
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id, this.config.errorMessages);
            this.errorIds.forEach((errorId) => {
                this.multicheckboxService.errorEvent(this.config.id);
            });
        }
        this.currentStatus =
            ((_c = this.config.formGroup.get(this.config.id)) === null || _c === void 0 ? void 0 : _c.status) || 'DISABLED';
        this.toggleDisabledState();
        (_d = this.config.formGroup
            .get(this.config.id)) === null || _d === void 0 ? void 0 : _d.statusChanges.subscribe((change) => {
            this.getAriaErrorText();
            //Get the error text when the formControl value changes
            if (change === 'VALID') {
                this.multicheckboxService.errorEvent(this.config.id);
            }
            if (change !== this.currentStatus) {
                this.currentStatus = change;
                this.toggleDisabledState();
            }
            this.setStatus();
        });
        console.log(this.labelConfig);
    }
    setStatus() {
        var _a;
        this.currentStatus =
            ((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.status) || 'DISABLED';
        this.currentTouch = this.config.formGroup.controls[this.config.id].touched;
    }
    ngAfterViewInit() {
        this.setStatus();
    }
    toggleDisabledState() {
        switch (this.currentStatus) {
            case 'DISABLED':
                this.setDisabledState(true);
                break;
            default:
                this.setDisabledState(false);
                break;
        }
    }
    ngOnChanges() {
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
    }
    /**
     * Get the aria error text for the label
     */
    getAriaErrorText() {
        var _a;
        if (this.config.errorMessages) {
            (_a = this.formControl) === null || _a === void 0 ? void 0 : _a.markAsDirty();
            this.errorAria = this.standAloneFunctions.getErrorAria(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
    }
    /**
     * Set a boolean representing the touched state to true and trigger getAriaErrorText()
     */
    onTouchedLabel() {
        this.touched = true;
        this.getAriaErrorText();
    }
    setLang(lang) {
        this.getAriaErrorText();
        if (lang === 'en' || lang === 'en-US') {
            this.errorStubText = ERROR_TEXT_STUB.en;
        }
        else {
            this.errorStubText = ERROR_TEXT_STUB.fr;
        }
    }
    /**
     * Return error state from FormGroup, must be touched & invalid
     */
    get errorState() {
        var _a;
        this.setStatus();
        return ((_a = (this.currentTouch &&
            this.currentStatus === 'INVALID')) !== null && _a !== void 0 ? _a : false);
    }
    clickEvent() {
        this.standAloneFunctions.wasTouched(this.config.formGroup, this.config.id);
    }
    ariaAccess() {
        var _a, _b;
        let returnVal = '';
        if (this.config.label)
            returnVal += this.translate.instant(this.config.label || '') + ' ';
        if (this.config.desc)
            returnVal += this.translate.instant(this.config.desc || '') + ' ';
        if (this.config.hint)
            returnVal += this.translate.instant(this.config.hint || '') + ' ';
        if (this.config.inlineLabel)
            returnVal += this.translate.instant(this.config.inlineLabel || '') + ' ';
        if (this.config.mixed) {
            returnVal += 'Mixed checkbox';
        }
        if (((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.invalid) &&
            ((_b = this.config.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched)) {
            returnVal += this.errorStubText;
            returnVal += this.errorAria;
        }
        return returnVal;
    }
}
CheckboxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: CheckboxComponent, deps: [{ token: StandAloneFunctions }, { token: i1.TranslateService }, { token: MultiCheckboxService }], target: i0.ɵɵFactoryTarget.Component });
CheckboxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: CheckboxComponent, selector: "ircc-cl-lib-checkbox", inputs: { config: "config", formGroup: "formGroup", id: "id", label: "label", required: "required", size: "size", mixed: "mixed", inlineLabel: "inlineLabel", inlineLabelBold: "inlineLabelBold", hint: "hint", desc: "desc", errorMessages: "errorMessages" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => CheckboxComponent),
            multi: true
        }
    ], usesOnChanges: true, ngImport: i0, template: "<form\n  class=\"checkbox-container\"\n  [formGroup]=\"config.formGroup\"\n>\n  <div\n    class=\"checkbox-container\"\n    [ngClass]=\"config.size\"\n  >\n    <ircc-cl-lib-label\n      [config]=\"labelConfig\"\n      [attr.size]=\"config.size\"\n      [legend]=\"true\"\n    ></ircc-cl-lib-label>\n    <div\n      class=\"checkbox-layout\"\n      [ngClass]=\"{\n        error: currentStatus === 'INVALID' && currentTouch === true\n      }\"\n    >\n      <div class=\"checkbox\">\n        <input\n          [attr.aria-live]=\"'off'\"\n          id=\"{{ config.id }}\"\n          class=\"check\"\n          (click)=\"clickEvent()\"\n          [ngClass]=\"{\n            mixed: config.mixed,\n            error: currentStatus === 'INVALID' && currentTouch === true\n          }\"\n          [attr.size]=\"config.size\"\n          type=\"checkbox\"\n          [formControlName]=\"config.id\"\n          [attr.aria-invalid]=\"formControl?.invalid\"\n          [attr.aria-label]=\"ariaAccess()\"\n        />\n        <span class=\"checkmark\"></span>\n      </div>\n      <label\n        [attr.aria-live]=\"'off'\"\n        class=\"checkbox-desc-label\"\n        [for]=\"config.id\"\n        [id]=\"config.id + ' checkbox_label'\"\n        [ngClass]=\"{\n          'disabled-label': currentStatus === 'DISABLED',\n          small: config.size === 'small',\n          makeBold: config.inlineLabelBold\n        }\"\n        >{{ config.inlineLabel || '' | translate }}\n      </label>\n    </div>\n    <div aria-live=\"polite\">\n      <div\n        *ngIf=\"errorState\"\n        class=\"check-error\"\n        [ngClass]=\"{ small: config.size === 'small' }\"\n      >\n        <span class=\"sr-only\">{{\n          errorStubText + ': ' + (config.label || '' | translate) + ': '\n        }}</span>\n\n        <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n          <div\n            *ngIf=\"formControl?.errors?.[errors.key]\"\n            class=\"radio-errors\"\n          >\n            <ircc-cl-lib-error\n              [id]=\"errors.id\"\n              [errorLOV]=\"errors.errorLOV\"\n              [size]=\"config.size\"\n            ></ircc-cl-lib-error>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </div>\n</form>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "directive", type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i5.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i5.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i5.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: CheckboxComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-checkbox', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => CheckboxComponent),
                            multi: true
                        }
                    ], template: "<form\n  class=\"checkbox-container\"\n  [formGroup]=\"config.formGroup\"\n>\n  <div\n    class=\"checkbox-container\"\n    [ngClass]=\"config.size\"\n  >\n    <ircc-cl-lib-label\n      [config]=\"labelConfig\"\n      [attr.size]=\"config.size\"\n      [legend]=\"true\"\n    ></ircc-cl-lib-label>\n    <div\n      class=\"checkbox-layout\"\n      [ngClass]=\"{\n        error: currentStatus === 'INVALID' && currentTouch === true\n      }\"\n    >\n      <div class=\"checkbox\">\n        <input\n          [attr.aria-live]=\"'off'\"\n          id=\"{{ config.id }}\"\n          class=\"check\"\n          (click)=\"clickEvent()\"\n          [ngClass]=\"{\n            mixed: config.mixed,\n            error: currentStatus === 'INVALID' && currentTouch === true\n          }\"\n          [attr.size]=\"config.size\"\n          type=\"checkbox\"\n          [formControlName]=\"config.id\"\n          [attr.aria-invalid]=\"formControl?.invalid\"\n          [attr.aria-label]=\"ariaAccess()\"\n        />\n        <span class=\"checkmark\"></span>\n      </div>\n      <label\n        [attr.aria-live]=\"'off'\"\n        class=\"checkbox-desc-label\"\n        [for]=\"config.id\"\n        [id]=\"config.id + ' checkbox_label'\"\n        [ngClass]=\"{\n          'disabled-label': currentStatus === 'DISABLED',\n          small: config.size === 'small',\n          makeBold: config.inlineLabelBold\n        }\"\n        >{{ config.inlineLabel || '' | translate }}\n      </label>\n    </div>\n    <div aria-live=\"polite\">\n      <div\n        *ngIf=\"errorState\"\n        class=\"check-error\"\n        [ngClass]=\"{ small: config.size === 'small' }\"\n      >\n        <span class=\"sr-only\">{{\n          errorStubText + ': ' + (config.label || '' | translate) + ': '\n        }}</span>\n\n        <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n          <div\n            *ngIf=\"formControl?.errors?.[errors.key]\"\n            class=\"radio-errors\"\n          >\n            <ircc-cl-lib-error\n              [id]=\"errors.id\"\n              [errorLOV]=\"errors.errorLOV\"\n              [size]=\"config.size\"\n            ></ircc-cl-lib-error>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </div>\n</form>\n" }]
        }], ctorParameters: function () { return [{ type: StandAloneFunctions }, { type: i1.TranslateService }, { type: MultiCheckboxService }]; }, propDecorators: { config: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], required: [{
                type: Input
            }], size: [{
                type: Input
            }], mixed: [{
                type: Input
            }], inlineLabel: [{
                type: Input
            }], inlineLabelBold: [{
                type: Input
            }], hint: [{
                type: Input
            }], desc: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }] } });

class SelectComponent {
    constructor(standAloneFunctions, translate) {
        this.standAloneFunctions = standAloneFunctions;
        this.translate = translate;
        this.touched = false;
        this.errorIds = [];
        this.activiatedSelect = false;
        this.rotateChevron = false;
        this.currentStatus = 'VALID';
        this.formGroupEmpty = new FormGroup({});
        this.config = {
            id: '',
            formGroup: new FormGroup({})
        };
        this.id = '';
        this.formGroup = this.formGroupEmpty;
        this.errorAria = '';
        this.labelConfig = {
            formGroup: this.config.formGroup,
            parentID: ''
        };
        this.errorStubText = '';
        this.onTouch = () => {
            var _a, _b, _c, _d;
            if (((_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched) === false) {
                (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.markAsTouched();
            }
        };
        this.onChange = (value) => {
            var _a;
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(value);
        };
    }
    changeValue(event) {
        this.writeValue(event.srcElement.value);
        this.onTouch();
    }
    writeValue(value) {
        this.onChange(value);
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouch = onTouched;
    }
    markAsTouched() {
        if (!this.touched) {
            this.onTouch();
            this.touched = true;
        }
    }
    valueChange($event) {
        this.activiatedSelect = true;
    }
    onClicked() {
        this.rotateChevron = !this.rotateChevron;
    }
    onBlur() {
        this.touched = true;
        this.rotateChevron = false;
    }
    ngOnInit() {
        var _a, _b;
        const retControl = this.config.formGroup.get(this.config.id);
        if (retControl) {
            this.formControl = retControl;
        }
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
        });
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        //set config from individual options, if present
        if (this.formGroup !== this.formGroupEmpty) {
            this.config.formGroup = this.formGroup;
        }
        ;
        if (this.id !== '')
            this.config.id = this.id;
        if (this.size)
            this.config.size = this.size;
        if (this.label)
            this.config.label = this.label;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.placeholder)
            this.config.placeholder = this.placeholder;
        if (this.required)
            this.config.required = this.required;
        if (this.options)
            this.config.options = this.options;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
        if (this.disableError)
            this.config.disableError = this.disableError;
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
        this.currentStatus = ((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.status) || 'DISABLED';
        switch (this.currentStatus) {
            case 'DISABLED':
                this.setDisabledState(true);
                break;
            default:
                this.setDisabledState(false);
        }
        (_b = this.config.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.statusChanges.subscribe((change) => {
            this.getAriaErrorText();
            if (change !== this.currentStatus) {
                this.currentStatus = change;
                switch (this.currentStatus) {
                    case 'DISABLED':
                        this.setDisabledState(true);
                        break;
                    default:
                        this.setDisabledState(false);
                }
            }
        });
    }
    //This is used instead of ngOnChange here because it allows the config to be updated in date-picker.
    //TODO: Replace this with something less blunt
    ngDoCheck() {
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
    }
    /**
     * Apply a disabled state
     */
    setDisabledState(isDisabled) {
        var _a, _b, _c, _d;
        isDisabled
            ? (_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.disable()
            : (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.enable();
    }
    /**
     * Get the aria error text for the label
     */
    getAriaErrorText() {
        var _a;
        if (this.config.errorMessages) {
            (_a = this.formControl) === null || _a === void 0 ? void 0 : _a.markAsDirty();
            this.errorAria = this.standAloneFunctions.getErrorAria(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
    }
    /**
     * Set a boolean representing the touched state to true and trigger getAriaErrorText()
     */
    onTouchedLabel() {
        this.touched = true;
        this.getAriaErrorText();
    }
    setLang(lang) {
        this.getAriaErrorText();
        if (lang === 'en' || lang === 'en-US') {
            this.errorStubText = ERROR_TEXT_STUB.en;
        }
        else {
            this.errorStubText = ERROR_TEXT_STUB.fr;
        }
    }
}
SelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SelectComponent, deps: [{ token: StandAloneFunctions }, { token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
SelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: SelectComponent, selector: "ircc-cl-lib-select", inputs: { config: "config", id: "id", formGroup: "formGroup", size: "size", label: "label", desc: "desc", hint: "hint", placeholder: "placeholder", required: "required", options: "options", errorMessages: "errorMessages", disableError: "disableError" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            multi: true,
            useExisting: forwardRef(() => SelectComponent) //This allows the error state to be turned off and on again
        }
    ], ngImport: i0, template: "<div class=\"{{ config.size }} select-wrapper\">\n  <ircc-cl-lib-label\n    [config]=\"labelConfig\"\n    [attr.size]=\"config.size\"\n  ></ircc-cl-lib-label>\n  <form [formGroup]=\"config.formGroup\">\n    <div class=\"ircc-cl-lib-select\">\n      <select\n        (blur)=\"onBlur()\"\n        (click)=\"onClicked()\"\n        class=\"custom-select h6 select-placeholder\"\n        [name]=\"config.id\"\n        [id]=\"config.id\"\n        [formControlName]=\"config.id\"\n        (change)=\"changeValue($event)\"\n        [class.activited-select]=\"activiatedSelect\"\n        [attr.aria-invalid]=\"formControl?.invalid\"\n        [attr.aria-live]=\"'off'\"\n        [attr.aria-label]=\"\n          formControl?.invalid && touched\n            ? (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate) +\n              ' ' +\n              (errorStubText + ': ' + errorAria)\n            : (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate)\n        \"\n      >\n        <option\n          [value]=\"''\"\n          disabled\n          selected\n          hidden\n        >\n          {{ config.placeholder || '' | translate }}\n        </option>\n        <option\n          *ngFor=\"let option of config.options\"\n          [value]=\"option.value || option.text\"\n          class=\"select-option\"\n        >\n          {{ option.text | translate }}\n        </option>\n      </select>\n      <div\n        class=\"icon-container\"\n        [class.select-clicked]=\"rotateChevron\"\n      >\n        <i class=\"fa-thin fa-chevron-down custom-chevron\"></i>\n      </div>\n    </div>\n\n    <div\n      aria-live=\"polite\"\n      *ngIf=\"!config.disableError\"\n    >\n      <div\n        *ngIf=\"\n          config.formGroup.get(config.id)?.touched &&\n          currentStatus === 'INVALID'\n        \"\n      >\n        <span class=\"sr-only\">{{\n          errorStubText + ': ' + (config.label || '' | translate) + ': '\n        }}</span>\n        <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n          <div\n            *ngIf=\"formControl?.errors?.[errors.key]\"\n            class=\"radio-errors\"\n          >\n            <ircc-cl-lib-error\n              [size]=\"config.size\"\n              [id]=\"errors.id\"\n              [errorLOV]=\"errors.errorLOV\"\n            ></ircc-cl-lib-error>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </form>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "directive", type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i5.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i5.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i5.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i5.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i5.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SelectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-select', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            multi: true,
                            useExisting: forwardRef(() => SelectComponent) //This allows the error state to be turned off and on again
                        }
                    ], template: "<div class=\"{{ config.size }} select-wrapper\">\n  <ircc-cl-lib-label\n    [config]=\"labelConfig\"\n    [attr.size]=\"config.size\"\n  ></ircc-cl-lib-label>\n  <form [formGroup]=\"config.formGroup\">\n    <div class=\"ircc-cl-lib-select\">\n      <select\n        (blur)=\"onBlur()\"\n        (click)=\"onClicked()\"\n        class=\"custom-select h6 select-placeholder\"\n        [name]=\"config.id\"\n        [id]=\"config.id\"\n        [formControlName]=\"config.id\"\n        (change)=\"changeValue($event)\"\n        [class.activited-select]=\"activiatedSelect\"\n        [attr.aria-invalid]=\"formControl?.invalid\"\n        [attr.aria-live]=\"'off'\"\n        [attr.aria-label]=\"\n          formControl?.invalid && touched\n            ? (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate) +\n              ' ' +\n              (errorStubText + ': ' + errorAria)\n            : (config.label || '' | translate) +\n              ' ' +\n              (config.desc || '' | translate) +\n              ' ' +\n              (config.hint || '' | translate)\n        \"\n      >\n        <option\n          [value]=\"''\"\n          disabled\n          selected\n          hidden\n        >\n          {{ config.placeholder || '' | translate }}\n        </option>\n        <option\n          *ngFor=\"let option of config.options\"\n          [value]=\"option.value || option.text\"\n          class=\"select-option\"\n        >\n          {{ option.text | translate }}\n        </option>\n      </select>\n      <div\n        class=\"icon-container\"\n        [class.select-clicked]=\"rotateChevron\"\n      >\n        <i class=\"fa-thin fa-chevron-down custom-chevron\"></i>\n      </div>\n    </div>\n\n    <div\n      aria-live=\"polite\"\n      *ngIf=\"!config.disableError\"\n    >\n      <div\n        *ngIf=\"\n          config.formGroup.get(config.id)?.touched &&\n          currentStatus === 'INVALID'\n        \"\n      >\n        <span class=\"sr-only\">{{\n          errorStubText + ': ' + (config.label || '' | translate) + ': '\n        }}</span>\n        <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n          <div\n            *ngIf=\"formControl?.errors?.[errors.key]\"\n            class=\"radio-errors\"\n          >\n            <ircc-cl-lib-error\n              [size]=\"config.size\"\n              [id]=\"errors.id\"\n              [errorLOV]=\"errors.errorLOV\"\n            ></ircc-cl-lib-error>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </form>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: StandAloneFunctions }, { type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], size: [{
                type: Input
            }], label: [{
                type: Input
            }], desc: [{
                type: Input
            }], hint: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], required: [{
                type: Input
            }], options: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }], disableError: [{
                type: Input
            }] } });

const DATE_PICKER_MONTHS_EN = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
];
const DATE_PICKER_MONTHS_FR = [
    'janvier',
    'février',
    'mars',
    'avril',
    'mai',
    'juin',
    'juillet',
    'août',
    'septembre',
    'octobre',
    'novembre',
    'décembre'
];
const DATE_PICKER_DAY_CONTROL_ID_EXTENSION = '_dayControl';
const DATE_PICKER_MONTH_CONTROL_ID_EXTENSION = '_monthControl';
const DATE_PICKER_YEAR_CONTROL_ID_EXTENSION = '_yearControl';
const DATE_PICKER_LABELS_EN = ['Day', 'Month', 'Year'];
const DATE_PICKER_LABELS_FR = ['Jour', 'Mois', 'Année'];
const DATE_PICKER_PLACEHOLDER_YEAR_EN = 'YYYY';
const DATE_PICKER_PLACEHOLDER_YEAR_FR = 'AAAA';
const DATE_PICKER_PLACEHOLDER_MONTH_EN = 'Month';
const DATE_PICKER_PLACEHOLDER_MONTH_FR = 'Mois';
const DATE_PICKER_PLACEHOLDER_DAY_EN = 'DD';
const DATE_PICKER_PLACEHOLDER_DAY_FR = 'JJ';
const DATE_PICKER_UNKOWN_EN = 'Unknown';
const DATE_PICKER_UNKOWN_FR = 'Inconnu';
class DatePickerComponent {
    constructor(translate, standAloneFunctions) {
        this.translate = translate;
        this.standAloneFunctions = standAloneFunctions;
        this.formGroupEmpty = new FormGroup({});
        this.config = {
            id: '',
            formGroup: new FormGroup({})
        };
        this.formGroup = this.formGroupEmpty;
        this.yearSelectShow = true;
        this.monthSelectShow = true;
        this.daySelectShow = true;
        this.errorIds = [];
        this.days = [];
        this.months = [];
        this.labelConfig = {
            formGroup: this.config.formGroup,
            parentID: ''
        };
        this.touched = false;
        this.errorStubText = '';
        this.dropDownConfigs = {
            day: {
                id: '',
                formGroup: this.config.formGroup,
                label: '',
                options: [],
                size: 'large',
                disableError: true
            },
            month: {
                id: '',
                formGroup: this.config.formGroup,
                label: '',
                options: [],
                size: 'large',
                disableError: true
            },
            year: {
                id: '',
                formGroup: this.config.formGroup,
                label: '',
                options: [],
                size: 'large',
                disableError: true
            }
        };
        this.yearSelect = '';
        this.monthSelect = '';
        this.daySelect = '';
        //Get the current year for use in the year dropdown
        this.currentYear = new Date().getFullYear();
        this.onTouch = () => {
            var _a, _b, _c, _d;
            if (((_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched) === false) {
                (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.markAsTouched();
            }
        };
        this.onChange = (value) => {
            var _a;
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(value);
        };
    }
    ngOnInit() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        //set config from individual options, if present
        if (this.formGroup !== this.formGroupEmpty) {
            this.config.formGroup = this.formGroup;
        }
        ;
        if (this.id)
            this.config.id = this.id;
        if (this.size)
            this.config.size = this.size;
        if (this.label)
            this.config.label = this.label;
        if (this.required)
            this.config.required = this.required;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
        if (this.maxYear)
            this.config.maxYear = this.maxYear;
        if (this.minYear)
            this.config.minYear = this.minYear;
        if (this.unknownDateToggle)
            this.config.unknownDateToggle = this.unknownDateToggle;
        if (this.yearSelectShow)
            this.config.yearSelectShow = this.yearSelectShow;
        if (this.monthSelectShow)
            this.config.monthSelectShow = this.monthSelectShow;
        if (this.daySelectShow)
            this.config.daySelectShow = this.daySelectShow;
        //Set the ids for the dropdowns
        this.dropDownConfigs.day.id =
            this.config.id + DATE_PICKER_DAY_CONTROL_ID_EXTENSION;
        this.dropDownConfigs.month.id =
            this.config.id + DATE_PICKER_MONTH_CONTROL_ID_EXTENSION;
        this.dropDownConfigs.year.id =
            this.config.id + DATE_PICKER_YEAR_CONTROL_ID_EXTENSION;
        this.dropDownConfigs.day.formGroup = this.config.formGroup;
        this.dropDownConfigs.month.formGroup = this.config.formGroup;
        this.dropDownConfigs.year.formGroup = this.config.formGroup;
        this.dropDownConfigs.day.size = this.config.size;
        this.dropDownConfigs.month.size = this.config.size;
        this.dropDownConfigs.year.size = this.config.size;
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id + DATE_PICKER_YEAR_CONTROL_ID_EXTENSION, this.config.errorMessages);
        }
        // Populate the months and years arrays
        this.setMonthsLanguage();
        this.setLabelLanguage();
        this.translate.onLangChange.subscribe(() => {
            this.setMonthsLanguage();
            this.setYearDayLanguage();
            this.setLabelLanguage();
            this.getAriaOverride();
        });
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            if ((_a = this.config.unknownDateToggle) === null || _a === void 0 ? void 0 : _a.yearUnknown)
                (_b = this.dropDownConfigs.year.options) === null || _b === void 0 ? void 0 : _b.push({
                    text: DATE_PICKER_UNKOWN_EN,
                    value: '**'
                });
        }
        else {
            if ((_c = this.config.unknownDateToggle) === null || _c === void 0 ? void 0 : _c.yearUnknown)
                (_d = this.dropDownConfigs.year.options) === null || _d === void 0 ? void 0 : _d.push({
                    text: DATE_PICKER_UNKOWN_FR,
                    value: '**'
                });
        }
        if (this.config.minYear || this.config.maxYear) {
            if (this.config.minYear && this.config.maxYear) {
                for (let i = this.config.minYear; i <= this.config.maxYear; i++) {
                    (_e = this.dropDownConfigs.year.options) === null || _e === void 0 ? void 0 : _e.push({ text: i.toString() });
                }
            }
            else if (this.config.minYear && !this.config.maxYear) {
                for (let i = this.config.minYear; i <= this.currentYear; i++) {
                    (_f = this.dropDownConfigs.year.options) === null || _f === void 0 ? void 0 : _f.push({ text: i.toString() });
                }
            }
            else if (this.config.maxYear && !this.config.minYear) {
                for (let i = 1900; i <= this.config.maxYear; i++) {
                    (_g = this.dropDownConfigs.year.options) === null || _g === void 0 ? void 0 : _g.push({ text: i.toString() });
                }
            }
        }
        else {
            for (let i = 1900; i <= this.currentYear; i++) {
                (_h = this.dropDownConfigs.year.options) === null || _h === void 0 ? void 0 : _h.push({ text: i.toString() });
            }
        }
        // Populate the days array based on the selected month and year
        (_j = this.config.formGroup
            .get(this.config.id + DATE_PICKER_MONTH_CONTROL_ID_EXTENSION)) === null || _j === void 0 ? void 0 : _j.valueChanges.subscribe((month) => {
            var _a;
            //add if statement here - the value of year can be empty, since it may not have been selected yet.
            const numDays = this.updateDaysArray(month, (_a = this.config.formGroup.get(this.config.id + '_yearControl')) === null || _a === void 0 ? void 0 : _a.value);
        });
        (_k = this.config.formGroup
            .get(this.config.id + DATE_PICKER_YEAR_CONTROL_ID_EXTENSION)) === null || _k === void 0 ? void 0 : _k.valueChanges.subscribe((year) => {
            var _a;
            const numDays = this.updateDaysArray((_a = this.config.formGroup.get(this.config.id + DATE_PICKER_MONTH_CONTROL_ID_EXTENSION)) === null || _a === void 0 ? void 0 : _a.value, year);
        });
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            if ((_l = this.config.unknownDateToggle) === null || _l === void 0 ? void 0 : _l.dayUnknown)
                (_m = this.dropDownConfigs.day.options) === null || _m === void 0 ? void 0 : _m.push({
                    text: DATE_PICKER_UNKOWN_EN,
                    value: '**'
                });
        }
        else {
            if ((_o = this.config.unknownDateToggle) === null || _o === void 0 ? void 0 : _o.dayUnknown)
                (_p = this.dropDownConfigs.day.options) === null || _p === void 0 ? void 0 : _p.push({
                    text: DATE_PICKER_UNKOWN_FR,
                    value: '**'
                });
        }
        if ((((_q = this.config.unknownDateToggle) === null || _q === void 0 ? void 0 : _q.dayUnknown) &&
            ((_r = this.dropDownConfigs.day.options) === null || _r === void 0 ? void 0 : _r.length) === 1) ||
            (!((_s = this.config.unknownDateToggle) === null || _s === void 0 ? void 0 : _s.dayUnknown) &&
                ((_t = this.dropDownConfigs.day.options) === null || _t === void 0 ? void 0 : _t.length) === 0)) {
            for (let i = 1; i <= 31; i++) {
                (_u = this.dropDownConfigs.day.options) === null || _u === void 0 ? void 0 : _u.push({ text: i.toString() });
            }
        }
    }
    ngOnChanges() {
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, [], this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        this.dropDownConfigs.day.size = this.config.size;
        this.dropDownConfigs.month.size = this.config.size;
        this.dropDownConfigs.year.size = this.config.size;
    }
    ngAfterViewInit() {
        this.yearSelect = document.getElementById(this.dropDownConfigs.year.id);
        this.monthSelect = document.getElementById(this.dropDownConfigs.month.id);
        this.daySelect = document.getElementById(this.dropDownConfigs.day.id);
        this.getAriaOverride();
    }
    /**
     * Set the language for dropdown options
     * TODO: Set value of each month to be the lov and not the text
     */
    setMonthsLanguage() {
        var _a, _b, _c, _d;
        this.dropDownConfigs.month.options = [];
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            this.months = DATE_PICKER_MONTHS_EN;
            if ((_a = this.config.unknownDateToggle) === null || _a === void 0 ? void 0 : _a.monthUnknown)
                (_b = this.dropDownConfigs.month.options) === null || _b === void 0 ? void 0 : _b.push({
                    text: DATE_PICKER_UNKOWN_EN,
                    value: '**'
                });
        }
        else {
            this.months = DATE_PICKER_MONTHS_FR;
            if ((_c = this.config.unknownDateToggle) === null || _c === void 0 ? void 0 : _c.monthUnknown)
                (_d = this.dropDownConfigs.month.options) === null || _d === void 0 ? void 0 : _d.push({
                    text: DATE_PICKER_UNKOWN_FR,
                    value: '**'
                });
        }
        this.months.forEach((month, index) => {
            var _a;
            (_a = this.dropDownConfigs.month.options) === null || _a === void 0 ? void 0 : _a.push({
                text: month,
                value: (index + 1).toString().padStart(2, '0')
            });
        });
    }
    /**
     * Used to set the language of year/day 'unknown' field when langauge changes
     */
    setYearDayLanguage() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        (_a = this.dropDownConfigs.day.options) === null || _a === void 0 ? void 0 : _a.shift();
        (_b = this.dropDownConfigs.year.options) === null || _b === void 0 ? void 0 : _b.shift();
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            this.months = DATE_PICKER_MONTHS_EN;
            if ((_c = this.config.unknownDateToggle) === null || _c === void 0 ? void 0 : _c.dayUnknown)
                (_d = this.dropDownConfigs.day.options) === null || _d === void 0 ? void 0 : _d.unshift({
                    text: DATE_PICKER_UNKOWN_EN,
                    value: '**'
                });
            if ((_e = this.config.unknownDateToggle) === null || _e === void 0 ? void 0 : _e.yearUnknown)
                (_f = this.dropDownConfigs.year.options) === null || _f === void 0 ? void 0 : _f.unshift({
                    text: DATE_PICKER_UNKOWN_EN,
                    value: '**'
                });
        }
        else {
            this.months = DATE_PICKER_MONTHS_FR;
            if ((_g = this.config.unknownDateToggle) === null || _g === void 0 ? void 0 : _g.dayUnknown)
                (_h = this.dropDownConfigs.day.options) === null || _h === void 0 ? void 0 : _h.unshift({
                    text: DATE_PICKER_UNKOWN_FR,
                    value: '**'
                });
            if ((_j = this.config.unknownDateToggle) === null || _j === void 0 ? void 0 : _j.yearUnknown)
                (_k = this.dropDownConfigs.year.options) === null || _k === void 0 ? void 0 : _k.unshift({
                    text: DATE_PICKER_UNKOWN_FR,
                    value: '**'
                });
        }
    }
    /**
     * Set the language for the labels of each dropdown
     */
    setLabelLanguage() {
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            this.dropDownConfigs.day.label = DATE_PICKER_LABELS_EN[0];
            this.dropDownConfigs.month.label = DATE_PICKER_LABELS_EN[1];
            this.dropDownConfigs.year.label = DATE_PICKER_LABELS_EN[2];
            this.dropDownConfigs.day.placeholder = DATE_PICKER_PLACEHOLDER_DAY_EN;
            this.dropDownConfigs.month.placeholder = DATE_PICKER_PLACEHOLDER_MONTH_EN;
            this.dropDownConfigs.year.placeholder = DATE_PICKER_PLACEHOLDER_YEAR_EN;
            this.errorStubText = ERROR_TEXT_STUB.en;
        }
        else {
            this.dropDownConfigs.day.label = DATE_PICKER_LABELS_FR[0];
            this.dropDownConfigs.month.label = DATE_PICKER_LABELS_FR[1];
            this.dropDownConfigs.year.label = DATE_PICKER_LABELS_FR[2];
            this.dropDownConfigs.day.placeholder = DATE_PICKER_PLACEHOLDER_DAY_FR;
            this.dropDownConfigs.month.placeholder = DATE_PICKER_PLACEHOLDER_MONTH_FR;
            this.dropDownConfigs.year.placeholder = DATE_PICKER_PLACEHOLDER_YEAR_FR;
            this.errorStubText = ERROR_TEXT_STUB.fr;
        }
    }
    /**
     * update the days array with the correct number of days based on the year and the month
     * @param month string of the month (TODO: Change this to be an LOV)
     * @param year year selected
     */
    updateDaysArray(month, year) {
        var _a, _b, _c, _d, _e;
        this.days = [];
        this.dropDownConfigs.day.options = [];
        const numDays = this.getNumDaysInMonth(month, year);
        for (let i = 1; i <= numDays; i++) {
            this.days.push(i);
        }
        (_a = this.config.formGroup
            .get(this.config.id + DATE_PICKER_DAY_CONTROL_ID_EXTENSION)) === null || _a === void 0 ? void 0 : _a.setValue('');
        if (this.translate.currentLang === 'en' ||
            this.translate.currentLang === 'en-US') {
            if ((_b = this.config.unknownDateToggle) === null || _b === void 0 ? void 0 : _b.dayUnknown)
                (_c = this.dropDownConfigs.day.options) === null || _c === void 0 ? void 0 : _c.push({
                    text: DATE_PICKER_UNKOWN_EN,
                    value: '**'
                });
        }
        else {
            if ((_d = this.config.unknownDateToggle) === null || _d === void 0 ? void 0 : _d.dayUnknown)
                (_e = this.dropDownConfigs.day.options) === null || _e === void 0 ? void 0 : _e.push({
                    text: DATE_PICKER_UNKOWN_FR,
                    value: '**'
                });
        }
        this.days.forEach((day) => {
            var _a;
            (_a = this.dropDownConfigs.day.options) === null || _a === void 0 ? void 0 : _a.push({ text: day.toString() });
        });
    }
    /**
     * Get the number of days in the month based on the month and year
     * @param month string of the month selected
     * @param year number selected
     * @returns number representing the number of days in the month
     */
    getNumDaysInMonth(month, year) {
        const monthNum = +month;
        if (monthNum === 2) {
            if (String(year) === '**') {
                //if year is unknown and month is feb return 29
                return 29;
            }
            return this.isLeapYear(year) ? 29 : 28;
        }
        else if ([4, 6, 9, 11].includes(monthNum)) {
            return 30;
        }
        else {
            return 31;
        }
    }
    /**
     * Check if the year is a leap year
     * @param year number representing the year
     * @returns true if a leap year, false otherwise
     */
    isLeapYear(year) {
        if (year % 4 === 0) {
            if (year % 100 === 0) {
                return year % 400 === 0;
            }
            return true;
        }
        return false;
    }
    getDatePickerTouchedOrInvalid() {
        var _a, _b, _c, _d, _e, _f;
        let datePickerState = false;
        datePickerState =
            (((_a = this.config.formGroup.get(this.dropDownConfigs.year.id)) === null || _a === void 0 ? void 0 : _a.touched) &&
                ((_b = this.config.formGroup.get(this.dropDownConfigs.year.id)) === null || _b === void 0 ? void 0 : _b.invalid)) ||
                (((_c = this.config.formGroup.get(this.dropDownConfigs.month.id)) === null || _c === void 0 ? void 0 : _c.touched) &&
                    ((_d = this.config.formGroup.get(this.dropDownConfigs.month.id)) === null || _d === void 0 ? void 0 : _d.invalid)) ||
                (((_e = this.config.formGroup.get(this.dropDownConfigs.day.id)) === null || _e === void 0 ? void 0 : _e.touched) &&
                    ((_f = this.config.formGroup.get(this.dropDownConfigs.day.id)) === null || _f === void 0 ? void 0 : _f.invalid));
        this.touched = datePickerState || false;
        this.getAriaOverride(datePickerState);
        return datePickerState !== null && datePickerState !== void 0 ? datePickerState : false;
        //  return this.config.formGroup?.touched && this.config.formGroup?.invalid;
    }
    /**
     * Override the aria labels for each of the select fields in the date picker
     * @param hasError is the field in error?
     */
    getAriaOverride(hasError) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (this.yearSelect !== '') {
            if (hasError &&
                ((_a = this.config.formGroup.get(this.dropDownConfigs.year.id)) === null || _a === void 0 ? void 0 : _a.touched) &&
                ((_b = this.config.formGroup.get(this.dropDownConfigs.year.id)) === null || _b === void 0 ? void 0 : _b.invalid)) {
                (_c = this.yearSelect) === null || _c === void 0 ? void 0 : _c.setAttribute('aria-label', this.getLabelCore() +
                    this.dropDownConfigs.year.label +
                    ' ' +
                    this.getErrorAria());
            }
            else {
                (_d = this.yearSelect) === null || _d === void 0 ? void 0 : _d.setAttribute('aria-label', this.getLabelCore() + this.dropDownConfigs.year.label);
            }
        }
        if (this.monthSelect !== '') {
            if (hasError &&
                ((_e = this.config.formGroup.get(this.dropDownConfigs.month.id)) === null || _e === void 0 ? void 0 : _e.touched) &&
                ((_f = this.config.formGroup.get(this.dropDownConfigs.month.id)) === null || _f === void 0 ? void 0 : _f.invalid)) {
                (_g = this.monthSelect) === null || _g === void 0 ? void 0 : _g.setAttribute('aria-label', this.getLabelCore() +
                    this.dropDownConfigs.month.label +
                    ' ' +
                    this.getErrorAria());
            }
            else {
                (_h = this.monthSelect) === null || _h === void 0 ? void 0 : _h.setAttribute('aria-label', this.getLabelCore() + this.dropDownConfigs.month.label);
            }
        }
        if (this.daySelect !== '') {
            if (hasError &&
                ((_j = this.config.formGroup.get(this.dropDownConfigs.day.id)) === null || _j === void 0 ? void 0 : _j.touched) &&
                ((_k = this.config.formGroup.get(this.dropDownConfigs.day.id)) === null || _k === void 0 ? void 0 : _k.invalid)) {
                (_l = this.daySelect) === null || _l === void 0 ? void 0 : _l.setAttribute('aria-label', this.getLabelCore() +
                    this.dropDownConfigs.day.label +
                    ' ' +
                    this.getErrorAria());
            }
            else {
                (_m = this.daySelect) === null || _m === void 0 ? void 0 : _m.setAttribute('aria-label', this.getLabelCore() + this.dropDownConfigs.day.label);
            }
        }
    }
    /**
     * Generates a core string of the label (date picker label, description, and hint) for aria text
     * @returns label core text translated string
     */
    getLabelCore() {
        let labelCore = '';
        if (this.config.label)
            labelCore += this.translate.instant(this.config.label) + ' ';
        if (this.config.desc)
            labelCore += this.translate.instant(this.config.desc) + ' ';
        if (this.config.hint)
            labelCore += this.translate.instant(this.config.hint) + ' ';
        return labelCore;
    }
    /**
     * Generates the translated error string for aria text
     * @returns errors text translated string
     */
    getErrorAria() {
        let errors = '';
        this.errorIds.forEach((error) => {
            errors += this.translate.instant(error.errorLOV) + ' ';
        });
        return errors;
    }
    changeValue(event) {
        this.writeValue(event.srcElement.value);
        this.onTouch();
    }
    writeValue(value) {
        this.onChange(value);
    }
    registerOnChange(fn) {
        this.config.formGroup.valueChanges.subscribe(fn);
    }
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    /**
     * Apply a disabled state
     */
    setDisabledState(isDisabled) {
        var _a, _b, _c, _d;
        if (isDisabled) {
            (_b = (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.disable();
        }
        else {
            (_d = (_c = this.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.enable();
        }
    }
}
DatePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DatePickerComponent, deps: [{ token: i1.TranslateService }, { token: StandAloneFunctions }], target: i0.ɵɵFactoryTarget.Component });
DatePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: DatePickerComponent, selector: "ircc-cl-lib-date-picker", inputs: { config: "config", formGroup: "formGroup", id: "id", size: "size", label: "label", required: "required", hint: "hint", desc: "desc", errorMessages: "errorMessages", maxYear: "maxYear", minYear: "minYear", unknownDateToggle: "unknownDateToggle", yearSelectShow: "yearSelectShow", monthSelectShow: "monthSelectShow", daySelectShow: "daySelectShow" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => DatePickerComponent),
            multi: true
        }
    ], usesOnChanges: true, ngImport: i0, template: "<div class=\"{{ config.size }}\">\n  <ircc-cl-lib-label\n    [config]=\"labelConfig\"\n    [attr.size]=\"config.size\"\n  ></ircc-cl-lib-label>\n  <fieldset class=\"all-select-container\">\n    <ircc-cl-lib-select\n      class=\"select-year\"\n      [attr.aria-live]=\"'off'\"\n      [config]=\"dropDownConfigs.year\"\n      *ngIf=\"config.yearSelectShow\"\n      (change)=\"changeValue($event)\"\n    ></ircc-cl-lib-select>\n    <ircc-cl-lib-select\n      class=\"select-month\"\n      [config]=\"dropDownConfigs.month\"\n      *ngIf=\"config.monthSelectShow\"\n      (change)=\"changeValue($event)\"\n    ></ircc-cl-lib-select>\n    <ircc-cl-lib-select\n      class=\"select-day\"\n      [config]=\"dropDownConfigs.day\"\n      *ngIf=\"config.daySelectShow\"\n      (change)=\"changeValue($event)\"\n    ></ircc-cl-lib-select>\n  </fieldset>\n  <div aria-live=\"polite\">\n    <ng-container *ngIf=\"getDatePickerTouchedOrInvalid()\">\n      <span class=\"sr-only\">{{\n        errorStubText + ': ' + (config.label || '' | translate) + ': '\n      }}</span>\n      <!-- TODO: Do something clever here to add which of the dropdowns are in error and put them in the above p tag -->\n      <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n        <div\n          *ngIf=\"config.formGroup.get(dropDownConfigs.year.id)?.errors?.[errors.key] || config.formGroup.get(dropDownConfigs.month.id)?.errors?.[errors.key] || config.formGroup.get(dropDownConfigs.day.id)?.errors?.[errors.key]\"\n          class=\"radio-errors\"\n        >\n          <ircc-cl-lib-error\n            [id]=\"errors.id\"\n            [errorLOV]=\"errors.errorLOV\"\n            [size]=\"config.size\"\n          ></ircc-cl-lib-error>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "component", type: SelectComponent, selector: "ircc-cl-lib-select", inputs: ["config", "id", "formGroup", "size", "label", "desc", "hint", "placeholder", "required", "options", "errorMessages", "disableError"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DatePickerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-date-picker', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => DatePickerComponent),
                            multi: true
                        }
                    ], template: "<div class=\"{{ config.size }}\">\n  <ircc-cl-lib-label\n    [config]=\"labelConfig\"\n    [attr.size]=\"config.size\"\n  ></ircc-cl-lib-label>\n  <fieldset class=\"all-select-container\">\n    <ircc-cl-lib-select\n      class=\"select-year\"\n      [attr.aria-live]=\"'off'\"\n      [config]=\"dropDownConfigs.year\"\n      *ngIf=\"config.yearSelectShow\"\n      (change)=\"changeValue($event)\"\n    ></ircc-cl-lib-select>\n    <ircc-cl-lib-select\n      class=\"select-month\"\n      [config]=\"dropDownConfigs.month\"\n      *ngIf=\"config.monthSelectShow\"\n      (change)=\"changeValue($event)\"\n    ></ircc-cl-lib-select>\n    <ircc-cl-lib-select\n      class=\"select-day\"\n      [config]=\"dropDownConfigs.day\"\n      *ngIf=\"config.daySelectShow\"\n      (change)=\"changeValue($event)\"\n    ></ircc-cl-lib-select>\n  </fieldset>\n  <div aria-live=\"polite\">\n    <ng-container *ngIf=\"getDatePickerTouchedOrInvalid()\">\n      <span class=\"sr-only\">{{\n        errorStubText + ': ' + (config.label || '' | translate) + ': '\n      }}</span>\n      <!-- TODO: Do something clever here to add which of the dropdowns are in error and put them in the above p tag -->\n      <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n        <div\n          *ngIf=\"config.formGroup.get(dropDownConfigs.year.id)?.errors?.[errors.key] || config.formGroup.get(dropDownConfigs.month.id)?.errors?.[errors.key] || config.formGroup.get(dropDownConfigs.day.id)?.errors?.[errors.key]\"\n          class=\"radio-errors\"\n        >\n          <ircc-cl-lib-error\n            [id]=\"errors.id\"\n            [errorLOV]=\"errors.errorLOV\"\n            [size]=\"config.size\"\n          ></ircc-cl-lib-error>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: StandAloneFunctions }]; }, propDecorators: { config: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], label: [{
                type: Input
            }], required: [{
                type: Input
            }], hint: [{
                type: Input
            }], desc: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], minYear: [{
                type: Input
            }], unknownDateToggle: [{
                type: Input
            }], yearSelectShow: [{
                type: Input
            }], monthSelectShow: [{
                type: Input
            }], daySelectShow: [{
                type: Input
            }] } });

const MAX_CHAR_LIMIT_EN = 'Maximum character limit reached.';
const MAX_CHAR_LIMIT_FR = 'Limite maximale de caractères atteinte.';
const WARNING_CHAR_LIMIT_EN = 'Maximum character limit reached in 15 characters.';
const WARNING_CHAR_LIMIT_FR = 'Limite maximale de caractères atteinte en 15 caractères.';
var ResizableTypes;
(function (ResizableTypes) {
    ResizableTypes["vertical"] = "vertical";
    ResizableTypes["horizontal"] = "password";
    ResizableTypes["both"] = "both";
    ResizableTypes["none"] = "none";
})(ResizableTypes || (ResizableTypes = {}));
class TextareaComponent {
    constructor(standAloneFunctions, translate) {
        this.standAloneFunctions = standAloneFunctions;
        this.translate = translate;
        this.formGroupEmpty = new FormGroup({});
        //DON'T include default values of '' unless it REALLY makes sense to do so. Instead, make them optional
        this.config = {
            id: '',
            formGroup: new FormGroup({})
        };
        this.id = '';
        this.formGroup = this.formGroupEmpty;
        this.charLimit = '';
        this.disabled = false;
        this.focusState = false;
        this.errorIds = [];
        this.charLimitStatus = '';
        this.currentCharacterStatusAria = '';
        this.currentStatus = 'VALID';
        this.announceCharStatusChangeAria = false;
        this.charLength = -1;
        this.labelConfig = {
            formGroup: this.config.formGroup,
            parentID: ''
        };
        this.isEventActive = false;
        this.announceMaxCharaterLimitReached = '';
        //Removed '!' and added null case in onChange
        this.onTouch = () => {
            var _a, _b, _c, _d;
            if (((_b = (_a = this.config.formGroup) === null || _a === void 0 ? void 0 : _a.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.touched) === false) {
                (_d = (_c = this.config.formGroup) === null || _c === void 0 ? void 0 : _c.get(this.config.id)) === null || _d === void 0 ? void 0 : _d.markAsTouched();
            }
        };
        this.onChange = (value) => {
            var _a;
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(value);
        };
    }
    ngOnInit() {
        var _a, _b;
        //set config from individual options, if present
        if (this.id !== '')
            this.config.id = this.id;
        if (this.formGroup !== this.formGroupEmpty)
            this.config.formGroup = this.formGroup;
        if (this.charLimit !== '')
            this.config.charLimit = this.charLimit;
        if (this.size)
            this.config.size = this.size;
        if (this.label)
            this.config.label = this.label;
        if (this.desc)
            this.config.desc = this.desc;
        if (this.hint)
            this.config.hint = this.hint;
        if (this.placeholder)
            this.config.placeholder = this.placeholder;
        if (this.required)
            this.config.required = this.required;
        if (this.resizable)
            this.config.resizable = this.resizable;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
        if (this.errorIcon)
            this.config.errorIcon = this.errorIcon;
        if (this.config.charLimit != '' && this.config.charLimit) {
            this.charLength = 0;
        }
        if (this.config.errorMessages) {
            this.errorIds = this.standAloneFunctions.getErrorIds(this.config.formGroup, this.config.id, this.config.errorMessages);
        }
        if (this.config.formGroup.controls[this.config.id].value) {
            this.charLength =
                this.config.formGroup.controls[this.config.id].value.length;
            this.characterCountStatus(this.config.formGroup.controls[this.config.id].value.length);
        }
        this.config.formGroup.valueChanges.subscribe((change) => {
            var _a;
            this.characterCountStatus((_a = change[this.config.id]) === null || _a === void 0 ? void 0 : _a.length);
        });
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
        this.currentStatus =
            ((_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.status) || 'DISABLED';
        this.toggleDisabledState();
        (_b = this.config.formGroup
            .get(this.config.id)) === null || _b === void 0 ? void 0 : _b.statusChanges.subscribe((change) => {
            if (change !== this.currentStatus) {
                this.currentStatus = change;
                this.toggleDisabledState();
            }
        });
        this.translate.currentLang === 'en' || this.translate.currentLang === 'en-US'
            ? (this.announceMaxCharaterLimitReached = MAX_CHAR_LIMIT_EN)
            : (this.announceMaxCharaterLimitReached = MAX_CHAR_LIMIT_FR);
    }
    toggleDisabledState() {
        switch (this.currentStatus) {
            case 'DISABLED':
                this.setDisabledState(true);
                break;
            default:
                this.setDisabledState(false);
                break;
        }
    }
    ngOnChanges() {
        this.labelConfig = this.standAloneFunctions.makeLabelConfig(this.config.formGroup, this.config.id, this.config.errorMessages, this.config.label, this.config.desc, this.config.hint, this.config.required, this.config.labelIconConfig);
    }
    focusInput(focusValue) {
        this.focusState = !focusValue;
    }
    characterCountStatus(currCharCount) {
        var _a, _b, _c, _d;
        let currLang = this.translate.currentLang;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.charLimit) {
            if (((_b = this.config) === null || _b === void 0 ? void 0 : _b.charLimit) == currCharCount) {
                this.charLimitStatus = 'maxLimit';
                currLang === 'en' || currLang === 'en-US'
                    ? (this.currentCharacterStatusAria = MAX_CHAR_LIMIT_EN)
                    : (this.currentCharacterStatusAria = MAX_CHAR_LIMIT_FR);
                this.announceCharStatusChangeAria = true;
                this.isEventActive = true;
            }
            else if (Number((_c = this.config) === null || _c === void 0 ? void 0 : _c.charLimit) - currCharCount == 15) {
                this.charLimitStatus = 'warningLimit';
                currLang === 'en' || currLang === 'en-US'
                    ? (this.currentCharacterStatusAria = WARNING_CHAR_LIMIT_EN)
                    : (this.currentCharacterStatusAria = WARNING_CHAR_LIMIT_FR);
                this.announceCharStatusChangeAria = true;
                this.isEventActive = false;
            }
            else if (Number((_d = this.config) === null || _d === void 0 ? void 0 : _d.charLimit) - currCharCount < 15) {
                this.charLimitStatus = 'warningLimit';
                this.currentCharacterStatusAria = '';
                this.isEventActive = false;
            }
            else {
                this.charLimitStatus = '';
                this.currentCharacterStatusAria = '';
                this.isEventActive = false;
            }
        }
    }
    onBlur() {
        this.announceCharStatusChangeAria = false;
        if (this.config.formGroup.controls[this.config.id].value) {
            this.charLength =
                this.config.formGroup.controls[this.config.id].value.length;
        }
        else {
            this.charLength = 0;
        }
    }
    //Keep announcing max char limit reached for each keypress made after max limit has reached
    onKeyPress(event) {
        if (this.isEventActive) {
            if (this.announceMaxCharaterLimitReached === MAX_CHAR_LIMIT_EN || this.announceMaxCharaterLimitReached === MAX_CHAR_LIMIT_FR) {
                this.announceMaxCharaterLimitReached += '&nbsp;';
            }
            else {
                this.translate.currentLang === 'en' || this.translate.currentLang === 'en-US'
                    ? (this.announceMaxCharaterLimitReached = MAX_CHAR_LIMIT_EN)
                    : (this.announceMaxCharaterLimitReached = MAX_CHAR_LIMIT_FR);
            }
        }
        if (this.charLimitStatus !== 'maxLimit') {
            this.isEventActive = false;
        }
    }
    formatCharacterUsedString(currentLength) {
        var formatedString = '';
        var currentLengthString = currentLength.toString();
        if (currentLengthString === '-1' ||
            this.config.charLimit === '' ||
            !this.config.charLimit) {
            return formatedString;
        }
        formatedString = currentLengthString + '/' + this.config.charLimit;
        return formatedString;
    }
    clearvalue() { }
    changeValue(event) {
        this.writeValue(event.target.value);
        this.onTouch();
    }
    writeValue(value) {
        this.onChange(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    setDisabledState(isDisabled) {
        var _a, _b;
        isDisabled
            ? (_a = this.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.disable()
            : (_b = this.formGroup.get(this.config.id)) === null || _b === void 0 ? void 0 : _b.enable();
    }
}
TextareaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: TextareaComponent, deps: [{ token: StandAloneFunctions }, { token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
TextareaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: TextareaComponent, selector: "ircc-cl-lib-textarea", inputs: { config: "config", id: "id", formGroup: "formGroup", size: "size", label: "label", desc: "desc", hint: "hint", placeholder: "placeholder", required: "required", charLimit: "charLimit", resizable: "resizable", errorMessages: "errorMessages", errorIcon: "errorIcon" }, host: { listeners: { "window:keypress": "onKeyPress($event)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => TextareaComponent),
            multi: true
        }
    ], usesOnChanges: true, ngImport: i0, template: "<div>\n  <form [formGroup]=\"config.formGroup\">\n    <div\n      class=\"textarea-container\"\n      ngClass=\"{{ config.size }} resize-{{ config.resizable }}\"\n    >\n      <div>\n        <ircc-cl-lib-label\n          [config]=\"labelConfig\"\n          [attr.size]=\"config.size\"\n        ></ircc-cl-lib-label>\n        <div\n          class=\"content-area\"\n          [ngClass]=\"focusState === true ? 'focus' : ''\"\n        >\n          <textarea\n            class=\"textarea-field\"\n            maxlength=\"{{ config.charLimit }}\"\n            placeholder=\"{{\n              announceCharStatusChangeAria\n                ? ''\n                : (config.placeholder || '' | translate)\n            }}\"\n            [id]=\"config.id\"\n            tabindex=\"0\"\n            (blur)=\"onBlur()\"\n            (change)=\"changeValue($event)\"\n            [formControlName]=\"config.id\"\n            [attr.aria-label]=\"\n              announceCharStatusChangeAria\n                ? currentCharacterStatusAria\n                : (config.label || '' | translate) +\n                  ' ' +\n                  (config.desc || '' | translate) +\n                  ' ' +\n                  (config.hint || '' | translate) +\n                  ' ' +\n                  (config.placeholder || '' | translate) +\n                  ' ' +\n                  formatCharacterUsedString(charLength)\n            \"\n            #textareaInput\n          >\n          </textarea>\n          <p\n            *ngIf=\"config.charLimit\"\n            class=\"character-count\"\n            [ngClass]=\"charLimitStatus\"\n          >\n            {{ textareaInput.value.length }}/{{ config.charLimit }}\n          </p>\n          <span\n            class=\"sr-only\"\n            aria-live=\"polite\"\n            [innerHTML]=\"announceMaxCharaterLimitReached\"\n          >\n          </span>\n        </div>\n      </div>\n\n      <div\n        *ngIf=\"\n          config.formGroup.get(config.id)?.touched &&\n          config.formGroup.get(config.id)?.invalid\n        \"\n        class=\"check-error\"\n      >\n        <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n          <div\n            *ngIf=\"config.formGroup.get(config.id)?.errors?.[errors.key]\"\n            class=\"radio-errors\"\n          >\n            <ircc-cl-lib-error\n              [size]=\"config.size\"\n              [id]=\"errors.id\"\n              [errorLOV]=\"errors.errorLOV\"\n            ></ircc-cl-lib-error>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </form>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "directive", type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i5.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i5.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { kind: "directive", type: i5.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i5.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: TextareaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-textarea', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => TextareaComponent),
                            multi: true
                        }
                    ], template: "<div>\n  <form [formGroup]=\"config.formGroup\">\n    <div\n      class=\"textarea-container\"\n      ngClass=\"{{ config.size }} resize-{{ config.resizable }}\"\n    >\n      <div>\n        <ircc-cl-lib-label\n          [config]=\"labelConfig\"\n          [attr.size]=\"config.size\"\n        ></ircc-cl-lib-label>\n        <div\n          class=\"content-area\"\n          [ngClass]=\"focusState === true ? 'focus' : ''\"\n        >\n          <textarea\n            class=\"textarea-field\"\n            maxlength=\"{{ config.charLimit }}\"\n            placeholder=\"{{\n              announceCharStatusChangeAria\n                ? ''\n                : (config.placeholder || '' | translate)\n            }}\"\n            [id]=\"config.id\"\n            tabindex=\"0\"\n            (blur)=\"onBlur()\"\n            (change)=\"changeValue($event)\"\n            [formControlName]=\"config.id\"\n            [attr.aria-label]=\"\n              announceCharStatusChangeAria\n                ? currentCharacterStatusAria\n                : (config.label || '' | translate) +\n                  ' ' +\n                  (config.desc || '' | translate) +\n                  ' ' +\n                  (config.hint || '' | translate) +\n                  ' ' +\n                  (config.placeholder || '' | translate) +\n                  ' ' +\n                  formatCharacterUsedString(charLength)\n            \"\n            #textareaInput\n          >\n          </textarea>\n          <p\n            *ngIf=\"config.charLimit\"\n            class=\"character-count\"\n            [ngClass]=\"charLimitStatus\"\n          >\n            {{ textareaInput.value.length }}/{{ config.charLimit }}\n          </p>\n          <span\n            class=\"sr-only\"\n            aria-live=\"polite\"\n            [innerHTML]=\"announceMaxCharaterLimitReached\"\n          >\n          </span>\n        </div>\n      </div>\n\n      <div\n        *ngIf=\"\n          config.formGroup.get(config.id)?.touched &&\n          config.formGroup.get(config.id)?.invalid\n        \"\n        class=\"check-error\"\n      >\n        <ng-container *ngFor=\"let errors of errorIds; let i = index\">\n          <div\n            *ngIf=\"config.formGroup.get(config.id)?.errors?.[errors.key]\"\n            class=\"radio-errors\"\n          >\n            <ircc-cl-lib-error\n              [size]=\"config.size\"\n              [id]=\"errors.id\"\n              [errorLOV]=\"errors.errorLOV\"\n            ></ircc-cl-lib-error>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </form>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: StandAloneFunctions }, { type: i1.TranslateService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], formGroup: [{
                type: Input
            }], size: [{
                type: Input
            }], label: [{
                type: Input
            }], desc: [{
                type: Input
            }], hint: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], required: [{
                type: Input
            }], charLimit: [{
                type: Input
            }], resizable: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }], errorIcon: [{
                type: Input
            }], onKeyPress: [{
                type: HostListener,
                args: ['window:keypress', ['$event']]
            }] } });

class MultiCheckboxComponent {
    constructor(multiCheckboxService, standAloneFunctions) {
        this.multiCheckboxService = multiCheckboxService;
        this.standAloneFunctions = standAloneFunctions;
        this.form = new FormGroup({});
        this.errorIds = [];
        this.config = {
            id: '',
            label: {
                parentID: '',
                formGroup: this.form
            },
            errorMessages: []
        };
        this.id = '';
        /**
         * Accumulates all the errors on parents and children checkboxes
         * @type IErrorPairsMultiCheckBox[]
         */
        this.errorMessagesAccumulator = [];
        /**
         * Accumulates unique error types and used in the frontend to display
         * @type IErrorPairsMultiCheckBox[]
         */
        this.errorMessagesAccumulatorUniqueType = [];
        this.disabledStatus = false;
        this.groupCheckbox = true;
        if (this.id !== '')
            this.config.id = this.id;
        if (this.parent)
            this.config.parent = this.parent;
        if (this.children)
            this.config.children = this.children;
        if (this.errorMessages)
            this.config.errorMessages = this.errorMessages;
    }
    // returns size depending on if its group or multicheckbox
    get size() {
        var _a, _b, _c;
        if (this.groupCheckbox && this.config.children) {
            return ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.children[0]) === null || _b === void 0 ? void 0 : _b.size) || 'large';
        }
        return ((_c = this.config.parent) === null || _c === void 0 ? void 0 : _c.size) || 'large';
    }
    ngOnInit() {
        //errorChecking
        this.checkErrorsSubscription();
        this.errorSub = this.multiCheckboxService.multiCheckboxErrorObs$.subscribe((response) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
            if (this.config.children) {
                let children = (_a = this.config.children) === null || _a === void 0 ? void 0 : _a.findIndex((child) => {
                    return child.id === response;
                });
                if (children > -1) {
                    this.checkError((_e = (_d = (_c = (_b = this.config) === null || _b === void 0 ? void 0 : _b.children[children]) === null || _c === void 0 ? void 0 : _c.formGroup) === null || _d === void 0 ? void 0 : _d.get(response)) === null || _e === void 0 ? void 0 : _e.status, ((_g = (_f = this.config) === null || _f === void 0 ? void 0 : _f.children[children]) === null || _g === void 0 ? void 0 : _g.formGroup) || new FormGroup({}), response);
                }
            }
            if (((_j = (_h = this.config) === null || _h === void 0 ? void 0 : _h.parent) === null || _j === void 0 ? void 0 : _j.id) === response) {
                this.checkError((_o = (_m = (_l = (_k = this.config) === null || _k === void 0 ? void 0 : _k.parent) === null || _l === void 0 ? void 0 : _l.formGroup) === null || _m === void 0 ? void 0 : _m.get(response)) === null || _o === void 0 ? void 0 : _o.status, ((_q = (_p = this.config) === null || _p === void 0 ? void 0 : _p.parent) === null || _q === void 0 ? void 0 : _q.formGroup) || new FormGroup({}), response);
            }
        });
        if (this.config.parent !== undefined) {
            this.groupCheckbox = false;
            this.configSub =
                this.multiCheckboxService.multiCheckboxEventObs$.subscribe((response) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
                    if (this.config.children) {
                        if (response.id === ((_a = this.config.parent) === null || _a === void 0 ? void 0 : _a.id)) {
                            (_b = this.config.children) === null || _b === void 0 ? void 0 : _b.forEach((res) => {
                                this.multiCheckboxService.checkEvent({
                                    id: res.id,
                                    event: response.event
                                });
                            });
                            this.config.parent.mixed = false;
                            this.checkError((_g = (_e = (_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.formGroup) === null || _e === void 0 ? void 0 : _e.get((_f = this.config.parent) === null || _f === void 0 ? void 0 : _f.id)) === null || _g === void 0 ? void 0 : _g.status, ((_j = (_h = this.config) === null || _h === void 0 ? void 0 : _h.parent) === null || _j === void 0 ? void 0 : _j.formGroup) || new FormGroup({}), (_k = this.config.parent) === null || _k === void 0 ? void 0 : _k.id);
                            (_l = this.config.children) === null || _l === void 0 ? void 0 : _l.forEach((res) => {
                                var _a, _b, _c, _d, _e, _f;
                                this.checkError((_d = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.formGroup) === null || _c === void 0 ? void 0 : _c.get(res.id)) === null || _d === void 0 ? void 0 : _d.status, ((_f = (_e = this.config) === null || _e === void 0 ? void 0 : _e.parent) === null || _f === void 0 ? void 0 : _f.formGroup) || new FormGroup({}), res.id);
                            });
                        }
                        else if (((_m = this.config.children) === null || _m === void 0 ? void 0 : _m.findIndex((child) => {
                            return child.id === response.id;
                        })) > -1) {
                            let positive = 0;
                            let negative = 0;
                            (_o = this.config.children) === null || _o === void 0 ? void 0 : _o.forEach((res) => {
                                var _a;
                                ((_a = res.formGroup.get(res.id)) === null || _a === void 0 ? void 0 : _a.value) === true
                                    ? positive++
                                    : negative++;
                            });
                            if (positive > 0 && negative > 0) {
                                (_r = (_p = this.config.parent) === null || _p === void 0 ? void 0 : _p.formGroup.get((_q = this.config.parent) === null || _q === void 0 ? void 0 : _q.id)) === null || _r === void 0 ? void 0 : _r.patchValue(true, { emitEvent: false });
                                this.config.parent.mixed = true;
                            }
                            else if (positive > 0 && negative == 0) {
                                (_u = (_s = this.config.parent) === null || _s === void 0 ? void 0 : _s.formGroup.get((_t = this.config.parent) === null || _t === void 0 ? void 0 : _t.id)) === null || _u === void 0 ? void 0 : _u.patchValue(true, { emitEvent: false });
                                this.config.parent.mixed = false;
                            }
                            else if (positive == 0 && negative > 0) {
                                (_x = (_v = this.config.parent) === null || _v === void 0 ? void 0 : _v.formGroup.get((_w = this.config.parent) === null || _w === void 0 ? void 0 : _w.id)) === null || _x === void 0 ? void 0 : _x.patchValue(false, { emitEvent: false });
                                this.config.parent.mixed = false;
                            }
                            this.checkError((_2 = (_0 = (_z = (_y = this.config) === null || _y === void 0 ? void 0 : _y.parent) === null || _z === void 0 ? void 0 : _z.formGroup) === null || _0 === void 0 ? void 0 : _0.get((_1 = this.config.parent) === null || _1 === void 0 ? void 0 : _1.id)) === null || _2 === void 0 ? void 0 : _2.status, ((_3 = this.config.parent) === null || _3 === void 0 ? void 0 : _3.formGroup) || new FormGroup({}), ((_4 = this.config.parent) === null || _4 === void 0 ? void 0 : _4.id) || '');
                            (_5 = this.config.children) === null || _5 === void 0 ? void 0 : _5.forEach((res) => {
                                var _a, _b, _c, _d, _e, _f;
                                this.checkError((_d = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.formGroup) === null || _c === void 0 ? void 0 : _c.get(res.id)) === null || _d === void 0 ? void 0 : _d.status, ((_f = (_e = this.config) === null || _e === void 0 ? void 0 : _e.parent) === null || _f === void 0 ? void 0 : _f.formGroup) || new FormGroup({}), res.id);
                            });
                        }
                    }
                });
        }
    }
    checkErrorsSubscription() {
        var _a, _b, _c;
        (_a = this.config.children) === null || _a === void 0 ? void 0 : _a.forEach((res) => {
            var _a, _b;
            (_b = (_a = res.formGroup) === null || _a === void 0 ? void 0 : _a.get(res.id)) === null || _b === void 0 ? void 0 : _b.statusChanges.subscribe((value) => {
                this.checkError(value, res.formGroup, res.id);
                value === 'DISABLED'
                    ? (this.disabledStatus = true)
                    : (this.disabledStatus = false);
            });
        });
        if (this.config.parent !== undefined) {
            (_c = (_b = this.config.parent.formGroup) === null || _b === void 0 ? void 0 : _b.get(this.config.parent.id)) === null || _c === void 0 ? void 0 : _c.statusChanges.subscribe((value) => {
                var _a, _b, _c, _d, _e;
                this.checkError(value, ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.formGroup) || new FormGroup({}), ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.id) || '');
                value === 'DISABLED'
                    ? (this.disabledStatus = true)
                    : (this.disabledStatus = false);
                (_e = this.config.children) === null || _e === void 0 ? void 0 : _e.forEach((res) => {
                    var _a, _b;
                    (_b = (_a = res.formGroup) === null || _a === void 0 ? void 0 : _a.get(res.id)) === null || _b === void 0 ? void 0 : _b.statusChanges.subscribe((value) => {
                        this.checkError(value, res.formGroup, res.id);
                        value === 'DISABLED'
                            ? (this.disabledStatus = true)
                            : (this.disabledStatus = false);
                    });
                });
            });
        }
    }
    /**
     * Will check the status of a formcontrol.  If the control is not in a valid status, it will loop through the errors
     * and add them to this.errorMessages.
     * @param value Status of the formcontrol
     * @param group - Formgroup to be checked
     * @param id - ID of the control that is being checked for error in the formgroup
     */
    checkError(value, group, id) {
        var _a, _b, _c;
        if (value !== 'VALID') {
            for (const error in (_a = group.get(id)) === null || _a === void 0 ? void 0 : _a.errors) {
                let errorIndex = (_b = this.config.errorMessages) === null || _b === void 0 ? void 0 : _b.findIndex((errorPair) => {
                    return errorPair.key === error;
                });
                let errorMessagesKeys = (_c = this.errorMessagesAccumulator) === null || _c === void 0 ? void 0 : _c.findIndex((errorPair) => {
                    return errorPair.key === error && id === errorPair.id;
                });
                if (errorIndex > -1 && errorMessagesKeys === -1) {
                    this.errorMessagesAccumulator.push({
                        id: id,
                        key: this.config.errorMessages[errorIndex].key,
                        errorLOV: this.config.errorMessages[errorIndex].errorLOV
                    });
                }
                this.filterErrorList();
            }
        }
        else {
            this.errorMessagesAccumulator = this.errorMessagesAccumulator.filter((errorPair) => {
                var _a;
                return ((_a = (errorPair.id)) === null || _a === void 0 ? void 0 : _a.replace('_error0', '')) !== id;
            });
            this.filterErrorList();
        }
    }
    /**
     * Will loop through the errors in the variable errorMessages.
     * It will then add a copy in errorMessagesAccumulator for each unique error type.
     * THe first error in errorMessagesAccumulator will get _error0 appended to it's ID to display the icon
     */
    filterErrorList() {
        this.errorMessagesAccumulatorUniqueType = [];
        this.errorMessagesAccumulator.forEach((error) => {
            let errorIndex = this.errorMessagesAccumulatorUniqueType.findIndex((errorPair) => {
                return errorPair.key === error.key;
            });
            if (errorIndex === -1) {
                this.errorMessagesAccumulatorUniqueType.push(error);
            }
        });
        if (this.errorMessagesAccumulatorUniqueType[0]) {
            if (this.errorMessagesAccumulatorUniqueType[0].id && !this.errorMessagesAccumulatorUniqueType[0].id.endsWith("_error0")) {
                this.errorMessagesAccumulatorUniqueType[0].id = this.errorMessagesAccumulatorUniqueType[0].id + "_error0";
            }
        }
    }
    isValid(checkbox) {
        return typeof checkbox !== 'undefined';
    }
    removeResponseFromError(response) {
        this.config.errorMessages = this.config.errorMessages.filter((item) => {
            (item === null || item === void 0 ? void 0 : item.key) !== response.id;
        });
    }
}
MultiCheckboxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: MultiCheckboxComponent, deps: [{ token: MultiCheckboxService }, { token: StandAloneFunctions }], target: i0.ɵɵFactoryTarget.Component });
MultiCheckboxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: MultiCheckboxComponent, selector: "ircc-cl-lib-multi-checkbox", inputs: { config: "config", id: "id", parent: "parent", children: "children", errorMessages: "errorMessages" }, ngImport: i0, template: "<fieldset>\n  <legend class=\"visually-hidden\">\n    {{ config.label.label || '' | translate }}\n  </legend>\n  <ng-container *ngIf=\"config.label\">\n    <ircc-cl-lib-label\n      [config]=\"config.label\"\n      [legend]=\"true\"\n      [attr.size]=\"size\"\n    ></ircc-cl-lib-label>\n  </ng-container>\n  <div class=\"parent-checkbox\">\n    <ng-container *ngIf=\"config.parent; else group\">\n      <ircc-cl-lib-checkbox [config]=\"config.parent\"></ircc-cl-lib-checkbox>\n      <ng-container *ngFor=\"let child of config.children\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            recursiveListTmpl;\n            context: { checkBoxConfig: child }\n          \"\n        ></ng-container>\n      </ng-container>\n    </ng-container>\n  </div>\n\n  <ng-template #group>\n    <ng-container *ngFor=\"let child of config.children\">\n      <ircc-cl-lib-checkbox [config]=\"child\"></ircc-cl-lib-checkbox>\n    </ng-container>\n  </ng-template>\n\n  <ng-template\n    #recursiveListTmpl\n    let-checkBoxConfig=\"checkBoxConfig\"\n  >\n    <div class=\"child-checkbox\">\n      <ircc-cl-lib-checkbox [config]=\"checkBoxConfig\"></ircc-cl-lib-checkbox>\n    </div>\n  </ng-template>\n  <ng-container\n    *ngFor=\"let errors of errorMessagesAccumulatorUniqueType; let i = index\"\n  >\n    <div\n      *ngIf=\"errorMessagesAccumulatorUniqueType.length > -1 && !disabledStatus\"\n      class=\"radio-errors\"\n    >\n      <ircc-cl-lib-error\n        [id]=\"errors.id\"\n        [errorLOV]=\"errors.errorLOV\"\n        [attr.size]=\"size\"\n      ></ircc-cl-lib-error>\n    </div>\n  </ng-container>\n</fieldset>\n", styles: [".parent-checkbox{min-height:55px;margin-right:32px}.child-checkbox{margin-left:20px}.visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}fieldset{border:none}\n"], dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: LabelComponent, selector: "ircc-cl-lib-label", inputs: ["config", "formGroup", "errorMessages", "parentID", "label", "desc", "hint", "required", "iconButton", "topLabel", "touched", "legend"] }, { kind: "component", type: CheckboxComponent, selector: "ircc-cl-lib-checkbox", inputs: ["config", "formGroup", "id", "label", "required", "size", "mixed", "inlineLabel", "inlineLabelBold", "hint", "desc", "errorMessages"] }, { kind: "component", type: ErrorComponent, selector: "ircc-cl-lib-error", inputs: ["config", "id", "errorLOV", "icon", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: MultiCheckboxComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-multi-checkbox', template: "<fieldset>\n  <legend class=\"visually-hidden\">\n    {{ config.label.label || '' | translate }}\n  </legend>\n  <ng-container *ngIf=\"config.label\">\n    <ircc-cl-lib-label\n      [config]=\"config.label\"\n      [legend]=\"true\"\n      [attr.size]=\"size\"\n    ></ircc-cl-lib-label>\n  </ng-container>\n  <div class=\"parent-checkbox\">\n    <ng-container *ngIf=\"config.parent; else group\">\n      <ircc-cl-lib-checkbox [config]=\"config.parent\"></ircc-cl-lib-checkbox>\n      <ng-container *ngFor=\"let child of config.children\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            recursiveListTmpl;\n            context: { checkBoxConfig: child }\n          \"\n        ></ng-container>\n      </ng-container>\n    </ng-container>\n  </div>\n\n  <ng-template #group>\n    <ng-container *ngFor=\"let child of config.children\">\n      <ircc-cl-lib-checkbox [config]=\"child\"></ircc-cl-lib-checkbox>\n    </ng-container>\n  </ng-template>\n\n  <ng-template\n    #recursiveListTmpl\n    let-checkBoxConfig=\"checkBoxConfig\"\n  >\n    <div class=\"child-checkbox\">\n      <ircc-cl-lib-checkbox [config]=\"checkBoxConfig\"></ircc-cl-lib-checkbox>\n    </div>\n  </ng-template>\n  <ng-container\n    *ngFor=\"let errors of errorMessagesAccumulatorUniqueType; let i = index\"\n  >\n    <div\n      *ngIf=\"errorMessagesAccumulatorUniqueType.length > -1 && !disabledStatus\"\n      class=\"radio-errors\"\n    >\n      <ircc-cl-lib-error\n        [id]=\"errors.id\"\n        [errorLOV]=\"errors.errorLOV\"\n        [attr.size]=\"size\"\n      ></ircc-cl-lib-error>\n    </div>\n  </ng-container>\n</fieldset>\n", styles: [".parent-checkbox{min-height:55px;margin-right:32px}.child-checkbox{margin-left:20px}.visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}fieldset{border:none}\n"] }]
        }], ctorParameters: function () { return [{ type: MultiCheckboxService }, { type: StandAloneFunctions }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], parent: [{
                type: Input
            }], children: [{
                type: Input
            }], errorMessages: [{
                type: Input
            }] } });

var matchType;
(function (matchType) {
    matchType["infix"] = "infix";
    matchType["prefix"] = "prefix";
})(matchType || (matchType = {}));
class AutoCompleteComponent {
    constructor(domSanitizer, changeDetectorRef) {
        this.domSanitizer = domSanitizer;
        this.changeDetectorRef = changeDetectorRef;
        this.formGroupEmpty = new FormGroup({});
        this.config = {
            id: 'auto-complete',
            formGroup: this.formGroupEmpty,
            label: 'label',
            hint: 'hint',
            desc: 'desc',
            size: 'small',
            suggestions: []
        };
        this.matchType = 'infix';
        this.showSuggestions = false;
        this.formGroup = this.formGroupEmpty;
        this.inputComponent = Object.assign(Object.assign({}, this.config), { type: 'autocomplete' });
        this.flyout = {
            id: 'string',
            options: [],
            type: 'autocomplete',
            size: this.config.size
        };
    }
    ngOnChanges(changes) {
        this.inputComponent = Object.assign(Object.assign({}, this.config), { type: 'autocomplete' });
        this.flyout.size = this.config.size;
    }
    ngAfterContentChecked() {
        this.changeDetectorRef.detectChanges();
    }
    ngOnInit() {
        var _a;
        if (this.formGroup !== this.formGroupEmpty) {
            this.config.formGroup = this.formGroup;
        }
        this.inputComponent.id = this.config.id;
        this.inputComponent.formGroup = this.config.formGroup;
        this.inputComponent.label = this.config.label;
        this.inputComponent.hint = this.config.hint;
        this.inputComponent.desc = this.config.desc;
        this.inputComponent.size = this.config.size;
        this.inputComponent.errorMessages = this.config.errorMessages;
        this.inputComponent.placeholder = this.config.placeholder;
        this.flyout.id = `${this.config.id}-flyout`;
        this.flyout.options = this.config.suggestions.map((suggestion) => {
            return {
                value: suggestion,
                clickable: true
            };
        });
        (_a = this.config.formGroup
            .get(this.config.id)) === null || _a === void 0 ? void 0 : _a.valueChanges.subscribe((data) => {
            if (data === null || data.length === 0) {
                this.flyout.selected = '';
                this.flyout.options = [];
                this.flyout.options = this.config.suggestions.map((suggestion) => {
                    return {
                        value: suggestion,
                        clickable: true
                    };
                });
            }
            else {
                this.validateInternal(data);
            }
        });
        this.inputComponent = Object.assign(Object.assign({}, this.config), { type: 'autocomplete' });
    }
    spreadFlyoutOption(value) {
        return {
            value: value,
            clickable: true
        };
    }
    onFocus(event) {
        let timeoutTime = 0;
        if (event === false) {
            timeoutTime = 500;
        }
        setTimeout(() => {
            this.showSuggestions = event;
        }, timeoutTime);
        // Set 1st option as active when on focus
        if (this.flyout.options.length > 0) {
            this.flyout.options[0].active = true;
        }
    }
    isSelected(event) {
        var _a;
        if (event !== null) {
            const tempDivElement = document.createElement('div');
            tempDivElement.innerHTML = event || '';
            const convertedString = tempDivElement.textContent || tempDivElement.innerText || '';
            (_a = this.config.formGroup.get(this.config.id)) === null || _a === void 0 ? void 0 : _a.setValue(convertedString);
            this.showSuggestions = false;
        }
    }
    validateInternal(data) {
        this.flyout.options = [];
        let eventString = this.domSanitizer.sanitize(SecurityContext.HTML, data.replace(/<[^>]*>/g, ''));
        let re;
        if (this.matchType === 'infix') {
            const infixMatching = new RegExp(`${data}`);
            re = new RegExp(`${infixMatching.source}`, 'i');
        }
        else {
            const paragraphStart = new RegExp(`^${data}`);
            const whitespaceStart = new RegExp(`\\s+\\b${data}[a-zA-Z]*`);
            re = new RegExp(`${paragraphStart.source}|${whitespaceStart.source}`, 'i');
        }
        this.flyout.selected = data;
        this.flyout.options = this.config.suggestions
            .filter((suggestion) => suggestion.search(re) >= 0)
            .map((suggestion) => {
            return {
                value: suggestion,
                clickable: true
            };
        });
        if (this.flyout.options.length === 0) {
            this.flyout.options = [
                {
                    value: 'No options found',
                    clickable: false
                }
            ];
        }
    }
}
AutoCompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AutoCompleteComponent, deps: [{ token: i1$1.DomSanitizer }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
AutoCompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: AutoCompleteComponent, selector: "ircc-cl-lib-autocomplete", inputs: { config: "config", formGroup: "formGroup" }, viewQueries: [{ propertyName: "inputAutocomplete", first: true, predicate: ["inputAutocomplete"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div\n  #inputAutocomplete\n  [attr.size]=\"config.size\"\n>\n  <ircc-cl-lib-input\n    [attr.size]=\"config.size\"\n    [config]=\"inputComponent\"\n    type=\"autocomplete\"\n    (focusEvent)=\"onFocus($event)\"\n  ></ircc-cl-lib-input>\n\n  <ng-container *ngIf=\"showSuggestions === true\">\n    <ircc-cl-lib-flyout\n      (isSelected)=\"isSelected($event)\"\n      [config]=\"flyout\"\n      [class]=\"config.size\"\n    ></ircc-cl-lib-flyout>\n  </ng-container>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: FlyoutComponent, selector: "ircc-cl-lib-flyout", inputs: ["config", "id", "options", "disabled", "selection", "type", "size"], outputs: ["isSelected"] }, { kind: "component", type: InputComponent, selector: "ircc-cl-lib-input", inputs: ["config", "id", "formGroup", "type", "size", "label", "hint", "desc", "required", "placeholder", "errorMessages"], outputs: ["focusEvent"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AutoCompleteComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-autocomplete', template: "<div\n  #inputAutocomplete\n  [attr.size]=\"config.size\"\n>\n  <ircc-cl-lib-input\n    [attr.size]=\"config.size\"\n    [config]=\"inputComponent\"\n    type=\"autocomplete\"\n    (focusEvent)=\"onFocus($event)\"\n  ></ircc-cl-lib-input>\n\n  <ng-container *ngIf=\"showSuggestions === true\">\n    <ircc-cl-lib-flyout\n      (isSelected)=\"isSelected($event)\"\n      [config]=\"flyout\"\n      [class]=\"config.size\"\n    ></ircc-cl-lib-flyout>\n  </ng-container>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.DomSanitizer }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { inputAutocomplete: [{
                type: ViewChild,
                args: ['inputAutocomplete', { static: false }]
            }], config: [{
                type: Input
            }], formGroup: [{
                type: Input
            }] } });

const IrccDsAngularFormComponents = [
    CheckboxComponent,
    ErrorComponent,
    InputComponent,
    RadioInputComponent,
    DatePickerComponent,
    TextareaComponent,
    SelectComponent,
    MultiCheckboxComponent,
    AutoCompleteComponent
];
class IrccDsAngularFormComponentsModule {
}
IrccDsAngularFormComponentsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularFormComponentsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularFormComponentsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularFormComponentsModule, declarations: [CheckboxComponent,
        ErrorComponent,
        InputComponent,
        RadioInputComponent,
        DatePickerComponent,
        TextareaComponent,
        SelectComponent,
        MultiCheckboxComponent,
        AutoCompleteComponent], imports: [CommonModule,
        IrccDsAngularComponentsSharedModule,
        TranslateModule,
        FormsModule,
        ReactiveFormsModule,
        ScrollingModule,
        ScrollingModule$1,
        IrccDsAngularPipesdModule], exports: [CheckboxComponent,
        ErrorComponent,
        InputComponent,
        RadioInputComponent,
        DatePickerComponent,
        TextareaComponent,
        SelectComponent,
        MultiCheckboxComponent,
        AutoCompleteComponent] });
IrccDsAngularFormComponentsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularFormComponentsModule, imports: [CommonModule,
        IrccDsAngularComponentsSharedModule,
        TranslateModule,
        FormsModule,
        ReactiveFormsModule,
        ScrollingModule,
        ScrollingModule$1,
        IrccDsAngularPipesdModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularFormComponentsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...IrccDsAngularFormComponents],
                    imports: [
                        CommonModule,
                        IrccDsAngularComponentsSharedModule,
                        TranslateModule,
                        FormsModule,
                        ReactiveFormsModule,
                        ScrollingModule,
                        ScrollingModule$1,
                        IrccDsAngularPipesdModule
                    ],
                    exports: [...IrccDsAngularFormComponents]
                }]
        }] });

const GOV_CANADA_LOGOS = {
    headerLightLogo: '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',
    headerLightLogoFrench: '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',
    headerDarkLogo: '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',
    headerDarkLogoFrench: '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',
    footerLightLogo: 'iVBORw0KGgoAAAANSUhEUgAAAGUAAAAZCAYAAAAonOB1AAAACXBIWXMAABCcAAAQnAEmzTo0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAVJSURBVHgB5ZqPNTtBEMc3ngLoQAeoABWgAlGBdCAqCBWgAlSAClABKkAF99vPyjcmY/fu8gfv/fJ9716Su92Z2Znd+XfpVBGhAXd3d+Hm5ia8vLyEx8fHdG9lZSWsra2Fvb29sLW1lb7z/P7+PhwcHIT/HWdnZ0kXrBnwiU4eHh5CeH8PYX//a3C3G0JJJ7mxVQ3Oz8+rqGyMVm1vb1e3t7fV29tbevb8/Dz2PBqn2tjYSJ+LAnSg9esaPmCnf139/tekqMOx35mxocQMI4jRYDCoFQxjaCzfFwmnp6ftjcKGjkZM9zBOYew3o8TjV8VjOGJyfHzcKBinRzuGz0UCm7KVUaLxomK/jMLm7XazY5ese8Mv7uzsRDf3nn4TL/r9fmgCvvTq6mroIt/DIoFY2gq7uygKJX/+Jjavr2eHjhnFGgTEUxLaIrqtGKO6C2eU1sB46JNAHjd7GAxC6PXyY3UMCdrBHMNpYgOJAHM50ouEMEmgB4onhbHLMs7JycmYsdj1kyImB8mVLTzQgdWfd1NRT3VjOxiLOgTXZRF3fVLypICWn6f6BteG0bja0Ga86gDcowAtrra0REc1FnGAeZZmG0CDi/k2lnQ6ndH3qlD2SeZW/DFKr9cbO4JcqkdmAZmc0mVSbFwk6bUytXgav7k6fnPf5v9kg8gTk450n+fUQzbj63sXMQQpq7JJMklkYL7mXVxc1K5BfKHBJd6sR/IH774K/BkP/6Ojo3SvJHeiYmsSKWFW2DRZShVYiARljN8AvvbROJ+eM8+OQwEWNk6iEAu7EUsGjRnlSE4M4eWMnYux8sEbxRoMHVso/uaeZY0yj1rDMvUKAdqtOWX6+TnBc+O83JbHrQ2u1adB6zxDHV2LbEU/hN0UuTXauVa+HzMKi4QuOzmXjbE764zmlcYCSygpl4XCnx2dg1UKrrb0rI63XUfupMAfPeR0UNqYy+GHQCAjWZhlvkXbIk3JBCABSA3ClvOEGGdGCQa06jJRmrElIPM0/Jc0+behTKQt5i2jMqkc6IgLTRnaLHKRqeawnGOMsHbHzQvQRZDLy8uJjTJPGVA6p4H15ToQ1lhNSp/UKOJfMghIJyX3/mMWpR0eHqZPFsx7B2qg1dXVsLm5mYSiT9YrtRjmDPhRGEsGPglDuNbSpptnqwhalj86iHEvxDhVrK/SSVEBZq3Hy6ppi0e5BgTRrmNHoYjfdJWcSIwvJcf6IDVYmzwAnkNyz2IgrwMavBijif+oIclgi5gNhGmAIjh57I6/NAi8rUEI1qypjUu2cta5GVBnNDyG1QEeog3/JSvIgM6lYYbrmQSKGf7UoZzfTiYUF4VJOt67tNmHgEadYbybt/HIzvObXrRzGGvdozwrPEe9lKHkwM5gvjfAeua9QVPM8gJP6kY+Pj5G332vSvRKa2NTWdfN6S/h6elp7LelaU9FblMWdZsriGhnBFNItukPUQjZNogtqnwbw7/bzr0m8BV9SQaKPjtORRgy2RaIr9j9qwpP38voOwLi4St6u1ZaM6X5vmdmC+jiHydYrGVIVYrg3EcYiMJITUL/Hl+GCsPeF30k0YUWBswtWouy1a4Ml2te5npkGgdNGcbOV6VPY9DS17pkWL5LsdCxhlPfLdc3VHfAvybXffGX7jQPfsxJrftQA9UVyqosyFLwv7i9UgDT35NwVxxhXBlBl/GKQSrWoEeSwL3X19csPTIo8aLWKIFMRzyur69HPLhHFS4ZtD79RQj5/Hp8baVXBsiCm1OqLzfJxTpU/8GfbLakAz2XDhqNYoEflm//iy7AouAffZcxXLnrBUYAAAAASUVORK5CYII=',
    footerDarkLogo: 'iVBORw0KGgoAAAANSUhEUgAAAGUAAAAZCAYAAAAonOB1AAAACXBIWXMAABCcAAAQnAEmzTo0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAVdSURBVHgB7VrNdeM4DIbz8ua62vMclse5RakgSgXjrWCVCsapwE4FY1dgpQJnKpC3AnsqsPYyV6sDLBCBEUSRkuw4M++N871HiyIIggT4A0IewQAgYkKPmNIVJUMpolRSKij9S+lpNBqVVI9pCeUz+M1BY03pcQOVLiJbTmO/xer960vl2QxgOvU39OMHwMePuuQb9AmmlGMFfo5F8UyLKU0o7SQtKW0oPcGZgHVBaY8Kz+U0cZHJNs1mdYU8r973wrbbYaMumbBLWK5kzXo6tlF1N3BGkIk5zChsCGOqsjwPGuXCI4S3qZxSIkUPtCRnoU4RraDHLVRbGSOC88KwnWGxALi+rt/v7wHu7rxVG0aRrWkF1bnB2HYZxILPE3pYCWdlFJmU/bi5qZ6FVN9u6YS+8la9dN55hRj1fg/DO7cmoz5S9h94RxsxbUBf6ex/JBWVZWWkyaQ2kg9yqONrzgb20oTXwBlh8JmiD3sLz5miV4rrsz3CgZDVUsI7WAdZkPrpU53/8MGlbkf8i9U9JHeIt6xkOBDU1pj4npwyPmdiVVRSne3A9gw/9d4tZeaQtsSB0efdVs7CwZBxRCKzVOVo81Q+CvAaaB4N3f0mhjm28eoDG6u7jF2rG3EfeS3vsPLvl+5Wx3KxvvPYO8BeaFPhXUm7ls5lk0Afvqh6c9mmM9WntGcMkZK7F7m58HLbRivNwz/G+sqQO/K5zWlIcI5N7OEEEKEogzGqXA+E60QOn3v3sfXmPfUmDl2fk0uHNg/xqToJ1gbd6H6K7Aw9l0enjsXGoY0VLfcJz9FRALwSWB/6jKcemZMe/tagAvV2Di1TtMShRYq2x/bEiHW76Nk5pI2d7qRDT3vGuAv1762Mwh3eiGDjoc+UvGWAXyPtkKOhZ7PdOvIA707xxR20FMLjnHUYxa7kTUAHmc9ol/BGkIPwGo6EBDh1UTGwng2WgjgcQ2Nx2pgpNB2JrINvDW3P1fatgOE6eJFvb/T/wc/H1YH1CzghsO0NaXxW+T7ProDjceMrvAgINngC78uFbDVj2U4S+AWQLYW3Cg4nhVxiPfYCunGoW83yU9GBV8fWKJmHFsORQOXmYeUGr+ScYq+OZyGHbxbwE4C1S8t9YPnsMLAyOIgaUqiBgei764h81kGu5BtKf0Pg28mlbZgY1tCcvZxfw4HAyotgj4gjAjwbrXELStf2wsQrBt4YIoOdCDsjeSLMrCKxfa2w4D4ayf8Jx8s30Iwnrind2YtwSL6OErvBx2MDi8zHBuHVog1yO/QWfwrI9stf/6xBMpI/GXiL12fs1QA5IfCEMJIv+KvkkKjyi1FEYQ+KZjBwqerooIF6hSWKtBgc4j4deEIY9f4Aw6E9NoPuHaIJo18c1zdRed/Hkz88Zc3vKfLtRAcip3hYxJdnps8AvhXyF3TgBI6G5i/dPkn7xscoMb+1KvoMYSTOu9FyVb6ANoynDC48HUqhnlXc8bxnprzEqyj7nfjnUqyN617MDDQH43Mq3LIE/LJD9dZQKyXyGNk904zzzjO7kPzEI8fiS0A+YxtqX3Sg2+ycpJYpdW61S3FnY6FH4t5N5cbqxp3sjZ6xd/hyrAOTFonQJ/JcYhOtW7G0tXLq7bD+c4cOc6xUeSLt6fhXbpWl+mBUH/mZOrKX2I7R7ZUcl9+Wx0r+XvNxu6MhxoFq+SbQ9qsLqFZEFjozhJ95eSbwzP1u60snx1BvD89/V4L2eaAxV95TCmHovz2xku3fo7YiJxN6KvKN9O+bpUFbB0a18VyXb/tYxeVi0YdNC+VpWv5I6WDu6d8zrdcoGlh/T2CUh36PeMcw/A8RhuRsl5R/lwAAAABJRU5ErkJggg=='
};

/**
 * Language Switch Button renamed and refactored to include Header and Footer Dark Mode support based on user system preferences
 */
class LanguageHeaderFooterSwitchService {
    constructor() {
        this.languageClickSub = new BehaviorSubject(false);
        this.languageClickObs$ = this.languageClickSub.asObservable();
        this.isDarkModeSubject = new BehaviorSubject(false);
        this.isDarkMode$ = this.isDarkModeSubject.asObservable();
        this.updateDarkModePreference();
    }
    /**
   * We check system preference for preferred color scheme in the constructor before components are rendered in the DOM and subscribe to changes in the header and footer components
   */
    updateDarkModePreference() {
        const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
        const darkModeListener = (event) => {
            this.isDarkModeSubject.next(event.matches);
        };
        darkModeQuery.addEventListener('change', darkModeListener);
        this.isDarkModeSubject.next(darkModeQuery.matches);
    }
    languageToggleClick() {
        this.languageClickSub.next(true);
    }
}
LanguageHeaderFooterSwitchService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LanguageHeaderFooterSwitchService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LanguageHeaderFooterSwitchService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LanguageHeaderFooterSwitchService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LanguageHeaderFooterSwitchService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

const LANGUAGE_SWITCH_TEXT_ENGLISH = 'Français';
const LANGUAGE_SWITCH_TEXT_ENGLISH_MOBILE = '<abbr title="Français">FR</abbr>';
const LANGUAGE_SWITCH_TEXT_FRENCH = 'English';
const LANGUAGE_SWITCH_TEXT_FRENCH_MOBILE = '<abbr title="English">EN</abbr>';
class LanguageSwitchComponent {
    constructor(platformId, langToggle, translate, router, titleService) {
        this.platformId = platformId;
        this.langToggle = langToggle;
        this.translate = translate;
        this.router = router;
        this.titleService = titleService;
        this.id = '';
        this.isMobile = false;
        this.text = '';
        this.aria = '';
        this.isMobile = window.innerWidth <= 360; //phone breakpoint
    }
    /** Listens for screen resizes and sets mobile boolean */
    handleResize(e) {
        if (isPlatformBrowser(this.platformId)) {
            this.isMobile = window.innerWidth <= 768; //tablet breakpoint
            this.setText(this.translate.currentLang);
        }
    }
    ngOnInit() {
        let lang = this.translate.currentLang;
        this.setText(lang);
        this.translate.onLangChange.subscribe((newLang) => {
            console.log(newLang.lang, 'switch');
            this.setText(newLang.lang);
        });
    }
    switch() {
        this.langToggle.languageToggleClick();
        this.titleService.updateTitle(this.router.routerState.snapshot);
    }
    setText(lang) {
        if (lang === 'en' || lang === 'en-US') {
            this.isMobile
                ? (this.text = LANGUAGE_SWITCH_TEXT_ENGLISH_MOBILE)
                : (this.text = LANGUAGE_SWITCH_TEXT_ENGLISH);
        }
        else {
            this.isMobile
                ? (this.text = LANGUAGE_SWITCH_TEXT_FRENCH_MOBILE)
                : (this.text = LANGUAGE_SWITCH_TEXT_FRENCH);
        }
    }
}
LanguageSwitchComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LanguageSwitchComponent, deps: [{ token: PLATFORM_ID }, { token: LanguageHeaderFooterSwitchService }, { token: i1.TranslateService }, { token: i3.Router }, { token: i3.TitleStrategy }], target: i0.ɵɵFactoryTarget.Component });
LanguageSwitchComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: LanguageSwitchComponent, selector: "ircc-cl-lib-language-switch", inputs: { id: "id" }, host: { listeners: { "window:resize": "handleResize($event)" } }, ngImport: i0, template: "<a\n  [id]=\"id\"\n  (click)=\"switch()\"\n  id=\"language-toggle\"\n  [innerHTML]=\"text\"\n  tabindex=\"0\"\n></a>\n", preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: LanguageSwitchComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-language-switch', template: "<a\n  [id]=\"id\"\n  (click)=\"switch()\"\n  id=\"language-toggle\"\n  [innerHTML]=\"text\"\n  tabindex=\"0\"\n></a>\n" }]
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }, { type: LanguageHeaderFooterSwitchService }, { type: i1.TranslateService }, { type: i3.Router }, { type: i3.TitleStrategy }];
    }, propDecorators: { id: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize', ['$event']]
            }] } });

// import { ThemeSwitchService } from './theme-switch.service';
class ThemeSwitchComponent {
    constructor(renderer) {
        this.renderer = renderer;
        this.isDarkTheme = false;
        this.currentTheme = '';
        this.previousTheme = '';
    }
    ngOnInit() {
        this.darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
        this.isDarkTheme = this.darkModeQuery.matches;
        this.isDarkTheme ? this.currentTheme = 'dark' : this.currentTheme = 'light';
        this.currentTheme === 'dark' ? this.previousTheme = 'Light' : this.previousTheme = 'Dark';
        this.darkModeQuery.addEventListener('change', this.handleDarkModeChange.bind(this));
    }
    toggleTheme() {
        this.isDarkTheme = !this.isDarkTheme;
        this.isDarkTheme ? this.currentTheme = 'dark' : this.currentTheme = 'light';
        this.currentTheme === 'dark' ? this.previousTheme = 'Light' : this.previousTheme = 'Dark';
        this.renderer.setAttribute(document.documentElement, 'scheme', this.currentTheme);
        this.darkModeQuery.removeEventListener('change', this.handleDarkModeChange.bind(this));
    }
    handleDarkModeChange(event) {
        this.isDarkTheme = event.matches;
        this.isDarkTheme ? this.currentTheme = 'dark' : this.currentTheme = 'light';
        this.currentTheme === 'dark' ? this.previousTheme = 'Light' : this.previousTheme = 'Dark';
    }
}
ThemeSwitchComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ThemeSwitchComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
ThemeSwitchComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ThemeSwitchComponent, selector: "ircc-cl-lib-theme-switch", ngImport: i0, template: "<button\n  (click)=\"toggleTheme()\"\n  category=\"secondary\"\n  color=\"critical\"\n>\n  {{ this.previousTheme }}\n</button>\n", preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ThemeSwitchComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-theme-switch', template: "<button\n  (click)=\"toggleTheme()\"\n  category=\"secondary\"\n  color=\"critical\"\n>\n  {{ this.previousTheme }}\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; } });

const HEADER_IMG_LINK_EN = 'https://www.canada.ca/en.html';
const HEADER_IMG_LINK_FR = 'https://www.canada.ca/fr.html';
const CANADA_LOGO_ARIA_LABEL_ENGLISH = 'Symbol of the Government of Canada';
const CANADA_LOGO_ARIA_LABEL_FRENCH = 'Symbole du gouvernement du Canada';
class HeaderComponent {
    constructor(translate, languageHeaderFooterSwitch) {
        this.translate = translate;
        this.languageHeaderFooterSwitch = languageHeaderFooterSwitch;
        /**
         * This is the ID of the header component. Will be applied as the ID of the header Element within the custom element.
         *
         * All IDs must be unique and can be used to specifically target an element within your project.
         */
        this.id = '';
        this.themeToggle = false;
        this.alt = '';
        this.govCanadaLink = '';
        this.logo = '';
        this.isDarkMode = false;
        this.subscription = this.languageHeaderFooterSwitch.isDarkMode$.subscribe((response) => {
            this.updateHeaderImage(response);
            this.isDarkMode = response;
        });
    }
    /**
     * ngOnInit() lifecycle method run immediately when the component is initialized. c
     *
     * For Header Component the ngOnInit() checks for current url Language and subscribes to changes. Appropriate translations will be pulled as a result and content will be displayed in the users selected language.
     * When language changes update the Header and Footer images to display logos based on language and preferred color scheme based on the dark mode subscription in the constructor
     */
    ngOnInit() {
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
            this.updateHeaderImage(this.isDarkMode);
        });
    }
    updateHeaderImage(res) {
        const locale = this.translate.currentLang;
        if (locale === 'en' || locale === 'en-US') {
            this.logo = res
                ? GOV_CANADA_LOGOS.headerDarkLogo
                : GOV_CANADA_LOGOS.headerLightLogo;
        }
        else {
            this.logo = res
                ? GOV_CANADA_LOGOS.headerDarkLogoFrench
                : GOV_CANADA_LOGOS.headerLightLogoFrench;
        }
    }
    /**
     * setLang(lang: string) if a function which accepts a string value.
     * This value currently needs to be 'en' or 'en-US' to trigger English translations otherwise
     * french translations will be triggered.
     */
    setLang(lang) {
        if (lang === 'en' || lang === 'en-US') {
            this.alt = CANADA_LOGO_ARIA_LABEL_ENGLISH;
            this.govCanadaLink = HEADER_IMG_LINK_EN;
        }
        else {
            this.alt = CANADA_LOGO_ARIA_LABEL_FRENCH;
            this.govCanadaLink = HEADER_IMG_LINK_FR;
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
HeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: HeaderComponent, deps: [{ token: i1.TranslateService }, { token: LanguageHeaderFooterSwitchService }], target: i0.ɵɵFactoryTarget.Component });
HeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: HeaderComponent, selector: "ircc-cl-lib-header", inputs: { id: "id", themeToggle: "themeToggle" }, ngImport: i0, template: "<header\n  class=\"heading\"\n  role=\"banner\"\n  [id]=\"id\"\n>\n  <div class=\"header-content\">\n    <div class=\"image-container\">\n      <a\n        href=\"{{ govCanadaLink }}\"\n        id=\"canada-home-img-link\"\n        target=\"_blank\"\n        property=\"url\"\n        role=\"link\"\n        tabindex=\"0\"\n      >\n        <img\n          [src]=\"'data:image/png;base64,' + logo\"\n          alt=\"{{ alt }}\"\n          property=\"logo\"\n        />\n      </a>\n    </div>\n\n    <div class=\"languageSwitch\">\n      <ircc-cl-lib-language-switch\n        [id]=\"id + '_langToggle'\"\n      ></ircc-cl-lib-language-switch>\n      <ircc-cl-lib-theme-switch *ngIf=\"themeToggle\"></ircc-cl-lib-theme-switch>\n    </div>\n  </div>\n  <hr class=\"headerLine\" />\n\n  <ng-content select=\"[headerContent]\"></ng-content>\n</header>\n", dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LanguageSwitchComponent, selector: "ircc-cl-lib-language-switch", inputs: ["id"] }, { kind: "component", type: ThemeSwitchComponent, selector: "ircc-cl-lib-theme-switch" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: HeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-header', template: "<header\n  class=\"heading\"\n  role=\"banner\"\n  [id]=\"id\"\n>\n  <div class=\"header-content\">\n    <div class=\"image-container\">\n      <a\n        href=\"{{ govCanadaLink }}\"\n        id=\"canada-home-img-link\"\n        target=\"_blank\"\n        property=\"url\"\n        role=\"link\"\n        tabindex=\"0\"\n      >\n        <img\n          [src]=\"'data:image/png;base64,' + logo\"\n          alt=\"{{ alt }}\"\n          property=\"logo\"\n        />\n      </a>\n    </div>\n\n    <div class=\"languageSwitch\">\n      <ircc-cl-lib-language-switch\n        [id]=\"id + '_langToggle'\"\n      ></ircc-cl-lib-language-switch>\n      <ircc-cl-lib-theme-switch *ngIf=\"themeToggle\"></ircc-cl-lib-theme-switch>\n    </div>\n  </div>\n  <hr class=\"headerLine\" />\n\n  <ng-content select=\"[headerContent]\"></ng-content>\n</header>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: LanguageHeaderFooterSwitchService }]; }, propDecorators: { id: [{
                type: Input
            }], themeToggle: [{
                type: Input
            }] } });

const GOV_LOGO_ALT_TEXT_EN = 'Canada wordmark';
const GOV_LOGO_ALT_TEXT_FR = 'FR Canada wordmark';
class FooterComponent {
    constructor(translate, languageHeaderFooterSwitch) {
        this.translate = translate;
        this.languageHeaderFooterSwitch = languageHeaderFooterSwitch;
        this.id = '';
        this.altImage = '';
        this.logo = GOV_CANADA_LOGOS.footerLightLogo;
        this.isDarkMode = false;
        this.subscription = this.languageHeaderFooterSwitch.isDarkMode$.subscribe((response) => {
            this.updateFooterImage(response);
            this.isDarkMode = response;
        });
    }
    ngOnInit() {
        this.setLang(this.translate.currentLang);
        this.translate.onLangChange.subscribe((change) => {
            this.setLang(change.lang);
            this.updateFooterImage(this.isDarkMode);
        });
    }
    updateFooterImage(res) {
        this.logo = res
            ? GOV_CANADA_LOGOS.footerDarkLogo
            : GOV_CANADA_LOGOS.footerLightLogo;
    }
    setLang(lang) {
        if (lang === 'en' || lang === 'en-US') {
            this.altImage = GOV_LOGO_ALT_TEXT_EN;
        }
        else {
            this.altImage = GOV_LOGO_ALT_TEXT_FR;
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
FooterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: FooterComponent, deps: [{ token: i1.TranslateService }, { token: LanguageHeaderFooterSwitchService }], target: i0.ɵɵFactoryTarget.Component });
FooterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: FooterComponent, selector: "ircc-cl-lib-footer", inputs: { id: "id" }, ngImport: i0, template: "<footer\n  class=\"ircc-cl-lib-footer footing\"\n  role=\"contentinfo\"\n>\n  <div\n    class=\"grid-container\"\n    [id]=\"id\"\n  >\n    <div class=\"item1 body3\">\n      <ng-content></ng-content>\n    </div>\n    <picture class=\"item2\">\n      <img\n        [src]=\"'data:image/png;base64,' + logo\"\n        alt=\"{{ altImage }}\"\n      />\n    </picture>\n  </div>\n</footer>\n", preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: FooterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-footer', template: "<footer\n  class=\"ircc-cl-lib-footer footing\"\n  role=\"contentinfo\"\n>\n  <div\n    class=\"grid-container\"\n    [id]=\"id\"\n  >\n    <div class=\"item1 body3\">\n      <ng-content></ng-content>\n    </div>\n    <picture class=\"item2\">\n      <img\n        [src]=\"'data:image/png;base64,' + logo\"\n        alt=\"{{ altImage }}\"\n      />\n    </picture>\n  </div>\n</footer>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: LanguageHeaderFooterSwitchService }]; }, propDecorators: { id: [{
                type: Input
            }] } });

class HiddenNavComponent {
    constructor() {
        this.config = {
            id: ''
        };
    }
    scrollToAnchor(id) {
        if (id) {
            const el = document.getElementById(id);
            el === null || el === void 0 ? void 0 : el.scrollIntoView();
            el === null || el === void 0 ? void 0 : el.setAttribute('tabindex', '-1');
            el === null || el === void 0 ? void 0 : el.focus();
        }
    }
    handleKeyDown(key, link) {
        key === 'Tab' ? this.showNav() : null;
        key === 'Enter' && link ? this.scrollToAnchor(link) : null;
    }
    showNav() {
        const container = document.getElementById('hidden-nav-container');
        const btns = document.getElementsByClassName('hidden-btns');
        container === null || container === void 0 ? void 0 : container.classList.add('active-nav');
    }
}
HiddenNavComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: HiddenNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
HiddenNavComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: HiddenNavComponent, selector: "ircc-cl-lib-hidden-nav", inputs: { config: "config" }, host: { listeners: { "keydown": "handleKeyDown($event.key)" } }, ngImport: i0, template: "<div id=\"hidden-nav-container\">\n  <ng-container *ngFor=\"let link of config?.skipLinks; let i = index\">\n    <button\n      class=\"hidden-btns\"\n      role=\"link\"\n      (click)=\"scrollToAnchor(link.href)\"\n      (keydown)=\"handleKeyDown($event.key, link.href)\"\n      [tabindex]=\"i + 1\"\n      [attr.aria-label]=\"link.ariaLabel\"\n    >\n      {{ link.title }}\n    </button>\n  </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: HiddenNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-hidden-nav', template: "<div id=\"hidden-nav-container\">\n  <ng-container *ngFor=\"let link of config?.skipLinks; let i = index\">\n    <button\n      class=\"hidden-btns\"\n      role=\"link\"\n      (click)=\"scrollToAnchor(link.href)\"\n      (keydown)=\"handleKeyDown($event.key, link.href)\"\n      [tabindex]=\"i + 1\"\n      [attr.aria-label]=\"link.ariaLabel\"\n    >\n      {{ link.title }}\n    </button>\n  </ng-container>\n</div>\n" }]
        }], propDecorators: { config: [{
                type: Input
            }], handleKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event.key']]
            }] } });

const IrccDsHeaderFooterComponents = [
    HeaderComponent,
    FooterComponent,
    LanguageSwitchComponent,
    HiddenNavComponent,
    ThemeSwitchComponent
];
class IrccDsAngularHeaderFooterModule {
}
IrccDsAngularHeaderFooterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularHeaderFooterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularHeaderFooterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularHeaderFooterModule, declarations: [HeaderComponent,
        FooterComponent,
        LanguageSwitchComponent,
        HiddenNavComponent,
        ThemeSwitchComponent], imports: [CommonModule,
        IrccDsAngularComponentsSharedModule,
        TranslateModule,
        FormsModule,
        ReactiveFormsModule], exports: [HeaderComponent,
        FooterComponent,
        LanguageSwitchComponent,
        HiddenNavComponent,
        ThemeSwitchComponent] });
IrccDsAngularHeaderFooterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularHeaderFooterModule, imports: [CommonModule,
        IrccDsAngularComponentsSharedModule,
        TranslateModule,
        FormsModule,
        ReactiveFormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularHeaderFooterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...IrccDsHeaderFooterComponents],
                    imports: [
                        CommonModule,
                        IrccDsAngularComponentsSharedModule,
                        TranslateModule,
                        FormsModule,
                        ReactiveFormsModule
                    ],
                    exports: [...IrccDsHeaderFooterComponents]
                }]
        }] });

class ChipItemComponent {
    constructor() {
        this.iconClickEvent = new EventEmitter();
    }
    onIconClick() {
        this.iconClickEvent.emit();
    }
    onEnterKeyPress() {
        this.iconClickEvent.emit();
    }
}
ChipItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ChipItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ChipItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ChipItemComponent, selector: "lib-chip-item", inputs: { chipContent: "chipContent" }, outputs: { iconClickEvent: "iconClickEvent" }, ngImport: i0, template: "<div\n  class=\"chip-item\"\n  tabindex=\"0\"\n  (keydown.enter)=\"onEnterKeyPress()\"\n>\n  <span class=\"chip-text\">{{ chipContent || '' }}</span>\n  <span\n    class=\"icon-container\"\n    (click)=\"onIconClick()\"\n  >\n    <i class=\"fa-solid fa-circle-xmark clickable-icon\"></i>\n  </span>\n</div>\n", preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ChipItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-chip-item', template: "<div\n  class=\"chip-item\"\n  tabindex=\"0\"\n  (keydown.enter)=\"onEnterKeyPress()\"\n>\n  <span class=\"chip-text\">{{ chipContent || '' }}</span>\n  <span\n    class=\"icon-container\"\n    (click)=\"onIconClick()\"\n  >\n    <i class=\"fa-solid fa-circle-xmark clickable-icon\"></i>\n  </span>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { chipContent: [{
                type: Input
            }], iconClickEvent: [{
                type: Output
            }] } });

/**
 * TODO: This particular component, while functional, is not ideal. Components should not import other components directly in the .ts
 * unless absolutely necessary. Furthermore, the use of DoCheck, while interesting, is not ideal, since it ignores the built-in
 * angular lifecycle hooks and change detection.
 */
class AutocompleteComponent {
    constructor(differs) {
        this.differs = differs;
        //TODO: Change this to a config
        this.options = [];
        this.title = `Title`;
        this.hintText = `Hint Text`;
        this.name = `Add Name`;
        this.error = false;
        this.limit = 0;
        this.selectValueChange = new EventEmitter();
        this.savedSelectedOptions = [];
        this.selectedOptions = [];
        this.originalOptions = [];
        this.hideDropdown = true;
        this.isFocusInsideComponent = false;
        this.isComponentClicked = false;
        this.addHover = false;
        this.emptyResults = false;
        this.differ = this.differs.find({}).create();
    }
    handleKeyDown(event) {
        var _a;
        event.stopPropagation();
        if (this.hideDropdown === false || this.options.length > 0) {
            (_a = this.inputComponent) === null || _a === void 0 ? void 0 : _a.clearvalue();
            this.returnOptionsToDefault();
            this.isComponentClicked = false;
            this.isFocusInsideComponent = false;
            this.hideDropdown = true;
        }
    }
    clickInside(event) {
        const target = event.target;
        if (this.hideDropdown === true &&
            target.type === `text` &&
            this.options.length > 0) {
            this.isFocusInsideComponent = true;
            this.isComponentClicked = true;
            this.toggleDropDown();
            this.addHover = true;
        }
        else if (target.classList.contains('select-target') ||
            target.classList.contains(`selected`)) {
            this.isComponentClicked = false;
            this.isFocusInsideComponent = false;
            this.toggleDropDown();
        }
    }
    clickout() {
        var _a;
        if (!this.isFocusInsideComponent && this.isComponentClicked) {
            this.toggleDropDown();
            (_a = this.inputComponent) === null || _a === void 0 ? void 0 : _a.clearvalue();
            this.returnOptionsToDefault();
            this.isComponentClicked = false;
        }
        this.isFocusInsideComponent = false;
    }
    onMouseEnter() {
        this.addHover = false;
    }
    ngDoCheck() {
        const change = this.differ.diff(this);
        if (change) {
            change.forEachChangedItem((item) => {
                if (item.key === `options`) {
                    this.selectValueChange.emit(this.selectedOptions);
                }
            });
        }
    }
    valueChange(event) {
        this.filterList(event);
    }
    filterList(filterValue) {
        if (filterValue.length < 1) {
            this.returnOptionsToDefault();
        }
        else {
            const filteredOptions = this.originalOptions.filter((value) => {
                return value.text.toLowerCase().includes(filterValue.toLowerCase());
            });
            this.options = filteredOptions.slice(0);
            if (this.options.length === 0) {
                this.emptyResults = true;
            }
            else {
                this.emptyResults = false;
            }
        }
    }
    checkActive(value) {
        for (const selectedOption of this.selectedOptions) {
            if (selectedOption.value === value) {
                return true;
            }
        }
        return false;
    }
    returnOptionsToDefault() {
        this.emptyResults = false;
        this.options = this.originalOptions.slice(0);
    }
    toggleDropDown() {
        var _a;
        this.hideDropdown = !this.hideDropdown;
        (_a = this.inputComponent) === null || _a === void 0 ? void 0 : _a.focusInput(this.hideDropdown);
    }
    toggleDropDownKey(event) {
        if (event.keyCode === 13) {
            this.toggleDropDown();
        }
    }
    removeChipItem(index) {
        this.selectedOptions.splice(index, 1);
        this.returnOptionsToDefault();
    }
    removeAllChipItems() {
        this.selectedOptions = [];
        this.returnOptionsToDefault();
    }
    selectAll() {
        for (const option of this.options) {
            this.selectedOptions.push(option);
        }
        this.returnOptionsToDefault();
    }
    selectIndex(index) {
        var _a;
        if (this.limit !== 0 && this.selectedOptions.length >= this.limit) {
            return;
        }
        else {
            (_a = this.inputComponent) === null || _a === void 0 ? void 0 : _a.clearvalue();
            this.returnOptionsToDefault();
            if (this.checkDuplicated(index) === false) {
                this.selectedOptions.push(this.options[index]);
            }
        }
    }
    checkDuplicated(index) {
        return this.selectedOptions.some((element) => {
            if (element.value === this.options[index].value) {
                return true;
            }
            return false;
        });
    }
    ngOnInit() {
        this.selectedOptions = [];
        this.originalOptions = this.options.slice(0);
        this.selectedOptions = this.savedSelectedOptions;
        this.savedSelectedOptions = [];
        this.returnOptionsToDefault();
    }
}
AutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AutocompleteComponent, deps: [{ token: i0.KeyValueDiffers }], target: i0.ɵɵFactoryTarget.Component });
AutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: AutocompleteComponent, selector: "lib-autocomplete", inputs: { options: "options", title: "title", hintText: "hintText", name: "name", error: "error", limit: "limit", savedSelectedOptions: "savedSelectedOptions" }, outputs: { selectValueChange: "selectValueChange" }, host: { listeners: { "window:keydown.escape": "handleKeyDown($event)", "click": "clickInside($event)", "document:click": "clickout()" } }, viewQueries: [{ propertyName: "inputComponent", first: true, predicate: InputComponent, descendants: true, static: true }], ngImport: i0, template: "<div\n  class=\"autocomplete-container\"\n  [ngClass]=\"{ error: error }\"\n>\n  <div>\n    <!-- <jl-pr-sclp-input\n      [label]=\"title\"\n      [hintText]=\"hintText\"\n      [placeholder]=\"'+ ' + (name | translate)\"\n      [error]=\"error\"\n      (valueChange)=\"valueChange($event)\"\n    > -->\n    <lib-chip-item\n      *ngFor=\"let option of selectedOptions; let index = index\"\n      [chipContent]=\"option['text']\"\n      (iconClickEvent)=\"removeChipItem(index)\"\n    ></lib-chip-item>\n    <!-- </jl-pr-sclp-input> -->\n  </div>\n\n  <div\n    class=\"autocomplete-options\"\n    [ngClass]=\"hideDropdown === false ? '' : 'hide'\"\n    (mouseenter)=\"onMouseEnter()\"\n  >\n    <div\n      *ngIf=\"limit === 0\"\n      class=\"option autocomplete-target all-results\"\n      (click)=\"selectAll()\"\n      [tabindex]=\"0\"\n      [ngClass]=\"emptyResults === false ? '' : 'hide-option'\"\n    >\n      <p class=\"select-target\">\n        {{ 'AllOptionsForAutocomplete' | translate }} {{ title | translate }}s\n      </p>\n    </div>\n    <div\n      class=\"option autocomplete-target\"\n      *ngFor=\"let option of options; let index = index; first as isFirst\"\n      (click)=\"selectIndex(index)\"\n      [tabindex]=\"index + 1\"\n      [ngClass]=\"checkActive(option['value']) ? 'active' : ''\"\n    >\n      <p class=\"select-target\">{{ option['text'] }}</p>\n    </div>\n    <div\n      class=\"option autocomplete-target\"\n      [ngClass]=\"emptyResults === false ? 'hide-option' : ''\"\n    >\n      <p>{{ 'NoResults' | translate }}</p>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ChipItemComponent, selector: "lib-chip-item", inputs: ["chipContent"], outputs: ["iconClickEvent"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AutocompleteComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-autocomplete', template: "<div\n  class=\"autocomplete-container\"\n  [ngClass]=\"{ error: error }\"\n>\n  <div>\n    <!-- <jl-pr-sclp-input\n      [label]=\"title\"\n      [hintText]=\"hintText\"\n      [placeholder]=\"'+ ' + (name | translate)\"\n      [error]=\"error\"\n      (valueChange)=\"valueChange($event)\"\n    > -->\n    <lib-chip-item\n      *ngFor=\"let option of selectedOptions; let index = index\"\n      [chipContent]=\"option['text']\"\n      (iconClickEvent)=\"removeChipItem(index)\"\n    ></lib-chip-item>\n    <!-- </jl-pr-sclp-input> -->\n  </div>\n\n  <div\n    class=\"autocomplete-options\"\n    [ngClass]=\"hideDropdown === false ? '' : 'hide'\"\n    (mouseenter)=\"onMouseEnter()\"\n  >\n    <div\n      *ngIf=\"limit === 0\"\n      class=\"option autocomplete-target all-results\"\n      (click)=\"selectAll()\"\n      [tabindex]=\"0\"\n      [ngClass]=\"emptyResults === false ? '' : 'hide-option'\"\n    >\n      <p class=\"select-target\">\n        {{ 'AllOptionsForAutocomplete' | translate }} {{ title | translate }}s\n      </p>\n    </div>\n    <div\n      class=\"option autocomplete-target\"\n      *ngFor=\"let option of options; let index = index; first as isFirst\"\n      (click)=\"selectIndex(index)\"\n      [tabindex]=\"index + 1\"\n      [ngClass]=\"checkActive(option['value']) ? 'active' : ''\"\n    >\n      <p class=\"select-target\">{{ option['text'] }}</p>\n    </div>\n    <div\n      class=\"option autocomplete-target\"\n      [ngClass]=\"emptyResults === false ? 'hide-option' : ''\"\n    >\n      <p>{{ 'NoResults' | translate }}</p>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.KeyValueDiffers }]; }, propDecorators: { inputComponent: [{
                type: ViewChild,
                args: [InputComponent, { static: true }]
            }], options: [{
                type: Input
            }], title: [{
                type: Input
            }], hintText: [{
                type: Input
            }], name: [{
                type: Input
            }], error: [{
                type: Input
            }], limit: [{
                type: Input
            }], selectValueChange: [{
                type: Output
            }], savedSelectedOptions: [{
                type: Input
            }], handleKeyDown: [{
                type: HostListener,
                args: ['window:keydown.escape', ['$event']]
            }], clickInside: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], clickout: [{
                type: HostListener,
                args: ['document:click']
            }] } });

class ChipListComponent {
    constructor() {
        this.chipListChange = new EventEmitter();
    }
    ngOnInit() { }
    removeChipItem(chipIdx) {
        var _a;
        (_a = this.chipList) === null || _a === void 0 ? void 0 : _a.splice(chipIdx, 1);
        this.chipListChange.emit(this.chipList);
    }
    onSubmit() {
        var _a;
        if (this.chipContentText) {
            (_a = this.chipList) === null || _a === void 0 ? void 0 : _a.push(this.chipContentText);
            this.chipListChange.emit(this.chipList);
            this.chipContentText = '';
        }
    }
}
ChipListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ChipListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ChipListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: ChipListComponent, selector: "lib-chip-list", inputs: { chipList: "chipList" }, outputs: { chipListChange: "chipListChange" }, ngImport: i0, template: "<form\n  #form=\"ngForm\"\n  (ngSubmit)=\"onSubmit()\"\n>\n  <ircc-cl-lib-input\n    name=\"chipContentText\"\n    [(ngModel)]=\"chipContentText\"\n    placeholder=\"Add Chip\"\n  >\n  </ircc-cl-lib-input>\n</form>\n<div class=\"chip-list\">\n  <lib-chip-item\n    *ngFor=\"let chip of chipList; let idx = index\"\n    [chipContent]=\"chip\"\n    (iconClickEvent)=\"removeChipItem(idx)\"\n  ></lib-chip-item>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i5.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i5.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "component", type: ChipItemComponent, selector: "lib-chip-item", inputs: ["chipContent"], outputs: ["iconClickEvent"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: ChipListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-chip-list', template: "<form\n  #form=\"ngForm\"\n  (ngSubmit)=\"onSubmit()\"\n>\n  <ircc-cl-lib-input\n    name=\"chipContentText\"\n    [(ngModel)]=\"chipContentText\"\n    placeholder=\"Add Chip\"\n  >\n  </ircc-cl-lib-input>\n</form>\n<div class=\"chip-list\">\n  <lib-chip-item\n    *ngFor=\"let chip of chipList; let idx = index\"\n    [chipContent]=\"chip\"\n    (iconClickEvent)=\"removeChipItem(idx)\"\n  ></lib-chip-item>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { chipList: [{
                type: Input
            }], chipListChange: [{
                type: Output
            }] } });

class SecondaryChipsComponent {
    constructor() { }
    ngOnInit() { }
}
SecondaryChipsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SecondaryChipsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SecondaryChipsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: SecondaryChipsComponent, selector: "lib-secondary-chips", inputs: { chipContent: "chipContent" }, ngImport: i0, template: "<div\n  class=\"secondary-chip\"\n  tabindex=\"0\"\n>\n  <span class=\"secondary-chip-text\">{{ chipContent || '' | translate }}</span>\n</div>\n", dependencies: [{ kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SecondaryChipsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-secondary-chips', template: "<div\n  class=\"secondary-chip\"\n  tabindex=\"0\"\n>\n  <span class=\"secondary-chip-text\">{{ chipContent || '' | translate }}</span>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { chipContent: [{
                type: Input
            }] } });

class SearchInputComponent {
    constructor() {
        this.searchEvent = new EventEmitter();
        this.searchInputControl = new FormControl();
    }
    ngOnInit() {
        console.log('testing');
    }
}
SearchInputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SearchInputComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SearchInputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: SearchInputComponent, selector: "lib-search-input", inputs: { config: "config" }, outputs: { searchEvent: "searchEvent" }, ngImport: i0, template: "<input formControlName=\"searchInputControl\" />\n<!-- TODO: Translation? -->\n<ng-container *ngIf=\"config?.searchButton\">\n  <button>{{ config?.searchButton?.text }}</button>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i5.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i5.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: SearchInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-search-input', template: "<input formControlName=\"searchInputControl\" />\n<!-- TODO: Translation? -->\n<ng-container *ngIf=\"config?.searchButton\">\n  <button>{{ config?.searchButton?.text }}</button>\n</ng-container>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { config: [{
                type: Input
            }], searchEvent: [{
                type: Output
            }] } });

const IrccDsLegacyOldComponents = [
    AutocompleteComponent,
    ChipListComponent,
    SecondaryChipsComponent,
    ChipItemComponent,
    SearchInputComponent
];
class IrccDsAngularLegacyOldModule {
}
IrccDsAngularLegacyOldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularLegacyOldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularLegacyOldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularLegacyOldModule, declarations: [AutocompleteComponent,
        ChipListComponent,
        SecondaryChipsComponent,
        ChipItemComponent,
        SearchInputComponent], imports: [CommonModule,
        IrccDsAngularComponentsSharedModule,
        TranslateModule,
        FormsModule,
        ReactiveFormsModule], exports: [AutocompleteComponent,
        ChipListComponent,
        SecondaryChipsComponent,
        ChipItemComponent,
        SearchInputComponent] });
IrccDsAngularLegacyOldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularLegacyOldModule, imports: [CommonModule,
        IrccDsAngularComponentsSharedModule,
        TranslateModule,
        FormsModule,
        ReactiveFormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularLegacyOldModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...IrccDsLegacyOldComponents],
                    imports: [
                        CommonModule,
                        IrccDsAngularComponentsSharedModule,
                        TranslateModule,
                        FormsModule,
                        ReactiveFormsModule
                    ],
                    exports: [...IrccDsLegacyOldComponents]
                }]
        }] });

//TODO: Add detailed readme listing how this actually works. People will be SOOOO confused.
class NavigationService {
    constructor() {
        //Used entirely as a workaround for the change detection limitations
        this.itemChangeSubj = new Subject();
        this.itemChangeObs$ = this.itemChangeSubj.asObservable();
        this.navEventSubj = new Subject();
        this.navEventObs$ = this.navEventSubj.asObservable(); //Use this for any events we need propagated up to parents
        this.navConfigSubj = new BehaviorSubject({
            id: '',
            label: '',
            iconLeading: '',
            iconTrailing: '',
            height: '',
            size: 'small',
            scrolling: false,
            marginTop: 0,
            navigationConfig: [],
            childrenPadding: true
        });
        this.navConfigObs$ = this.navConfigSubj.asObservable();
        this.flattenedNavigation = [];
        /**
         * Flatten an object into a simple array
         * @param obj object being flattened
         * @returns flattened array
         */
        this.flatten = (obj) => {
            const stack = [obj];
            let stackB = [];
            while ((stack === null || stack === void 0 ? void 0 : stack.length) > 0) {
                const currentObj = stack.pop();
                if (!Array.isArray(currentObj)) {
                    stackB.push(currentObj);
                }
                Object.keys(currentObj).forEach((key) => {
                    if (typeof currentObj[key] === 'object' && currentObj[key] !== null) {
                        stack.push(currentObj[key]);
                    }
                });
            }
            return stackB;
        };
        /**
         *
         * @param items flattened array
         * @param key of the key value pair ('id')
         * @param value id of the piece being searched for (update.id)
         * @returns
         */
        this.findByKey = (items, key, value) => {
            let returnItem = {
                id: '',
                label: '',
                type: 'accordion',
                children: []
            };
            returnItem = items.find((element) => element[key] === value) || {
                id: '',
                label: '',
                type: 'accordion',
                children: []
            };
            return returnItem;
        };
        /**
         * Replace the contents of one object with those of another. This is done to keep our
         * memory trick going
         * @param obj1 object being updated
         * @param obj2 values to put in obj1
         */
        this.setNavItemFields = (obj1, obj2) => {
            Object.keys(obj2).forEach((key) => {
                obj1[key] = obj2[key];
            });
        };
    }
    /**
     * Broadcast the config object of the value and flatten the array
     * @param update: INavigationConfig
     */
    setNavConfig(update) {
        this.navConfigSubj.next(update);
        this.flattenedNavigation = this.flatten(update);
    }
    /**
     * General broadcast of an element update
     * @param event
     */
    setNavItem(update) {
        this.setNavItemFields(this.findByKey(this.flattenedNavigation, 'id', update.id), update);
        this.itemChangeSubj.next(update.id); //This is used to get around a change detection problem in the various child components
    }
    /**
     * Broadcast element events
     * @param event: INavItemEvent where id is the id of the component broadcasting and event is the Event
     */
    navEvent(event) {
        this.navEventSubj.next(event);
    }
}
NavigationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavigationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NavigationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavigationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class navItemHeadingComponent {
    constructor(navEvent) {
        var _a, _b;
        this.navEvent = navEvent;
        this.config = {
            id: '',
            label: '',
            iconLeading: '',
            size: 'small',
            type: 'heading',
            children: [],
            bold: false
        };
        this.id = '';
        this.label = '';
        this.iconLeading = '';
        this.buttonIcon = {
            id: `${this.config.id}-button`,
            category: 'custom',
            size: (_a = this.config) === null || _a === void 0 ? void 0 : _a.size,
            icon: {
                class: (_b = this.config) === null || _b === void 0 ? void 0 : _b.iconLeading,
                color: 'var(--text-primary)'
            }
        };
        this.navObjectChangeSub = new Subscription();
    }
    ngOnInit() {
        var _a, _b, _c, _d;
        this.id !== '' ? (this.config.id = this.id) : undefined;
        this.label !== '' ? (this.config.label = this.label) : undefined;
        this.iconLeading !== ''
            ? (this.config.iconLeading = this.iconLeading)
            : undefined;
        this.children !== undefined
            ? (this.config.children = this.children)
            : undefined;
        this.size !== undefined ? (this.config.size = this.size) : undefined;
        this.leftPadding !== undefined
            ? (this.config.leftPadding = this.leftPadding)
            : undefined;
        this.bold !== undefined ? (this.config.bold = this.bold) : undefined;
        if (((_a = this.config) === null || _a === void 0 ? void 0 : _a.bold) != true && ((_b = this.config) === null || _b === void 0 ? void 0 : _b.bold) != false) {
            this.config.bold = true;
        }
        this.buttonIcon = {
            id: `${this.config.id}_button`,
            category: 'custom',
            size: (_c = this.config) === null || _c === void 0 ? void 0 : _c.size,
            icon: {
                class: (_d = this.config) === null || _d === void 0 ? void 0 : _d.iconLeading,
                color: 'var(--text-primary)'
            }
        };
    }
    getClasses() {
        var _a, _b;
        let classes = '';
        if (this.config.iconLeading.length > 0) {
            classes += 'grid-header';
        }
        if (((_a = this.config) === null || _a === void 0 ? void 0 : _a.leftPadding) === true) {
            classes += ' left-padding';
        }
        if (((_b = this.config) === null || _b === void 0 ? void 0 : _b.bold) === false) {
            classes += ' remove-bold';
        }
        return classes;
    }
}
navItemHeadingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemHeadingComponent, deps: [{ token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
navItemHeadingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: navItemHeadingComponent, selector: "ircc-cl-lib-nav-header", inputs: { config: "config", id: "id", label: "label", iconLeading: "iconLeading", children: "children", size: "size", leftPadding: "leftPadding", bold: "bold" }, ngImport: i0, template: "<div [id]=\"config.id\">\n  <div\n    class=\"nav-header-header\"\n    [class]=\"getClasses()\"\n  >\n    <ircc-cl-lib-icon\n      *ngIf=\"config.iconLeading.length > 0\"\n      [config]=\"{ FA_keywords: config.iconLeading }\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n    <h2>{{ config?.label || '' | translate }}</h2>\n  </div>\n  <div class=\"nav-header-content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemHeadingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-nav-header', template: "<div [id]=\"config.id\">\n  <div\n    class=\"nav-header-header\"\n    [class]=\"getClasses()\"\n  >\n    <ircc-cl-lib-icon\n      *ngIf=\"config.iconLeading.length > 0\"\n      [config]=\"{ FA_keywords: config.iconLeading }\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n    <h2>{{ config?.label || '' | translate }}</h2>\n  </div>\n  <div class=\"nav-header-content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: NavigationService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], iconLeading: [{
                type: Input
            }], children: [{
                type: Input
            }], size: [{
                type: Input
            }], leftPadding: [{
                type: Input
            }], bold: [{
                type: Input
            }] } });

//TODO: Fix class name (NavItemNavComponent)
class navItemNavComponent {
    constructor(renderer, navEvent, cdr) {
        this.renderer = renderer;
        this.navEvent = navEvent;
        this.cdr = cdr;
        //TODO: Pattern is supposed to be that any elements that may not be used should be OPTIONAL
        this.config = {
            id: '',
            href: '',
            anchor: '',
            external: false,
            border: false,
            label: '',
            iconLeading: '',
            iconTrailing: '',
            type: 'link',
            children: [],
            header: false
        };
        this.id = '';
        this.indicatorConfig = {
            category: 'weak',
            purpose: 'status',
            type: 'dot',
            tabIndex: -1
        };
        this.headerConfig = {
            iconLeading: '',
            id: 'header_link',
            label: 'Header Title',
            type: 'heading',
            children: []
        };
        // Check if current url's fragment match
        this.fragMatchOptions = {
            queryParams: 'ignored',
            matrixParams: 'exact',
            paths: 'exact',
            fragment: 'exact'
        };
        this.navObjectChangeSub = new Subscription();
    }
    ngOnInit() {
        //Used entirely as a workaround for the change detection limitations
        this.navObjectChangeSub = this.navEvent.itemChangeObs$
            .pipe(filter((item) => item === this.config.id))
            .subscribe(() => {
            var _a, _b;
            this.indicatorConfig.status = (_a = this.config.indicator) === null || _a === void 0 ? void 0 : _a.status;
            this.indicatorConfig.icon = (_b = this.config.indicator) === null || _b === void 0 ? void 0 : _b.icon;
        });
        this.id !== '' ? (this.config.id = this.id) : undefined;
        if (this.config.indicator) {
            this.indicatorConfig = {
                type: 'dot',
                category: 'weak',
                purpose: 'status',
                status: this.config.indicator.status,
                icon: this.config.indicator.icon,
                tabIndex: -1
            };
            this.config.indicator.label
                ? (this.indicatorConfig = Object.assign(Object.assign({}, this.indicatorConfig), { type: 'text', label: this.config.indicator.label, tabIndex: -1 }))
                : null;
            this.size
                ? (this.indicatorConfig = Object.assign(Object.assign({}, this.indicatorConfig), { size: this.size }))
                : null;
        }
        this.size !== undefined ? (this.config.size = this.size) : undefined;
    }
    linkClick(e) {
        this.navEvent.navEvent({ id: this.config.id, event: e }); //Broadcast the event
        if (!this.config.external) {
            setTimeout(() => {
                var _a;
                if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.anchor) {
                    const anchorElement = this.renderer.selectRootElement(`#${this.config.anchor}`, true);
                    anchorElement
                        ? anchorElement.scrollIntoView({ behavior: 'smooth' })
                        : null;
                }
            }, 0);
        }
    }
    enterPress(event) {
        var _a, _b;
        if (this.config.external) {
            (_a = this.externalLinkA) === null || _a === void 0 ? void 0 : _a.nativeElement.click();
        }
        else {
            (_b = this.internalLink) === null || _b === void 0 ? void 0 : _b.nativeElement.click();
        }
    }
}
navItemNavComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemNavComponent, deps: [{ token: i0.Renderer2 }, { token: NavigationService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
navItemNavComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: navItemNavComponent, selector: "ircc-cl-lib-nav-item", inputs: { config: "config", id: "id", size: "size", indicator: "indicator" }, viewQueries: [{ propertyName: "externalLinkA", first: true, predicate: ["externalLinkA"], descendants: true }, { propertyName: "internalLink", first: true, predicate: ["internalLink"], descendants: true }], ngImport: i0, template: "<div\n  [id]=\"config.id\"\n  class=\"lib-nav-item\"\n  [ngClass]=\"config?.border ? 'border-left' : null\"\n  (keydown.enter)=\"enterPress($event)\"\n>\n  <div>\n    <ng-container *ngIf=\"config?.external !== true; else externalLink\">\n      <a\n        [routerLink]=\"config?.href || '' | translate\"\n        [fragment]=\"config?.anchor\"\n        [routerLinkActive]=\"'active-link'\"\n        [routerLinkActiveOptions]=\"fragMatchOptions\"\n        (click)=\"linkClick($event)\"\n        #internalLink\n      >\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconLeading\"\n          class=\"icon-left\"\n          [config]=\"{ FA_keywords: config?.iconLeading || '' }\"\n        ></ircc-cl-lib-icon>\n        <p *ngIf=\"config?.header !== true\">\n          {{ config?.label || '' | translate }}\n        </p>\n        <h2\n          *ngIf=\"config?.header === true\"\n          class=\"h5\"\n        >\n          {{ config?.label || '' | translate }}\n        </h2>\n        <!-- <ircc-cl-lib-nav-header\n          [attr.size]=\"config.size\"\n          [size]=\"config.size\"\n          [label]=\"\"\n          *ngIf=\"config?.header === true\"\n        >\n        </ircc-cl-lib-nav-header> -->\n        <ircc-cl-lib-indicator\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.indicator\"\n          [config]=\"indicatorConfig\"\n        ></ircc-cl-lib-indicator>\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconTrailing\"\n          class=\"icon-trailing\"\n          [config]=\"{ FA_keywords: config?.iconTrailing || '' }\"\n        ></ircc-cl-lib-icon>\n      </a>\n    </ng-container>\n    <ng-template #externalLink>\n      <a\n        #externalLinkA\n        target=\"_blank\"\n        [attr.href]=\"\n          config?.href + (config?.anchor ? '#' + config.anchor : '') || ''\n            | translate\n        \"\n      >\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconLeading\"\n          class=\"icon-left\"\n          [config]=\"{ FA_keywords: config?.iconLeading || '' }\"\n        ></ircc-cl-lib-icon>\n        <p>{{ config?.label || '' | translate }} {{ config.size }}</p>\n        <ircc-cl-lib-indicator\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.indicator\"\n          [config]=\"indicatorConfig\"\n        ></ircc-cl-lib-indicator>\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconTrailing\"\n          class=\"icon-trailing\"\n          [config]=\"{ FA_keywords: config?.iconTrailing || '' }\"\n        ></ircc-cl-lib-icon>\n      </a>\n    </ng-template>\n  </div>\n  <div>\n    <ng-content></ng-content>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i3.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "ariaCurrentWhenActive", "routerLinkActive"], outputs: ["isActiveChange"], exportAs: ["routerLinkActive"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "component", type: IndicatorComponent, selector: "ircc-cl-lib-indicator", inputs: ["config", "size", "type", "icon", "category", "purpose", "status", "palette", "ariaLabel", "tabIndex"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-nav-item', template: "<div\n  [id]=\"config.id\"\n  class=\"lib-nav-item\"\n  [ngClass]=\"config?.border ? 'border-left' : null\"\n  (keydown.enter)=\"enterPress($event)\"\n>\n  <div>\n    <ng-container *ngIf=\"config?.external !== true; else externalLink\">\n      <a\n        [routerLink]=\"config?.href || '' | translate\"\n        [fragment]=\"config?.anchor\"\n        [routerLinkActive]=\"'active-link'\"\n        [routerLinkActiveOptions]=\"fragMatchOptions\"\n        (click)=\"linkClick($event)\"\n        #internalLink\n      >\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconLeading\"\n          class=\"icon-left\"\n          [config]=\"{ FA_keywords: config?.iconLeading || '' }\"\n        ></ircc-cl-lib-icon>\n        <p *ngIf=\"config?.header !== true\">\n          {{ config?.label || '' | translate }}\n        </p>\n        <h2\n          *ngIf=\"config?.header === true\"\n          class=\"h5\"\n        >\n          {{ config?.label || '' | translate }}\n        </h2>\n        <!-- <ircc-cl-lib-nav-header\n          [attr.size]=\"config.size\"\n          [size]=\"config.size\"\n          [label]=\"\"\n          *ngIf=\"config?.header === true\"\n        >\n        </ircc-cl-lib-nav-header> -->\n        <ircc-cl-lib-indicator\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.indicator\"\n          [config]=\"indicatorConfig\"\n        ></ircc-cl-lib-indicator>\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconTrailing\"\n          class=\"icon-trailing\"\n          [config]=\"{ FA_keywords: config?.iconTrailing || '' }\"\n        ></ircc-cl-lib-icon>\n      </a>\n    </ng-container>\n    <ng-template #externalLink>\n      <a\n        #externalLinkA\n        target=\"_blank\"\n        [attr.href]=\"\n          config?.href + (config?.anchor ? '#' + config.anchor : '') || ''\n            | translate\n        \"\n      >\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconLeading\"\n          class=\"icon-left\"\n          [config]=\"{ FA_keywords: config?.iconLeading || '' }\"\n        ></ircc-cl-lib-icon>\n        <p>{{ config?.label || '' | translate }} {{ config.size }}</p>\n        <ircc-cl-lib-indicator\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.indicator\"\n          [config]=\"indicatorConfig\"\n        ></ircc-cl-lib-indicator>\n        <ircc-cl-lib-icon\n          [attr.size]=\"config.size\"\n          tabindex=\"-1\"\n          *ngIf=\"config?.iconTrailing\"\n          class=\"icon-trailing\"\n          [config]=\"{ FA_keywords: config?.iconTrailing || '' }\"\n        ></ircc-cl-lib-icon>\n      </a>\n    </ng-template>\n  </div>\n  <div>\n    <ng-content></ng-content>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: NavigationService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { externalLinkA: [{
                type: ViewChild,
                args: ['externalLinkA', { static: false }]
            }], internalLink: [{
                type: ViewChild,
                args: ['internalLink', { static: false }]
            }], config: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], indicator: [{
                type: Input
            }] } });

class navItemAccordionComponent {
    constructor(navEvent) {
        var _a, _b;
        this.navEvent = navEvent;
        this.config = {
            id: '',
            open: false,
            label: '',
            size: 'small',
            type: 'accordion',
            children: [],
            leftPadding: false,
            bold: true
        };
        this.id = '';
        this.label = '';
        this.iconLeading = '';
        this.headerID = '';
        this.buttonIconOpen = {
            id: `${this.config.id}-button`,
            category: 'custom',
            size: (_a = this.config) === null || _a === void 0 ? void 0 : _a.size,
            icon: {
                class: 'fa-light fa-arrow-right',
                color: 'var(--text-primary)'
            }
        };
        this.buttonIconClose = {
            id: `${this.config.id}-button`,
            category: 'custom',
            size: (_b = this.config) === null || _b === void 0 ? void 0 : _b.size,
            icon: {
                class: 'fa-light fa-arrow-right',
                color: 'var(--text-primary)'
            }
        };
        this.navObjectChangeSub = new Subscription();
    }
    ngOnInit() {
        var _a, _b, _c, _d;
        // this.navObjectChangeSub = this.navEvent.navObjectChangeObs$.pipe(
        //   filter(item => (item.id === this.config.id && item.type === 'accordion'))).subscribe(response => {
        //     this.config = response as NavigationItemAccordion;
        //   });
        this.id !== '' ? (this.config.id = this.id) : undefined;
        this.open !== undefined ? (this.config.open = this.open) : undefined;
        this.bold !== undefined ? (this.config.bold = this.bold) : undefined;
        if (((_a = this.config) === null || _a === void 0 ? void 0 : _a.bold) != true && ((_b = this.config) === null || _b === void 0 ? void 0 : _b.bold) != false) {
            this.config.bold = true;
        }
        this.leftPadding !== undefined
            ? (this.config.leftPadding = this.leftPadding)
            : undefined;
        this.label !== '' ? (this.config.label = this.label) : undefined;
        this.size !== undefined ? (this.config.size = this.size) : undefined;
        this.iconLeading !== ''
            ? (this.config.iconLeading = this.iconLeading)
            : undefined;
        this.headerID = `${this.config.id}_header`;
        this.buttonIconOpen = {
            id: `${this.config.id}_button_open`,
            category: 'custom',
            size: (_c = this.config) === null || _c === void 0 ? void 0 : _c.size,
            icon: {
                class: 'fa-light fa-chevron-up',
                color: 'var(--text-primary)'
            }
        };
        this.buttonIconClose = {
            id: `${this.config.id}_button_close`,
            category: 'custom',
            size: (_d = this.config) === null || _d === void 0 ? void 0 : _d.size,
            icon: {
                class: 'fa-light fa-chevron-down',
                color: 'var(--text-primary)'
            }
        };
    }
    openAccordion(event) {
        this.config.open = !this.config.open;
        this.navEvent.navEvent({ id: this.config.id, event: event });
    }
    enterPress(event) {
        this.config.open = !this.config.open;
    }
}
navItemAccordionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemAccordionComponent, deps: [{ token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
navItemAccordionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: navItemAccordionComponent, selector: "ircc-cl-lib-nav-accordion", inputs: { config: "config", id: "id", open: "open", label: "label", size: "size", iconLeading: "iconLeading", leftPadding: "leftPadding", bold: "bold" }, ngImport: i0, template: "<div\n  [id]=\"config.id\"\n  class=\"lib-nav-item\"\n>\n  <div class=\"accordion-panel\">\n    <div\n      class=\"accordion-nav\"\n      (keydown.enter)=\"enterPress($event)\"\n    >\n      <ircc-cl-lib-nav-header\n        [id]=\"headerID\"\n        [attr.size]=\"config.size\"\n        [size]=\"config.size\"\n        [label]=\"config?.label || ''\"\n        [iconLeading]=\"config?.iconLeading || ''\"\n        [leftPadding]=\"config?.leftPadding\"\n        [bold]=\"config?.bold\"\n      >\n      </ircc-cl-lib-nav-header>\n\n      <ircc-cl-lib-icon-button\n        *ngIf=\"config.open === true\"\n        (clickEvent)=\"openAccordion($event)\"\n        [config]=\"buttonIconOpen\"\n        [attr.size]=\"config.size\"\n        class=\"open\"\n      ></ircc-cl-lib-icon-button>\n      <ircc-cl-lib-icon-button\n        *ngIf=\"config.open === false\"\n        (clickEvent)=\"openAccordion($event)\"\n        [attr.size]=\"config.size\"\n        [config]=\"buttonIconClose\"\n        class=\"close\"\n      ></ircc-cl-lib-icon-button>\n    </div>\n    <div\n      [class]=\"\n        config.open ? 'open accordion-content' : 'close accordion-content'\n      \"\n    >\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconButtonComponent, selector: "ircc-cl-lib-icon-button", inputs: ["config", "id", "category", "size", "ariaLabel", "disabled", "icon"], outputs: ["clickEvent"] }, { kind: "component", type: navItemHeadingComponent, selector: "ircc-cl-lib-nav-header", inputs: ["config", "id", "label", "iconLeading", "children", "size", "leftPadding", "bold"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemAccordionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-nav-accordion', template: "<div\n  [id]=\"config.id\"\n  class=\"lib-nav-item\"\n>\n  <div class=\"accordion-panel\">\n    <div\n      class=\"accordion-nav\"\n      (keydown.enter)=\"enterPress($event)\"\n    >\n      <ircc-cl-lib-nav-header\n        [id]=\"headerID\"\n        [attr.size]=\"config.size\"\n        [size]=\"config.size\"\n        [label]=\"config?.label || ''\"\n        [iconLeading]=\"config?.iconLeading || ''\"\n        [leftPadding]=\"config?.leftPadding\"\n        [bold]=\"config?.bold\"\n      >\n      </ircc-cl-lib-nav-header>\n\n      <ircc-cl-lib-icon-button\n        *ngIf=\"config.open === true\"\n        (clickEvent)=\"openAccordion($event)\"\n        [config]=\"buttonIconOpen\"\n        [attr.size]=\"config.size\"\n        class=\"open\"\n      ></ircc-cl-lib-icon-button>\n      <ircc-cl-lib-icon-button\n        *ngIf=\"config.open === false\"\n        (clickEvent)=\"openAccordion($event)\"\n        [attr.size]=\"config.size\"\n        [config]=\"buttonIconClose\"\n        class=\"close\"\n      ></ircc-cl-lib-icon-button>\n    </div>\n    <div\n      [class]=\"\n        config.open ? 'open accordion-content' : 'close accordion-content'\n      \"\n    >\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: NavigationService }]; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }], open: [{
                type: Input
            }], label: [{
                type: Input
            }], size: [{
                type: Input
            }], iconLeading: [{
                type: Input
            }], leftPadding: [{
                type: Input
            }], bold: [{
                type: Input
            }] } });

class navItemDividerComponent {
    constructor() {
        this.config = {
            id: '',
            children: [],
            label: '',
            type: 'link'
        };
        this.id = '';
    }
    ngOnInit() {
        this.id !== '' ? (this.config.id = this.id) : undefined;
    }
}
navItemDividerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemDividerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
navItemDividerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: navItemDividerComponent, selector: "ircc-cl-lib-nav-divider", inputs: { config: "config", id: "id" }, ngImport: i0, template: "<div\n  [id]=\"config.id\"\n  class=\"nav-seperator\"\n></div>\n", preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemDividerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-nav-divider', template: "<div\n  [id]=\"config.id\"\n  class=\"nav-seperator\"\n></div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { config: [{
                type: Input
            }], id: [{
                type: Input
            }] } });

class navigationComponent {
    constructor(navService, renderer, el) {
        this.navService = navService;
        this.renderer = renderer;
        this.el = el;
        this.id = '';
        this.label = '';
        this.iconLeading = '';
        this.iconTrailing = '';
        //TODO: NavigationItem and all other interfaces must be renamed starting with 'I'
        this.navigationConfig = [];
        this.flattenNavigation = [];
        this.config = {
            id: '',
            label: '',
            iconLeading: '',
            iconTrailing: '',
            size: 'small',
            navigationConfig: [],
            scrolling: false,
            height: '75vh',
            marginTop: 0,
            childrenPadding: true
        };
        this.wrapperFixed = false;
        this.listenerScroll = () => { };
        this.listenerResize = () => { };
        this.isArray = (obj) => {
            return Array.isArray(obj);
        };
        this.arrayOfObject = (obj) => {
            return Object.keys(obj);
        };
        this.getIconsStatus = () => {
            var _a, _b;
            return (this.config &&
                (((_a = this.config) === null || _a === void 0 ? void 0 : _a.iconLeading) || '').length > 0 &&
                (((_b = this.config) === null || _b === void 0 ? void 0 : _b.iconTrailing) || '').length > 0);
        };
        //These are in THIS component, not in it's own. I.e. the buttons in the actual
        //header are not in a child component.
        this.clickIconLeading = (event) => {
            this.navService.navEvent({ id: this.config.id, event: event });
        };
        this.clickIconTrailing = (event) => {
            this.navService.navEvent({ id: this.config.id, event: event });
        };
        this.navigationClass = () => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (((((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.iconLeading) === null || _b === void 0 ? void 0 : _b.length) || ''.length > 0) &&
                ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.iconTrailing) === null || _d === void 0 ? void 0 : _d.length)) ||
                ''.length > 0) {
                return 'header-full';
            }
            else if (((_f = (_e = this.config) === null || _e === void 0 ? void 0 : _e.iconLeading) === null || _f === void 0 ? void 0 : _f.length) || ''.length > 0) {
                return 'header-iconleading';
            }
            else if (((_h = (_g = this.config) === null || _g === void 0 ? void 0 : _g.iconTrailing) === null || _h === void 0 ? void 0 : _h.length) || ''.length > 0) {
                return 'header-icontrailing';
            }
            return '';
        };
        this.getHeight = () => {
            this.listenerScroll();
            this.listenerResize();
            if (this.complicatedMaths() === true) {
                this.disableStickyNav();
                this.setScrollableNavigationArea();
                this.listenerResize = this.renderer.listen('window', 'resize', () => {
                    this.setScrollableNavigationArea();
                });
            }
            else if (this.complicatedMaths() === false) {
                this.disableSetScrollableNavigationArea();
                this.setStickyNav();
                this.listenerScroll = this.renderer.listen('window', 'scroll', () => {
                    this.scrolling();
                });
            }
        };
        this.scrolling = () => {
            if (this.scrollTimeout) {
                clearTimeout(this.scrollTimeout);
            }
            this.scrollTimeout = setTimeout((() => {
                this.setStickyNav();
            }).bind(this), 50);
        };
        this.setStickyNav = () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (window.pageYOffset > ((_a = this.navigationHeader) === null || _a === void 0 ? void 0 : _a.nativeElement.offsetHeight)) {
                this.renderer.addClass((_b = this.navigationHeader) === null || _b === void 0 ? void 0 : _b.nativeElement, 'position-fixed');
                this.renderer.setStyle((_c = this.navigationHeader) === null || _c === void 0 ? void 0 : _c.nativeElement, 'top', `${(_d = this.config) === null || _d === void 0 ? void 0 : _d.marginTop}px`);
                this.renderer.setStyle((_e = this.navigationAreaScroll) === null || _e === void 0 ? void 0 : _e.nativeElement, 'margin-top', ((_f = this.navigationHeader) === null || _f === void 0 ? void 0 : _f.nativeElement.offsetHeight) +
                    ((_g = this.config) === null || _g === void 0 ? void 0 : _g.marginTop) +
                    'px');
            }
            else {
                this.renderer.removeClass((_h = this.navigationHeader) === null || _h === void 0 ? void 0 : _h.nativeElement, 'position-fixed');
                this.renderer.removeStyle((_j = this.navigationHeader) === null || _j === void 0 ? void 0 : _j.nativeElement, 'top');
                this.renderer.removeStyle((_k = this.navigationAreaScroll) === null || _k === void 0 ? void 0 : _k.nativeElement, 'margin-top');
            }
        };
        this.disableStickyNav = () => {
            var _a, _b, _c, _d;
            this.renderer.removeClass((_a = this.navigationHeader) === null || _a === void 0 ? void 0 : _a.nativeElement, 'position-fixed');
            this.renderer.removeStyle((_b = this.navigationHeader) === null || _b === void 0 ? void 0 : _b.nativeElement, 'top');
            this.renderer.removeStyle((_c = this.navigationAreaScroll) === null || _c === void 0 ? void 0 : _c.nativeElement, 'margin-top');
            this.renderer.removeStyle((_d = this.navigationArea) === null || _d === void 0 ? void 0 : _d.nativeElement, 'height');
        };
        this.complicatedMaths = () => {
            var _a, _b, _c;
            let windowheight = window.innerHeight;
            let usableHeight = windowheight -
                (((_a = this.navigationHeader) === null || _a === void 0 ? void 0 : _a.nativeElement.offsetHeight) +
                    ((_b = this.navigationContentTop) === null || _b === void 0 ? void 0 : _b.nativeElement.offsetHeight) +
                    ((_c = this.navigationContentBottom) === null || _c === void 0 ? void 0 : _c.nativeElement.offsetHeight));
            return usableHeight > windowheight / 2 ? true : false;
        };
        this.setScrollableNavigationArea = () => {
            var _a, _b, _c;
            this.renderer.setStyle((_a = this.navigation) === null || _a === void 0 ? void 0 : _a.nativeElement, 'height', this.config.height);
            this.renderer.setStyle((_b = this.navigation) === null || _b === void 0 ? void 0 : _b.nativeElement, 'overflow-y', 'auto');
            this.renderer.setStyle((_c = this.navigation) === null || _c === void 0 ? void 0 : _c.nativeElement, 'overflow-x', 'clip');
        };
        this.disableSetScrollableNavigationArea = () => {
            var _a, _b, _c;
            this.renderer.removeStyle((_a = this.navigation) === null || _a === void 0 ? void 0 : _a.nativeElement, 'height');
            this.renderer.removeStyle((_b = this.navigation) === null || _b === void 0 ? void 0 : _b.nativeElement, 'overflow-y');
            this.renderer.removeStyle((_c = this.navigation) === null || _c === void 0 ? void 0 : _c.nativeElement, 'overflow-x');
        };
        this.setIndex = (index) => {
            return (index += 1);
        };
    }
    ngOnInit() {
        var _a;
        this.configSub = this.navService.navConfigObs$.subscribe((response) => {
            var _a, _b;
            this.config = response;
            if (((_a = this.config) === null || _a === void 0 ? void 0 : _a.childrenPadding) != true &&
                ((_b = this.config) === null || _b === void 0 ? void 0 : _b.childrenPadding) != false) {
                this.config.childrenPadding = true;
            }
        });
        // Record relative height from top of page for sidenav
        this.wrapperTop = (_a = this.el.nativeElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().top;
    }
    getPaddingChildrenPadding(index) {
        var _a;
        let classes = '';
        if (((_a = this.config) === null || _a === void 0 ? void 0 : _a.childrenPadding) === true) {
            classes += 'indent-' + index;
        }
        return classes;
    }
    ngAfterViewInit() {
        this.wrapperWidth = this.el.nativeElement.parentElement.offsetWidth;
        if (this.config.scrolling === true) {
            this.getHeight();
            this.renderer.listen('window', 'resize', () => {
                this.getHeight();
                setTimeout(() => {
                    // Update element width upon window resize
                    this.wrapperWidth = this.el.nativeElement.parentElement.offsetWidth;
                });
            });
        }
        if (this.config.fixed) {
            this.renderer.listen('window', 'scroll', () => {
                // Check if navigation top has hit top of viewport
                if (this.wrapperTop) {
                    this.wrapperFixed = this.wrapperTop < window.scrollY;
                }
            });
        }
    }
}
navigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navigationComponent, deps: [{ token: NavigationService }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
navigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: navigationComponent, selector: "ircc-cl-lib-navigation", inputs: { id: "id", label: "label", iconLeading: "iconLeading", iconTrailing: "iconTrailing", size: "size", navigationConfig: "navigationConfig" }, viewQueries: [{ propertyName: "navigationHeader", first: true, predicate: ["navigationHeader"], descendants: true }, { propertyName: "navigationContentTop", first: true, predicate: ["navigationContentTop"], descendants: true }, { propertyName: "navigationContentBottom", first: true, predicate: ["navigationContentBottom"], descendants: true }, { propertyName: "navigationArea", first: true, predicate: ["navigationArea"], descendants: true }, { propertyName: "navigationAreaScroll", first: true, predicate: ["navigationAreaScroll"], descendants: true }, { propertyName: "navigation", first: true, predicate: ["navigation"], descendants: true }], ngImport: i0, template: "<div\n  [id]=\"config.id\"\n  [attr.size]=\"config.size\"\n  class=\"lib-navigation\"\n  [ngClass]=\"{ fixed: config.fixed && wrapperFixed }\"\n  [style.max-width]=\"\n    wrapperFixed && wrapperWidth && wrapperWidth > 0\n      ? wrapperWidth + 'px'\n      : 'none'\n  \"\n  #navigation\n>\n  <div\n    class=\"navigation-header\"\n    [class]=\"navigationClass()\"\n    #navigationHeader\n  >\n    <ircc-cl-lib-icon\n      class=\"icon-leading\"\n      [config]=\"{ FA_keywords: config?.iconLeading || '' }\"\n      (click)=\"clickIconLeading(config.id + '_icon_leading')\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n    <ng-container *ngIf=\"config?.label\">\n      <h3>{{ config?.label || '' | translate }}</h3>\n    </ng-container>\n    <ircc-cl-lib-icon\n      [id]=\"config.id + '_icon_trailing'\"\n      class=\"icon-trailing\"\n      [attr.size]=\"config.size\"\n      [config]=\"{ FA_keywords: config?.iconTrailing || '' }\"\n      (click)=\"clickIconTrailing(config.id + '_icon_trailing')\"\n    ></ircc-cl-lib-icon>\n  </div>\n\n  <div #navigationAreaScroll>\n    <!-- ignore-->\n    <!-- prettier-ignore -->\n    <div class=\"navigation-content-top\" #navigationContentTop ><ng-content select=\"[navigationContentTop]\"></ng-content></div>\n\n    <!-- TODO: Document this like crazy - recursive templating is cool, but EXTREMELY unusual -->\n    <div\n      class=\"navigation-area\"\n      #navigationArea\n    >\n      <ul class=\"parent-navigation\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            recursiveListTmpl;\n            context: { list: this.config.navigationConfig, index: 0 }\n          \"\n        ></ng-container>\n      </ul>\n    </div>\n\n    <ng-template\n      #recursiveListTmpl\n      let-list=\"list\"\n      let-index=\"index\"\n    >\n      <li *ngFor=\"let item of list\">\n        <ng-container [ngSwitch]=\"item.type\">\n          <!--Type Heading-->\n          <ng-container *ngSwitchCase=\"'heading'\"\n            ><ircc-cl-lib-nav-header\n              [attr.size]=\"config.size\"\n              [size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul></ircc-cl-lib-nav-header\n          ></ng-container>\n\n          <!--Type Link-->\n          <ng-container *ngSwitchCase=\"'link'\">\n            <ircc-cl-lib-nav-item\n              [attr.size]=\"config.size\"\n              [size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul></ircc-cl-lib-nav-item\n          ></ng-container>\n\n          <!--Type Accordion-->\n          <ng-container *ngSwitchCase=\"'accordion'\">\n            <ircc-cl-lib-nav-accordion\n              [attr.size]=\"config.size\"\n              [size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul\n            ></ircc-cl-lib-nav-accordion>\n          </ng-container>\n\n          <ng-container *ngSwitchCase=\"'divider'\">\n            <ircc-cl-lib-nav-divider\n              [attr.size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul\n            ></ircc-cl-lib-nav-divider>\n          </ng-container>\n        </ng-container>\n      </li>\n    </ng-template>\n\n    <!-- prettier-ignore -->\n    <div class=\"navigation-content-bottom\" #navigationContentBottom><ng-content select=\"[navigationContentBottom]\"></ng-content></div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "component", type: IconComponent, selector: "ircc-cl-lib-icon", inputs: ["config", "ariaLabel", "FA_keywords", "size"] }, { kind: "component", type: navItemHeadingComponent, selector: "ircc-cl-lib-nav-header", inputs: ["config", "id", "label", "iconLeading", "children", "size", "leftPadding", "bold"] }, { kind: "component", type: navItemNavComponent, selector: "ircc-cl-lib-nav-item", inputs: ["config", "id", "size", "indicator"] }, { kind: "component", type: navItemAccordionComponent, selector: "ircc-cl-lib-nav-accordion", inputs: ["config", "id", "open", "label", "size", "iconLeading", "leftPadding", "bold"] }, { kind: "component", type: navItemDividerComponent, selector: "ircc-cl-lib-nav-divider", inputs: ["config", "id"] }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navigationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-navigation', template: "<div\n  [id]=\"config.id\"\n  [attr.size]=\"config.size\"\n  class=\"lib-navigation\"\n  [ngClass]=\"{ fixed: config.fixed && wrapperFixed }\"\n  [style.max-width]=\"\n    wrapperFixed && wrapperWidth && wrapperWidth > 0\n      ? wrapperWidth + 'px'\n      : 'none'\n  \"\n  #navigation\n>\n  <div\n    class=\"navigation-header\"\n    [class]=\"navigationClass()\"\n    #navigationHeader\n  >\n    <ircc-cl-lib-icon\n      class=\"icon-leading\"\n      [config]=\"{ FA_keywords: config?.iconLeading || '' }\"\n      (click)=\"clickIconLeading(config.id + '_icon_leading')\"\n      [attr.size]=\"config.size\"\n    ></ircc-cl-lib-icon>\n    <ng-container *ngIf=\"config?.label\">\n      <h3>{{ config?.label || '' | translate }}</h3>\n    </ng-container>\n    <ircc-cl-lib-icon\n      [id]=\"config.id + '_icon_trailing'\"\n      class=\"icon-trailing\"\n      [attr.size]=\"config.size\"\n      [config]=\"{ FA_keywords: config?.iconTrailing || '' }\"\n      (click)=\"clickIconTrailing(config.id + '_icon_trailing')\"\n    ></ircc-cl-lib-icon>\n  </div>\n\n  <div #navigationAreaScroll>\n    <!-- ignore-->\n    <!-- prettier-ignore -->\n    <div class=\"navigation-content-top\" #navigationContentTop ><ng-content select=\"[navigationContentTop]\"></ng-content></div>\n\n    <!-- TODO: Document this like crazy - recursive templating is cool, but EXTREMELY unusual -->\n    <div\n      class=\"navigation-area\"\n      #navigationArea\n    >\n      <ul class=\"parent-navigation\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            recursiveListTmpl;\n            context: { list: this.config.navigationConfig, index: 0 }\n          \"\n        ></ng-container>\n      </ul>\n    </div>\n\n    <ng-template\n      #recursiveListTmpl\n      let-list=\"list\"\n      let-index=\"index\"\n    >\n      <li *ngFor=\"let item of list\">\n        <ng-container [ngSwitch]=\"item.type\">\n          <!--Type Heading-->\n          <ng-container *ngSwitchCase=\"'heading'\"\n            ><ircc-cl-lib-nav-header\n              [attr.size]=\"config.size\"\n              [size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul></ircc-cl-lib-nav-header\n          ></ng-container>\n\n          <!--Type Link-->\n          <ng-container *ngSwitchCase=\"'link'\">\n            <ircc-cl-lib-nav-item\n              [attr.size]=\"config.size\"\n              [size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul></ircc-cl-lib-nav-item\n          ></ng-container>\n\n          <!--Type Accordion-->\n          <ng-container *ngSwitchCase=\"'accordion'\">\n            <ircc-cl-lib-nav-accordion\n              [attr.size]=\"config.size\"\n              [size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul\n            ></ircc-cl-lib-nav-accordion>\n          </ng-container>\n\n          <ng-container *ngSwitchCase=\"'divider'\">\n            <ircc-cl-lib-nav-divider\n              [attr.size]=\"config.size\"\n              [config]=\"item\"\n            >\n              <ul\n                *ngIf=\"item.children.length > 0\"\n                class=\"child-navigation\"\n                [class]=\"getPaddingChildrenPadding(index)\"\n              >\n                <ng-container\n                  *ngTemplateOutlet=\"\n                    recursiveListTmpl;\n                    context: { list: item.children, index: setIndex(index) }\n                  \"\n                ></ng-container></ul\n            ></ircc-cl-lib-nav-divider>\n          </ng-container>\n        </ng-container>\n      </li>\n    </ng-template>\n\n    <!-- prettier-ignore -->\n    <div class=\"navigation-content-bottom\" #navigationContentBottom><ng-content select=\"[navigationContentBottom]\"></ng-content></div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: NavigationService }, { type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { navigationHeader: [{
                type: ViewChild,
                args: ['navigationHeader', { static: false }]
            }], navigationContentTop: [{
                type: ViewChild,
                args: ['navigationContentTop', { static: false }]
            }], navigationContentBottom: [{
                type: ViewChild,
                args: ['navigationContentBottom', { static: false }]
            }], navigationArea: [{
                type: ViewChild,
                args: ['navigationArea', { static: false }]
            }], navigationAreaScroll: [{
                type: ViewChild,
                args: ['navigationAreaScroll', { static: false }]
            }], navigation: [{
                type: ViewChild,
                args: ['navigation', { static: false }]
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], iconLeading: [{
                type: Input
            }], iconTrailing: [{
                type: Input
            }], size: [{
                type: Input
            }], navigationConfig: [{
                type: Input
            }] } });

class navItemStatusComponent {
    constructor() {
        this.status = 'notStarted';
    }
    ngOnInit() {
    }
}
navItemStatusComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemStatusComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
navItemStatusComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: navItemStatusComponent, selector: "ircc-cl-lib-nav-item-status", inputs: { status: "status" }, ngImport: i0, template: "<div>\n  <ng-container [ngSwitch]=\"status\">\n    <ng-container *ngSwitchCase=\"'notStarted'\">\n      <ircc-cl-lib-indicator></ircc-cl-lib-indicator>\n    </ng-container>\n  </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "component", type: IndicatorComponent, selector: "ircc-cl-lib-indicator", inputs: ["config", "size", "type", "icon", "category", "purpose", "status", "palette", "ariaLabel", "tabIndex"] }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: navItemStatusComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-nav-item-status', template: "<div>\n  <ng-container [ngSwitch]=\"status\">\n    <ng-container *ngSwitchCase=\"'notStarted'\">\n      <ircc-cl-lib-indicator></ircc-cl-lib-indicator>\n    </ng-container>\n  </ng-container>\n</div>\n" }]
        }], propDecorators: { status: [{
                type: Input
            }] } });

const IrccDsNavigationComponents = [
    navigationComponent,
    navItemHeadingComponent,
    navItemNavComponent,
    navItemAccordionComponent,
    navItemDividerComponent,
    navItemStatusComponent
];
class IrccDsAngularNavigationModule {
}
IrccDsAngularNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IrccDsAngularNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularNavigationModule, declarations: [navigationComponent,
        navItemHeadingComponent,
        navItemNavComponent,
        navItemAccordionComponent,
        navItemDividerComponent,
        navItemStatusComponent], imports: [CommonModule, IrccDsAngularComponentsSharedModule, TranslateModule], exports: [navigationComponent,
        navItemHeadingComponent,
        navItemNavComponent,
        navItemAccordionComponent,
        navItemDividerComponent,
        navItemStatusComponent] });
IrccDsAngularNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularNavigationModule, imports: [CommonModule, IrccDsAngularComponentsSharedModule, TranslateModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IrccDsAngularNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...IrccDsNavigationComponents],
                    imports: [CommonModule, IrccDsAngularComponentsSharedModule, TranslateModule],
                    exports: [...IrccDsNavigationComponents]
                }]
        }] });

var NavigationItemType;
(function (NavigationItemType) {
    NavigationItemType["accordion"] = "accordion";
    NavigationItemType["heading"] = "heading";
    NavigationItemType["link"] = "link";
    NavigationItemType["divider"] = "divider";
})(NavigationItemType || (NavigationItemType = {}));
var NavigationStatus;
(function (NavigationStatus) {
    NavigationStatus["notStarted"] = "notStarted";
    NavigationStatus["inProgress"] = "inProgress";
    NavigationStatus["complete"] = "complete";
    NavigationStatus["locked"] = "locked";
})(NavigationStatus || (NavigationStatus = {}));

/*
 * Public API Surface of ircc-ds-angular-component-library
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ARIA_TEXT, AutoCompleteComponent, AutocompleteComponent, BannerComponent, BannerService, BannerSize, BannerType, BreadcrumbComponent, BreadcrumbLinkComponent, ButtonCategories, ButtonColor, ButtonComponent, ButtonIconDirection, ButtonSize, CANADA_LOGO_ARIA_LABEL_ENGLISH, CANADA_LOGO_ARIA_LABEL_FRENCH, CLASS_TRASHCAN, CLASS_X_MARK, CTAType, CheckboxComponent, ChipItemComponent, ChipListComponent, DATE_PICKER_DAY_CONTROL_ID_EXTENSION, DATE_PICKER_LABELS_EN, DATE_PICKER_LABELS_FR, DATE_PICKER_MONTHS_EN, DATE_PICKER_MONTHS_FR, DATE_PICKER_MONTH_CONTROL_ID_EXTENSION, DATE_PICKER_PLACEHOLDER_DAY_EN, DATE_PICKER_PLACEHOLDER_DAY_FR, DATE_PICKER_PLACEHOLDER_MONTH_EN, DATE_PICKER_PLACEHOLDER_MONTH_FR, DATE_PICKER_PLACEHOLDER_YEAR_EN, DATE_PICKER_PLACEHOLDER_YEAR_FR, DATE_PICKER_UNKOWN_EN, DATE_PICKER_UNKOWN_FR, DATE_PICKER_YEAR_CONTROL_ID_EXTENSION, DROPDOWN_ARIA, DSFullSizes, DSOrientations, DSSizes, DSViewPortSize, DatePickerComponent, DropDownActions, DropdownComponent, DropdownTypes, DynamicImageComponent, ERROR_TEXT_STUB, ErrorComponent, FLYOUT_CURRENT_SELECTED, FlyoutComponent, FlyoutOptionComponent, FooterComponent, GOV_LOGO_ALT_TEXT_EN, GOV_LOGO_ALT_TEXT_FR, HEADER_IMG_LINK_EN, HEADER_IMG_LINK_FR, HELP_ICON_ALT, HeaderComponent, HiddenNavComponent, IFlyoutOptionType, IFlyoutSelectTypes, IconButtonCategories, IconButtonComponent, IconComponent, IndicatorComponent, IndicatorPalette, IndicatorPurpose, IndicatorStatus, IndicatorTreatment, IndicatorType, InputComponent, InputTypes, IrccDsAngularBannerModule, IrccDsAngularComponentsSharedModule, IrccDsAngularFormComponentsModule, IrccDsAngularHeaderFooterModule, IrccDsAngularLegacyOldModule, IrccDsAngularNavigationModule, LANGUAGE_SWITCH_TEXT_ENGLISH, LANGUAGE_SWITCH_TEXT_ENGLISH_MOBILE, LANGUAGE_SWITCH_TEXT_FRENCH, LANGUAGE_SWITCH_TEXT_FRENCH_MOBILE, LabelButtonService, LabelComponent, LanguageHeaderFooterSwitchService, LanguageSwitchComponent, LinkType, MAX_CHAR_LIMIT_EN, MAX_CHAR_LIMIT_FR, MultiCheckboxComponent, MultiCheckboxService, NavigationItemType, NavigationService, NavigationStatus, Orientations, PROGRESS_INDICATOR_STEP_EN, PROGRESS_INDICATOR_STEP_FR, ProgressIndicatorComponent, ProgressTagsComponent, RadioInputComponent, ResizableTypes, SPINNER_LABELS_EN, SPINNER_LABELS_FR, SearchInputComponent, SecondaryChipsComponent, SelectComponent, SpinnerComponent, SpinnerType, StandAloneFunctions, TAG_LABELS_EN, TAG_LABELS_FR, TabsComponent, TagType, TextareaComponent, ThemeSwitchComponent, WARNING_CHAR_LIMIT_EN, WARNING_CHAR_LIMIT_FR, autocompletePipe, matchType, navItemAccordionComponent, navItemDividerComponent, navItemHeadingComponent, navItemNavComponent, navItemStatusComponent, navigationComponent };
//# sourceMappingURL=ircc-ds-angular-component-library.mjs.map
