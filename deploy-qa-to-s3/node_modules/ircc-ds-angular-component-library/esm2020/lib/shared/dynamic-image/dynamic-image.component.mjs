import { Component, Input, ViewChild } from '@angular/core';
import { DSViewPortSize } from '../../../shared/constants/jl-components.constants';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
export class DynamicImageComponent {
    constructor(translate, renderer, el) {
        this.translate = translate;
        this.renderer = renderer;
        this.el = el;
        this.config = {
            id: '',
            breakpoints: [{ maxWidth: DSViewPortSize.default, src: '' }],
            altText: '',
            defaultSrc: '',
            lazyLoad: false
        };
        this.id = '';
        this.altText = '';
        this.defaultSrc = '';
        this.lazyLoad = false;
    }
    ngOnInit() {
        if (this.id)
            this.config.id = this.id;
        if (this.breakpoints)
            this.config.breakpoints = this.breakpoints;
        if (this.altText)
            this.config.altText = this.altText;
        if (this.defaultSrc)
            this.config.defaultSrc = this.defaultSrc;
        if (this.lazyLoad)
            this.config.lazyLoad = this.lazyLoad;
    }
    ngAfterViewInit() {
        this.updateImageSrc();
        window.addEventListener('resize', () => this.updateImageSrc());
    }
    updateImageSrc() {
        if (this.image?.nativeElement) {
            const screenWidth = window.innerWidth;
            // Find the matching breakpoint for the current screen width
            const breakpoint = this.config.breakpoints.find((breakpoint) => screenWidth <= breakpoint.maxWidth);
            if (breakpoint) {
                // Set the src attribute of the image to the matched breakpoint's src
                this.renderer.setAttribute(this.image?.nativeElement, 'src', breakpoint.src);
            }
            else {
                // If no matching breakpoint is found, use the default src image
                this.renderer.setAttribute(this.image?.nativeElement, 'src', this.config.defaultSrc);
            }
        }
    }
}
DynamicImageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DynamicImageComponent, deps: [{ token: i1.TranslateService }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
DynamicImageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: DynamicImageComponent, selector: "ircc-cl-lib-dynamic-image", inputs: { config: "config", id: "id", breakpoints: "breakpoints", altText: "altText", defaultSrc: "defaultSrc", lazyLoad: "lazyLoad" }, viewQueries: [{ propertyName: "image", first: true, predicate: ["image"], descendants: true, static: true }], ngImport: i0, template: "<div\n  id=\"{{ config.id + '-container' }}\"\n  class=\"dynamic-image-wrapper\"\n>\n  <img\n    #image\n    [alt]=\"config.altText || '' | translate\"\n    [attr.loading]=\"config.lazyLoad ? 'lazy' : null\"\n  />\n</div>\n", dependencies: [{ kind: "pipe", type: i1.TranslatePipe, name: "translate" }], preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: DynamicImageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ircc-cl-lib-dynamic-image', template: "<div\n  id=\"{{ config.id + '-container' }}\"\n  class=\"dynamic-image-wrapper\"\n>\n  <img\n    #image\n    [alt]=\"config.altText || '' | translate\"\n    [attr.loading]=\"config.lazyLoad ? 'lazy' : null\"\n  />\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { image: [{
                type: ViewChild,
                args: ['image', { static: true }]
            }], config: [{
                type: Input
            }], id: [{
                type: Input
            }], breakpoints: [{
                type: Input
            }], altText: [{
                type: Input
            }], defaultSrc: [{
                type: Input
            }], lazyLoad: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1pbWFnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9jb21wb25lbnQtbGliL3NyYy9saWIvc2hhcmVkL2R5bmFtaWMtaW1hZ2UvZHluYW1pYy1pbWFnZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9jb21wb25lbnQtbGliL3NyYy9saWIvc2hhcmVkL2R5bmFtaWMtaW1hZ2UvZHluYW1pYy1pbWFnZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFJTCxTQUFTLEVBRVYsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1EQUFtRCxDQUFDOzs7QUFpQm5GLE1BQU0sT0FBTyxxQkFBcUI7SUFrQmhDLFlBQ1UsU0FBMkIsRUFDM0IsUUFBbUIsRUFDbkIsRUFBYztRQUZkLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBQzNCLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQW5CZixXQUFNLEdBQWlDO1lBQzlDLEVBQUUsRUFBRSxFQUFFO1lBQ04sV0FBVyxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsY0FBYyxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDNUQsT0FBTyxFQUFFLEVBQUU7WUFDWCxVQUFVLEVBQUUsRUFBRTtZQUNkLFFBQVEsRUFBRSxLQUFLO1NBQ2hCLENBQUM7UUFFTyxPQUFFLEdBQVcsRUFBRSxDQUFDO1FBSWhCLFlBQU8sR0FBVyxFQUFFLENBQUM7UUFDckIsZUFBVSxHQUFZLEVBQUUsQ0FBQztRQUN6QixhQUFRLEdBQVksS0FBSyxDQUFDO0lBTWhDLENBQUM7SUFFSixRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUMsRUFBRTtZQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDdEMsSUFBSSxJQUFJLENBQUMsV0FBVztZQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDakUsSUFBSSxJQUFJLENBQUMsT0FBTztZQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDckQsSUFBSSxJQUFJLENBQUMsVUFBVTtZQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDOUQsSUFBSSxJQUFJLENBQUMsUUFBUTtZQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDMUQsQ0FBQztJQUVELGVBQWU7UUFDYixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQsY0FBYztRQUNaLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxhQUFhLEVBQUU7WUFDN0IsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztZQUV0Qyw0REFBNEQ7WUFDNUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUM3QyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsV0FBVyxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQ25ELENBQUM7WUFFRixJQUFJLFVBQVUsRUFBRTtnQkFDZCxxRUFBcUU7Z0JBQ3JFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUN4QixJQUFJLENBQUMsS0FBSyxFQUFFLGFBQWEsRUFDekIsS0FBSyxFQUNMLFVBQVUsQ0FBQyxHQUFHLENBQ2YsQ0FBQzthQUNIO2lCQUFNO2dCQUNMLGdFQUFnRTtnQkFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQ3hCLElBQUksQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUN6QixLQUFLLEVBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQ3ZCLENBQUM7YUFDSDtTQUNGO0lBQ0gsQ0FBQzs7bUhBOURVLHFCQUFxQjt1R0FBckIscUJBQXFCLHVUQzNCbEMsaU9BVUE7NEZEaUJhLHFCQUFxQjtrQkFKakMsU0FBUzsrQkFDRSwyQkFBMkI7d0pBSUMsS0FBSztzQkFBMUMsU0FBUzt1QkFBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUMzQixNQUFNO3NCQUFkLEtBQUs7Z0JBUUcsRUFBRTtzQkFBVixLQUFLO2dCQUNHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBR0csT0FBTztzQkFBZixLQUFLO2dCQUNHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBQ0csUUFBUTtzQkFBaEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIFJlbmRlcmVyMixcbiAgRWxlbWVudFJlZixcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgVmlld0NoaWxkLFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBEU1ZpZXdQb3J0U2l6ZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvamwtY29tcG9uZW50cy5jb25zdGFudHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElEeW5hbWljSW1hZ2VDb21wb25lbnRDb25maWcge1xuICBpZDogc3RyaW5nO1xuICBicmVha3BvaW50czogSUJyZWFrcG9pbnRbXTtcbiAgZGVmYXVsdFNyYzogc3RyaW5nO1xuICBhbHRUZXh0OiBzdHJpbmc7XG4gIGxhenlMb2FkPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSUJyZWFrcG9pbnQge1xuICBtYXhXaWR0aDogRFNWaWV3UG9ydFNpemU7XG4gIHNyYzogc3RyaW5nO1xufVxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaXJjYy1jbC1saWItZHluYW1pYy1pbWFnZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9keW5hbWljLWltYWdlLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBEeW5hbWljSW1hZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBAVmlld0NoaWxkKCdpbWFnZScsIHsgc3RhdGljOiB0cnVlIH0pIGltYWdlOiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuICBASW5wdXQoKSBjb25maWc6IElEeW5hbWljSW1hZ2VDb21wb25lbnRDb25maWcgPSB7XG4gICAgaWQ6ICcnLFxuICAgIGJyZWFrcG9pbnRzOiBbeyBtYXhXaWR0aDogRFNWaWV3UG9ydFNpemUuZGVmYXVsdCwgc3JjOiAnJyB9XSxcbiAgICBhbHRUZXh0OiAnJyxcbiAgICBkZWZhdWx0U3JjOiAnJyxcbiAgICBsYXp5TG9hZDogZmFsc2VcbiAgfTtcblxuICBASW5wdXQoKSBpZDogc3RyaW5nID0gJyc7XG4gIEBJbnB1dCgpIGJyZWFrcG9pbnRzOlxuICAgIHwgW3sgbWF4V2lkdGg6IERTVmlld1BvcnRTaXplLmRlZmF1bHQ7IHNyYzogJycgfV1cbiAgICB8IHVuZGVmaW5lZDtcbiAgQElucHV0KCkgYWx0VGV4dDogc3RyaW5nID0gJyc7XG4gIEBJbnB1dCgpIGRlZmF1bHRTcmM/OiBzdHJpbmcgPSAnJztcbiAgQElucHV0KCkgbGF6eUxvYWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZlxuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMuaWQpIHRoaXMuY29uZmlnLmlkID0gdGhpcy5pZDtcbiAgICBpZiAodGhpcy5icmVha3BvaW50cykgdGhpcy5jb25maWcuYnJlYWtwb2ludHMgPSB0aGlzLmJyZWFrcG9pbnRzO1xuICAgIGlmICh0aGlzLmFsdFRleHQpIHRoaXMuY29uZmlnLmFsdFRleHQgPSB0aGlzLmFsdFRleHQ7XG4gICAgaWYgKHRoaXMuZGVmYXVsdFNyYykgdGhpcy5jb25maWcuZGVmYXVsdFNyYyA9IHRoaXMuZGVmYXVsdFNyYztcbiAgICBpZiAodGhpcy5sYXp5TG9hZCkgdGhpcy5jb25maWcubGF6eUxvYWQgPSB0aGlzLmxhenlMb2FkO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMudXBkYXRlSW1hZ2VTcmMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4gdGhpcy51cGRhdGVJbWFnZVNyYygpKTtcbiAgfVxuXG4gIHVwZGF0ZUltYWdlU3JjKCkge1xuICAgIGlmICh0aGlzLmltYWdlPy5uYXRpdmVFbGVtZW50KSB7XG4gICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBcbiAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIGJyZWFrcG9pbnQgZm9yIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aFxuICAgICAgY29uc3QgYnJlYWtwb2ludCA9IHRoaXMuY29uZmlnLmJyZWFrcG9pbnRzLmZpbmQoXG4gICAgICAgIChicmVha3BvaW50KSA9PiBzY3JlZW5XaWR0aCA8PSBicmVha3BvaW50Lm1heFdpZHRoXG4gICAgICApO1xuICBcbiAgICAgIGlmIChicmVha3BvaW50KSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3JjIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIG1hdGNoZWQgYnJlYWtwb2ludCdzIHNyY1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICB0aGlzLmltYWdlPy5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICdzcmMnLFxuICAgICAgICAgIGJyZWFrcG9pbnQuc3JjXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBtYXRjaGluZyBicmVha3BvaW50IGlzIGZvdW5kLCB1c2UgdGhlIGRlZmF1bHQgc3JjIGltYWdlXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKFxuICAgICAgICAgIHRoaXMuaW1hZ2U/Lm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgJ3NyYycsXG4gICAgICAgICAgdGhpcy5jb25maWcuZGVmYXVsdFNyY1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiPGRpdlxuICBpZD1cInt7IGNvbmZpZy5pZCArICctY29udGFpbmVyJyB9fVwiXG4gIGNsYXNzPVwiZHluYW1pYy1pbWFnZS13cmFwcGVyXCJcbj5cbiAgPGltZ1xuICAgICNpbWFnZVxuICAgIFthbHRdPVwiY29uZmlnLmFsdFRleHQgfHwgJycgfCB0cmFuc2xhdGVcIlxuICAgIFthdHRyLmxvYWRpbmddPVwiY29uZmlnLmxhenlMb2FkID8gJ2xhenknIDogbnVsbFwiXG4gIC8+XG48L2Rpdj5cbiJdfQ==